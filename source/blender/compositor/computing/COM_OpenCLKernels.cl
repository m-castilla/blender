#line 1 ".COM_kernel_opencl.h"
#ifndef __COM_KERNEL_OPENCL_H__
#define __COM_KERNEL_OPENCL_H__

#define __KERNEL_COMPUTE__
#define __KERNEL_OPENCL__

/* no namespaces in opencl */
#define CCL_NAMESPACE_BEGIN
#define CCL_NAMESPACE_END

#ifdef __CL_NOINLINE__
#  define ccl_noinline __attribute__((noinline))
#else
#  define ccl_noinline
#endif

/* in opencl all functions are device functions, so leave this empty */
#define ccl_kernel __kernel void
#define ccl_device
#define ccl_device_inline ccl_device
#define ccl_device_forceinline ccl_device
#define ccl_device_noinline ccl_device ccl_noinline
#define ccl_device_noinline_cpu ccl_device
#define ccl_may_alias
#define ccl_static_constant static __constant
#define ccl_constant __constant
#define ccl_global __global
#define ccl_local __local
#define ccl_local_param __local
#define ccl_private __private
#define ccl_restrict restrict
#define ccl_ref
#define ccl_align(n) __attribute__((aligned(n)))
#define ccl_optional_struct_init

#if __OPENCL_VERSION__ >= 200
#  define ccl_loop_no_unroll __attribute__((opencl_unroll_hint(1)))
#else
#  define ccl_loop_no_unroll
#endif

#define ccl_addr_space

#define ATTR_FALLTHROUGH

/* no assert in opencl */
#define kernel_assert(cond)

/* make_type definitions with opencl style element initializers */
#ifdef make_float2
#  undef make_float2
#endif
#ifdef make_float3
#  undef make_float3
#endif
#ifdef make_float3_1
#  undef make_float3_1
#endif
#ifdef make_float3_4
#  undef make_float3_4
#endif
#ifdef make_float4
#  undef make_float4
#endif
#ifdef make_float4_1
#  undef make_float4_1
#endif
#ifdef make_float4_3
#  undef make_float4_3
#endif
#ifdef make_int2
#  undef make_int2
#endif
#ifdef make_int3
#  undef make_int3
#endif
#ifdef make_int3_1
#  undef make_int3_1
#endif
#ifdef make_int4
#  undef make_int4
#endif
#ifdef make_int4_1
#  undef make_int4_1
#endif

#define make_float2(x, y) ((float2)(x, y))
#define make_float3(x, y, z) ((float3)(x, y, z))
#define make_float3_1(f) ((float3)(f, f, f))
#define make_float3_4(f4) ((float3)(f4.x, f4.y, f4.z))
#define make_float4(x, y, z, w) ((float4)(x, y, z, w))
#define make_float4_1(f) ((float4)(f, f, f, f))
#define make_float4_3(f3) ((float4)(f3, 0.0f))
#define make_int2(x, y) ((int2)(x, y))
#define make_int3(x, y, z) ((int3)(x, y, z))
#define make_int3_1(i) ((int3)(i, i, i))
#define make_int4(x, y, z, w) ((int4)(x, y, z, w))
#define make_int4_1(i) ((int4)(i, i, i, i))

/* math functions */
#define __uint_as_float(x) as_float(x)
#define __float_as_uint(x) as_uint(x)
#define __int_as_float(x) as_float(x)
#define __float_as_int(x) as_int(x)
#define powf(x, y) pow(((float)(x)), ((float)(y)))
#define fabsf(x) fabs(((float)(x)))
#define copysignf(x, y) copysign(((float)(x)), ((float)(y)))
#define asinf(x) asin(((float)(x)))
#define acosf(x) acos(((float)(x)))
#define atanf(x) atan(((float)(x)))
#define floorf(x) floor(((float)(x)))
#define ceilf(x) ceil(((float)(x)))
#define hypotf(x, y) hypot(((float)(x)), ((float)(y)))
#define atan2f(x, y) atan2(((float)(x)), ((float)(y)))
#define fmaxf(x, y) fmax(((float)(x)), ((float)(y)))
#define fminf(x, y) fmin(((float)(x)), ((float)(y)))
#define fmodf(x, y) fmod((float)(x), (float)(y))
#define sinhf(x) sinh(((float)(x)))
#define coshf(x) cosh(((float)(x)))
#define tanhf(x) tanh(((float)(x)))
#define roundf(x) round(((float)(x)))

/* Use native functions with possibly lower precision for performance,
 * no issues found so far. */
#if 1
#  define sinf(x) native_sin(((float)(x)))
#  define cosf(x) native_cos(((float)(x)))
#  define tanf(x) native_tan(((float)(x)))
#  define expf(x) native_exp(((float)(x)))
#  define sqrtf(x) native_sqrt(((float)(x)))
#  define logf(x) native_log(((float)(x)))
#  define rcp(x) native_recip(x)
#else
#  define sinf(x) sin(((float)(x)))
#  define cosf(x) cos(((float)(x)))
#  define tanf(x) tan(((float)(x)))
#  define expf(x) exp(((float)(x)))
#  define sqrtf(x) sqrt(((float)(x)))
#  define logf(x) log(((float)(x)))
#  define rcp(x) recip(x)
#endif

/* define NULL */
#define NULL 0

/* enable extensions */
#ifdef __KERNEL_CL_KHR_FP16__
#  pragma OPENCL EXTENSION cl_khr_fp16 : enable
#endif

#line 1 ".kernel_util/COM_kernel_algo.h"
#ifndef __COM_KERNEL_ALGO_H__
#define __COM_KERNEL_ALGO_H__

#line 1 ".kernel_util/COM_kernel_color.h"
#ifndef __COM_KERNEL_COLOR_H__
#define __COM_KERNEL_COLOR_H__

/* All this methods has been taken from blendlib math_color.c file.
 * They are adapted for kernel compatibility with float4 vectors and normalized colors */
#line 1 ".kernel_util/COM_kernel_geom.h"
#ifndef __COM_KERNEL_GEOM_H__
#define __COM_KERNEL_GEOM_H__

#line 1 ".kernel_util/COM_kernel_math.h"
#ifndef __COM_KERNEL_MATH_H__
#define __COM_KERNEL_MATH_H__

/* Math
 *
 * Basic math functions on scalar and vector types. This header is used by
 * both the kernel code when compiled as C++, and other C++ non-kernel code. */

#ifndef __KERNEL_COMPUTE__
#  include <cmath>
#endif

#ifndef __KERNEL_OPENCL__
#  include <float.h>
#  include <math.h>
#  include <stdio.h>
#endif /* __KERNEL_OPENCL__ */

#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 19 ".kernel_util/COM_kernel_math.h"

CCL_NAMESPACE_BEGIN

/* Float Pi variations */

/* Division */
#ifndef M_PI_F
#  define M_PI_F (3.1415926535897932f) /* pi */
#endif
#ifndef M_PI_2_F
#  define M_PI_2_F (1.5707963267948966f) /* pi/2 */
#endif
#ifndef M_PI_4_F
#  define M_PI_4_F (0.7853981633974830f) /* pi/4 */
#endif
#ifndef M_1_PI_F
#  define M_1_PI_F (0.3183098861837067f) /* 1/pi */
#endif
#ifndef M_2_PI_F
#  define M_2_PI_F (0.6366197723675813f) /* 2/pi */
#endif
#ifndef M_1_2PI_F
#  define M_1_2PI_F (0.1591549430918953f) /* 1/(2*pi) */
#endif
#ifndef M_SQRT_PI_8_F
#  define M_SQRT_PI_8_F (0.6266570686577501f) /* sqrt(pi/8) */
#endif
#ifndef M_LN_2PI_F
#  define M_LN_2PI_F (1.8378770664093454f) /* ln(2*pi) */
#endif

/* Multiplication */
#ifndef M_2PI_F
#  define M_2PI_F (6.2831853071795864f) /* 2*pi */
#endif
#ifndef M_4PI_F
#  define M_4PI_F (12.566370614359172f) /* 4*pi */
#endif

/* Float sqrt variations */
#ifndef M_SQRT2_F
#  define M_SQRT2_F (1.4142135623730950f) /* sqrt(2) */
#endif
#ifndef M_LN2_F
#  define M_LN2_F (0.6931471805599453f) /* ln(2) */
#endif
#ifndef M_LN10_F
#  define M_LN10_F (2.3025850929940457f) /* ln(10) */
#endif

#ifndef RAD2DEGF
#  define RAD2DEGF(_rad) ((_rad) * (float)(180.0f / M_PI_F))
#endif
#ifndef DEG2RADF
#  define DEG2RADF(_deg) ((_deg) * (float)(M_PI_F / 180.0f))
#endif

/* Scalar */

#ifdef _WIN32
#  ifndef __KERNEL_OPENCL__
ccl_device_inline float fmaxf(float a, float b)
{
  return (a > b) ? a : b;
}

ccl_device_inline float fminf(float a, float b)
{
  return (a < b) ? a : b;
}
#  endif /* !__KERNEL_OPENCL__ */
#endif   /* _WIN32 */

#ifndef __KERNEL_COMPUTE__
using std::isfinite;
using std::isnan;
using std::sqrt;

ccl_device_inline int abs(const int x)
{
  return (x > 0) ? x : -x;
}

ccl_device_inline int max(const int a, const int b)
{
  return (a > b) ? a : b;
}

ccl_device_inline int min(const int a, const int b)
{
  return (a < b) ? a : b;
}

ccl_device_inline float max(const float a, const float b)
{
  return (a > b) ? a : b;
}

ccl_device_inline float min(const float a, const float b)
{
  return (a < b) ? a : b;
}
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline float fminf3(const float a, const float b, const float c)
{
  return fminf(fminf(a, b), c);
}

ccl_device_inline float fmaxf3(const float a, const float b, const float c)
{
  return fmaxf(fmaxf(a, b), c);
}

ccl_device_inline float fminf4(const float a, const float b, const float c, const float d)
{
  return fminf(fminf(a, b), fminf(c, d));
}

ccl_device_inline float fmaxf4(const float a, const float b, const float c, const float d)
{
  return fmaxf(fmaxf(a, b), fmaxf(c, d));
}

#ifndef __KERNEL_OPENCL__
/* Int/Float conversion */

ccl_device_inline int as_int(uint i)
{
  union {
    uint ui;
    int i;
  } u;
  u.ui = i;
  return u.i;
}

ccl_device_inline uint as_uint(int i)
{
  union {
    uint ui;
    int i;
  } u;
  u.i = i;
  return u.ui;
}

ccl_device_inline uint as_uint(float f)
{
  union {
    uint i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline int __float_as_int(float f)
{
  union {
    int i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline float __int_as_float(int i)
{
  union {
    int i;
    float f;
  } u;
  u.i = i;
  return u.f;
}

ccl_device_inline uint __float_as_uint(float f)
{
  union {
    uint i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline float __uint_as_float(uint i)
{
  union {
    uint i;
    float f;
  } u;
  u.i = i;
  return u.f;
}

ccl_device_inline int4 __float4_as_int4(float4 f)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(f.m128));
#  else
  return make_int4(
      __float_as_int(f.x), __float_as_int(f.y), __float_as_int(f.z), __float_as_int(f.w));
#  endif
}

ccl_device_inline float4 __int4_as_float4(int4 i)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_castsi128_ps(i.m128));
#  else
  return make_float4(
      __int_as_float(i.x), __int_as_float(i.y), __int_as_float(i.z), __int_as_float(i.w));
#  endif
}
#endif /* __KERNEL_OPENCL__ */

/* Versions of functions which are safe for fast math. */
ccl_device_inline bool isnan_safe(const float f)
{
  unsigned int x = __float_as_uint(f);
  return (x << 1) > 0xff000000u;
}

ccl_device_inline bool isfinite_safe(const float f)
{
  /* By IEEE 754 rule, 2*Inf equals Inf */
  unsigned int x = __float_as_uint(f);
  return (f == f) && (x == 0 || x == (1u << 31) || (f != 2.0f * f)) && !((x << 1) > 0xff000000u);
}

ccl_device_inline float ensure_finite(const float v)
{
  return isfinite_safe(v) ? v : 0.0f;
}

#ifndef __KERNEL_OPENCL__
ccl_device_inline int clamp(const int a, const int mn, const int mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float clamp(const float a, const float mn, const float mx)
{
  return fminf(fmaxf(a, mn), mx);
}

ccl_device_inline float mix(const float a, const float b, const float t)
{
  return a + t * (b - a);
}

ccl_device_inline float smoothstep(const float edge0, const float edge1, const float x)
{
  float result;
  if (x < edge0)
    result = 0.0f;
  else if (x >= edge1)
    result = 1.0f;
  else {
    float t = (x - edge0) / (edge1 - edge0);
    result = (3.0f - 2.0f * t) * (t * t);
  }
  return result;
}

#endif /* __KERNEL_OPENCL__ */

#ifndef __KERNEL_CUDA__
ccl_device_inline float saturate(const float a)
{
  return clamp(a, 0.0f, 1.0f);
}
#endif /* __KERNEL_CUDA__ */

ccl_device_inline int float_to_int(const float f)
{
  return (int)f;
}

ccl_device_inline int floor_to_int(const float f)
{
  return float_to_int(floorf(f));
}

ccl_device_inline int quick_floor_to_int(const float x)
{
  return float_to_int(x) - ((x < 0) ? 1 : 0);
}

ccl_device_inline float floorfrac(const float x, int *i)
{
  *i = quick_floor_to_int(x);
  return x - *i;
}

ccl_device_inline int ceil_to_int(const float f)
{
  return float_to_int(ceilf(f));
}

ccl_device_inline float fractf(const float x)
{
  return x - floorf(x);
}

/* Adapted from godotengine math_funcs.h. */
ccl_device_inline float wrapf(const float value, const float max, const float min)
{
  float range = max - min;
  return (range != 0.0f) ? value - (range * floorf((value - min) / range)) : min;
}

ccl_device_inline float pingpongf(const float a, const float b)
{
  return (b != 0.0f) ? fabsf(fractf((a - b) / (b * 2.0f)) * b * 2.0f - b) : 0.0f;
}

ccl_device_inline float smoothminf(const float a, const float b, const float k)
{
  if (k != 0.0f) {
    float h = fmaxf(k - fabsf(a - b), 0.0f) / k;
    return fminf(a, b) - h * h * h * k * (1.0f / 6.0f);
  }
  else {
    return fminf(a, b);
  }
}

ccl_device_inline float signf(const float f)
{
  return (f < 0.0f) ? -1.0f : 1.0f;
}

ccl_device_inline float nonzerof(const float f, const float eps)
{
  if (fabsf(f) < eps)
    return signf(f) * eps;
  else
    return f;
}

/* Signum function testing for zero. Matches GLSL and OSL functions. */
ccl_device_inline float compatible_signf(const float f)
{
  if (f == 0.0f) {
    return 0.0f;
  }
  else {
    return signf(f);
  }
}

ccl_device_inline float smoothstepf(const float f)
{
  float ff = f * f;
  return (3.0f * ff - 2.0f * ff * f);
}

ccl_device_inline int mod(const int x, const int m)
{
  return (x % m + m) % m;
}

ccl_device_inline float3 float2_to_float3(const float2 a)
{
  return make_float3(a.x, a.y, 0.0f);
}

ccl_device_inline float3 float4_to_float3(const float4 a)
{
  return make_float3(a.x, a.y, a.z);
}

ccl_device_inline float4 float3_to_float4(const float3 a)
{
  return make_float4(a.x, a.y, a.z, 1.0f);
}

ccl_device_inline float inverse_lerp(const float a, const float b, const float x)
{
  return (x - a) / (b - a);
}

/* Cubic interpolation between b and c, a and d are the previous and next point. */
ccl_device_inline float cubic_interp(
    const float a, const float b, const float c, const float d, const float x)
{
  return 0.5f *
             (((d + 3.0f * (b - c) - a) * x + (2.0f * a - 5.0f * b + 4.0f * c - d)) * x +
              (c - a)) *
             x +
         b;
}

CCL_NAMESPACE_END

#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 418 ".kernel_util/COM_kernel_math.h"

#line 1 ".kernel_util/COM_kernel_math_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT2_H__
#define __COM_KERNEL_MATH_INT2_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline bool operator==(const int2 a, const int2 b);
ccl_device_inline int2 operator+(const int2 &a, const int2 &b);
ccl_device_inline int2 operator+=(int2 &a, const int2 &b);
ccl_device_inline int2 operator-(const int2 &a, const int2 &b);
ccl_device_inline int2 operator*(const int2 &a, const int2 &b);
ccl_device_inline int2 operator/(const int2 &a, const int2 &b);
#endif /* !__KERNEL_OPENCL__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline bool operator==(const int2 a, const int2 b)
{
  return (a.x == b.x && a.y == b.y);
}

ccl_device_inline int2 operator+(const int2 &a, const int2 &b)
{
  return make_int2(a.x + b.x, a.y + b.y);
}

ccl_device_inline int2 operator+=(int2 &a, const int2 &b)
{
  return a = a + b;
}

ccl_device_inline int2 operator-(const int2 &a, const int2 &b)
{
  return make_int2(a.x - b.x, a.y - b.y);
}

ccl_device_inline int2 operator*(const int2 &a, const int2 &b)
{
  return make_int2(a.x * b.x, a.y * b.y);
}

ccl_device_inline int2 operator/(const int2 &a, const int2 &b)
{
  return make_int2(a.x / b.x, a.y / b.y);
}
#endif /* !__KERNEL_OPENCL__ */

CCL_NAMESPACE_END

#endif

#line 420 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT3_H__
#define __COM_KERNEL_MATH_INT3_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline int3 min(int3 a, int3 b);
ccl_device_inline int3 max(int3 a, int3 b);
ccl_device_inline int3 clamp(const int3 &a, int mn, int mx);
ccl_device_inline int3 clamp(const int3 &a, int3 &mn, int mx);
#endif /* !__KERNEL_OPENCL__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline int3 min(int3 a, int3 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int3(_mm_min_epi32(a.m128, b.m128));
#  else
  return make_int3(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));
#  endif
}

ccl_device_inline int3 max(int3 a, int3 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int3(_mm_max_epi32(a.m128, b.m128));
#  else
  return make_int3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));
#  endif
}

ccl_device_inline int3 clamp(const int3 &a, int mn, int mx)
{
#  ifdef __KERNEL_SSE__
  return min(max(a, make_int3_1(mn)), make_int3_1(mx));
#  else
  return make_int3(clamp(a.x, mn, mx), clamp(a.y, mn, mx), clamp(a.z, mn, mx));
#  endif
}

ccl_device_inline int3 clamp(const int3 &a, int3 &mn, int mx)
{
#  ifdef __KERNEL_SSE__
  return min(max(a, mn), make_int3_1(mx));
#  else
  return make_int3(clamp(a.x, mn.x, mx), clamp(a.y, mn.y, mx), clamp(a.z, mn.z, mx));
#  endif
}

ccl_device_inline bool operator==(const int3 &a, const int3 &b)
{
  return a.x == b.x && a.y == b.y && a.z == b.z;
}

ccl_device_inline bool operator!=(const int3 &a, const int3 &b)
{
  return !(a == b);
}

ccl_device_inline bool operator<(const int3 &a, const int3 &b)
{
  return a.x < b.x && a.y < b.y && a.z < b.z;
}

ccl_device_inline int3 operator+(const int3 &a, const int3 &b)
{
#  ifdef __KERNEL_SSE__
  return int3(_mm_add_epi32(a.m128, b.m128));
#  else
  return make_int3(a.x + b.x, a.y + b.y, a.z + b.z);
#  endif
}

ccl_device_inline int3 operator-(const int3 &a, const int3 &b)
{
#  ifdef __KERNEL_SSE__
  return int3(_mm_sub_epi32(a.m128, b.m128));
#  else
  return make_int3(a.x - b.x, a.y - b.y, a.z - b.z);
#  endif
}
#endif /* !__KERNEL_OPENCL__ */

CCL_NAMESPACE_END

#endif /* __COM_kernel_MATH_INT3_H__ */

#line 421 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT4_H__
#define __COM_KERNEL_MATH_INT4_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline int4 operator+(const int4 &a, const int4 &b);
ccl_device_inline int4 operator+=(int4 &a, const int4 &b);
ccl_device_inline int4 operator>>(const int4 &a, int i);
ccl_device_inline int4 operator<<(const int4 &a, int i);
ccl_device_inline int4 operator<(const int4 &a, const int4 &b);
ccl_device_inline int4 operator>=(const int4 &a, const int4 &b);
ccl_device_inline int4 operator&(const int4 &a, const int4 &b);
ccl_device_inline int4 min(int4 a, int4 b);
ccl_device_inline int4 max(int4 a, int4 b);
ccl_device_inline int4 clamp(const int4 &a, const int4 &mn, const int4 &mx);
ccl_device_inline int4 select(const int4 &mask, const int4 &a, const int4 &b);
#endif /* __KERNEL_COMPUTE__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline int4 operator+(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_add_epi32(a.m128, b.m128));
#  else
  return make_int4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
#  endif
}

ccl_device_inline int4 operator+=(int4 &a, const int4 &b)
{
  return a = a + b;
}

ccl_device_inline int4 operator>>(const int4 &a, int i)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_srai_epi32(a.m128, i));
#  else
  return make_int4(a.x >> i, a.y >> i, a.z >> i, a.w >> i);
#  endif
}

ccl_device_inline int4 operator<<(const int4 &a, int i)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_slli_epi32(a.m128, i));
#  else
  return make_int4(a.x << i, a.y << i, a.z << i, a.w << i);
#  endif
}

ccl_device_inline int4 operator<(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_cmplt_epi32(a.m128, b.m128));
#  else
  return make_int4(a.x < b.x, a.y < b.y, a.z < b.z, a.w < b.w);
#  endif
}

ccl_device_inline int4 operator>=(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_xor_si128(_mm_set1_epi32(0xffffffff), _mm_cmplt_epi32(a.m128, b.m128)));
#  else
  return make_int4(a.x >= b.x, a.y >= b.y, a.z >= b.z, a.w >= b.w);
#  endif
}

ccl_device_inline int4 operator&(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_and_si128(a.m128, b.m128));
#  else
  return make_int4(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
#  endif
}

ccl_device_inline int4 min(int4 a, int4 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int4(_mm_min_epi32(a.m128, b.m128));
#  else
  return make_int4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));
#  endif
}

ccl_device_inline int4 max(int4 a, int4 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int4(_mm_max_epi32(a.m128, b.m128));
#  else
  return make_int4(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z), max(a.w, b.w));
#  endif
}

ccl_device_inline int4 clamp(const int4 &a, const int4 &mn, const int4 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline int4 select(const int4 &mask, const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  const __m128 m = _mm_cvtepi32_ps(mask);
  /* TODO(sergey): avoid cvt. */
  return int4(_mm_castps_si128(
      _mm_or_ps(_mm_and_ps(m, _mm_castsi128_ps(a)), _mm_andnot_ps(m, _mm_castsi128_ps(b)))));
#  else
  return make_int4(
      (mask.x) ? a.x : b.x, (mask.y) ? a.y : b.y, (mask.z) ? a.z : b.z, (mask.w) ? a.w : b.w);
#  endif
}

ccl_device_inline int4 load_int4(const int *v)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_loadu_si128((__m128i *)v));
#  else
  return make_int4(v[0], v[1], v[2], v[3]);
#  endif
}
#endif /* __KERNEL_COMPUTE__ */

CCL_NAMESPACE_END

#endif

#line 422 ".kernel_util/COM_kernel_math.h"

#line 1 ".kernel_util/COM_kernel_math_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT2_H__
#define __COM_KERNEL_MATH_FLOAT2_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float2 operator-(const float2 &a);
ccl_device_inline float2 operator*(const float2 &a, const float2 &b);
ccl_device_inline float2 operator*(const float2 &a, float f);
ccl_device_inline float2 operator*(float f, const float2 &a);
ccl_device_inline float2 operator/(float f, const float2 &a);
ccl_device_inline float2 operator/(const float2 &a, float f);
ccl_device_inline float2 operator/(const float2 &a, const float2 &b);
ccl_device_inline float2 operator+(const float2 &a, const float f);
ccl_device_inline float2 operator+(const float2 &a, const float2 &b);
ccl_device_inline float2 operator-(const float2 &a, const float f);
ccl_device_inline float2 operator-(const float2 &a, const float2 &b);
ccl_device_inline float2 operator+=(float2 &a, const float2 &b);
ccl_device_inline float2 operator*=(float2 &a, const float2 &b);
ccl_device_inline float2 operator*=(float2 &a, float f);
ccl_device_inline float2 operator/=(float2 &a, const float2 &b);
ccl_device_inline float2 operator/=(float2 &a, float f);

ccl_device_inline bool operator==(const float2 &a, const float2 &b);
ccl_device_inline bool operator!=(const float2 &a, const float2 &b);

ccl_device_inline float average(const float2 &a);
ccl_device_inline float distance(const float2 &a, const float2 &b);
ccl_device_inline float dot(const float2 &a, const float2 &b);
ccl_device_inline float cross(const float2 &a, const float2 &b);
ccl_device_inline float len(const float2 &a);
ccl_device_inline float2 normalize(const float2 &a);
ccl_device_inline float2 normalize_len(const float2 &a, float *t);
ccl_device_inline float2 safe_normalize(const float2 &a);
ccl_device_inline float2 min(const float2 &a, const float2 &b);
ccl_device_inline float2 max(const float2 &a, const float2 &b);
ccl_device_inline float2 clamp(const float2 &a, const float2 &mn, const float2 &mx);
ccl_device_inline float2 fabs(const float2 &a);
ccl_device_inline float2 as_float2(const float4 &a);
ccl_device_inline float2 interp(const float2 &a, const float2 &b, float t);
ccl_device_inline float2 floor(const float2 &a);
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float2 safe_divide_float2_float(const float2 a, const float b);

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float2 operator-(const float2 &a)
{
  return make_float2(-a.x, -a.y);
}

ccl_device_inline float2 operator*(const float2 &a, const float2 &b)
{
  return make_float2(a.x * b.x, a.y * b.y);
}

ccl_device_inline float2 operator*(const float2 &a, float f)
{
  return make_float2(a.x * f, a.y * f);
}

ccl_device_inline float2 operator*(float f, const float2 &a)
{
  return make_float2(a.x * f, a.y * f);
}

ccl_device_inline float2 operator/(float f, const float2 &a)
{
  return make_float2(f / a.x, f / a.y);
}

ccl_device_inline float2 operator/(const float2 &a, float f)
{
  float invf = 1.0f / f;
  return make_float2(a.x * invf, a.y * invf);
}

ccl_device_inline float2 operator/(const float2 &a, const float2 &b)
{
  return make_float2(a.x / b.x, a.y / b.y);
}

ccl_device_inline float2 operator+(const float2 &a, const float f)
{
  return a + make_float2(f, f);
}

ccl_device_inline float2 operator+(const float2 &a, const float2 &b)
{
  return make_float2(a.x + b.x, a.y + b.y);
}

ccl_device_inline float2 operator-(const float2 &a, const float f)
{
  return a - make_float2(f, f);
}

ccl_device_inline float2 operator-(const float2 &a, const float2 &b)
{
  return make_float2(a.x - b.x, a.y - b.y);
}

ccl_device_inline float2 operator+=(float2 &a, const float2 &b)
{
  return a = a + b;
}

ccl_device_inline float2 operator*=(float2 &a, const float2 &b)
{
  return a = a * b;
}

ccl_device_inline float2 operator*=(float2 &a, float f)
{
  return a = a * f;
}

ccl_device_inline float2 operator/=(float2 &a, const float2 &b)
{
  return a = a / b;
}

ccl_device_inline float2 operator/=(float2 &a, float f)
{
  float invf = 1.0f / f;
  return a = a * invf;
}

ccl_device_inline bool operator==(const float2 &a, const float2 &b)
{
  return (a.x == b.x && a.y == b.y);
}

ccl_device_inline bool operator!=(const float2 &a, const float2 &b)
{
  return !(a == b);
}

ccl_device_inline float average(const float2 &a)
{
  return (a.x + a.y) * (1.0f / 2.0f);
}

ccl_device_inline float distance(const float2 &a, const float2 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float2 &a, const float2 &b)
{
  return a.x * b.x + a.y * b.y;
}

ccl_device_inline float cross(const float2 &a, const float2 &b)
{
  return (a.x * b.y - a.y * b.x);
}

ccl_device_inline float len(const float2 &a)
{
  return sqrtf(dot(a, a));
}

ccl_device_inline float2 normalize(const float2 &a)
{
  return a / len(a);
}

ccl_device_inline float2 normalize_len(const float2 &a, float *t)
{
  *t = len(a);
  return a / (*t);
}

ccl_device_inline float2 safe_normalize(const float2 &a)
{
  float t = len(a);
  return (t != 0.0f) ? a / t : a;
}

ccl_device_inline float2 min(const float2 &a, const float2 &b)
{
  return make_float2(fminf(a.x, b.x), fminf(a.y, b.y));
}

ccl_device_inline float2 max(const float2 &a, const float2 &b)
{
  return make_float2(fmaxf(a.x, b.x), fmaxf(a.y, b.y));
}

ccl_device_inline float2 clamp(const float2 &a, const float2 &mn, const float2 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float2 fabs(const float2 &a)
{
  return make_float2(fabsf(a.x), fabsf(a.y));
}

ccl_device_inline float2 as_float2(const float4 &a)
{
  return make_float2(a.x, a.y);
}

ccl_device_inline float2 interp(const float2 &a, const float2 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float2 mix(const float2 &a, const float2 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float2 floor(const float2 &a)
{
  return make_float2(floorf(a.x), floorf(a.y));
}

#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float2 safe_divide_float2_float(const float2 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float2(0.0f, 0.0f);
}

CCL_NAMESPACE_END

#endif

#line 424 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT3_H__
#define __COM_KERNEL_MATH_FLOAT3_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float3 operator-(const float3 &a);
ccl_device_inline float3 operator*(const float3 &a, const float3 &b);
ccl_device_inline float3 operator*(const float3 &a, const float f);
ccl_device_inline float3 operator*(const float f, const float3 &a);
ccl_device_inline float3 operator/(const float f, const float3 &a);
ccl_device_inline float3 operator/(const float3 &a, const float f);
ccl_device_inline float3 operator/(const float3 &a, const float3 &b);
ccl_device_inline float3 operator+(const float3 &a, const float f);
ccl_device_inline float3 operator+(const float3 &a, const float3 &b);
ccl_device_inline float3 operator-(const float3 &a, const float f);
ccl_device_inline float3 operator-(const float3 &a, const float3 &b);
ccl_device_inline float3 operator+=(float3 &a, const float3 &b);
ccl_device_inline float3 operator-=(float3 &a, const float3 &b);
ccl_device_inline float3 operator*=(float3 &a, const float3 &b);
ccl_device_inline float3 operator*=(float3 &a, float f);
ccl_device_inline float3 operator/=(float3 &a, const float3 &b);
ccl_device_inline float3 operator/=(float3 &a, float f);

ccl_device_inline bool operator==(const float3 &a, const float3 &b);
ccl_device_inline bool operator!=(const float3 &a, const float3 &b);

ccl_device_inline float distance(const float3 &a, const float3 &b);
ccl_device_inline float dot(const float3 &a, const float3 &b);
ccl_device_inline float dot_xy(const float3 &a, const float3 &b);
ccl_device_inline float3 cross(const float3 &a, const float3 &b);
ccl_device_inline float3 normalize(const float3 &a);
ccl_device_inline float3 min(const float3 &a, const float3 &b);
ccl_device_inline float3 max(const float3 &a, const float3 &b);
ccl_device_inline float3 clamp(const float3 &a, const float3 &mn, const float3 &mx);
ccl_device_inline float3 fabs(const float3 &a);
ccl_device_inline float3 mix(const float3 &a, const float3 &b, float t);
ccl_device_inline float3 rcp(const float3 &a);
ccl_device_inline float3 sqrt(const float3 &a);
ccl_device_inline float3 floor(const float3 &a);
ccl_device_inline float3 ceil(const float3 &a);
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float min3(float3 a);
ccl_device_inline float max3(float3 a);
ccl_device_inline float len(const float3 a);
ccl_device_inline float len_squared(const float3 a);

ccl_device_inline float3 reflect(const float3 incident, const float3 normal);
ccl_device_inline float3 project(const float3 v, const float3 v_proj);

ccl_device_inline float3 saturate3(float3 a);
ccl_device_inline float3 safe_normalize(const float3 a);
ccl_device_inline float3 normalize_len(const float3 a, float *t);
ccl_device_inline float3 safe_normalize_len(const float3 a, float *t);
ccl_device_inline float3 safe_divide_float3_float3(const float3 a, const float3 b);
ccl_device_inline float3 safe_divide_float3_float(const float3 a, const float b);
ccl_device_inline float3 interp(float3 a, float3 b, float t);
ccl_device_inline float3 sqr3(float3 a);
ccl_device_inline float reduce_add(const float3 a);
ccl_device_inline float average(const float3 a);
ccl_device_inline bool isequal_float3(const float3 a, const float3 b);

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float3 operator-(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_xor_ps(a.m128, _mm_castsi128_ps(_mm_set1_epi32(0x80000000))));
#  else
  return make_float3(-a.x, -a.y, -a.z);
#  endif
}

ccl_device_inline float3 operator*(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_mul_ps(a.m128, b.m128));
#  else
  return make_float3(a.x * b.x, a.y * b.y, a.z * b.z);
#  endif
}

ccl_device_inline float3 operator*(const float3 &a, const float f)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_mul_ps(a.m128, _mm_set1_ps(f)));
#  else
  return make_float3(a.x * f, a.y * f, a.z * f);
#  endif
}

ccl_device_inline float3 operator*(const float f, const float3 &a)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_mul_ps(_mm_set1_ps(f), a.m128));
#  else
  return make_float3(a.x * f, a.y * f, a.z * f);
#  endif
}

ccl_device_inline float3 operator/(const float f, const float3 &a)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_div_ps(_mm_set1_ps(f), a.m128));
#  else
  return make_float3(f / a.x, f / a.y, f / a.z);
#  endif
}

ccl_device_inline float3 operator/(const float3 &a, const float f)
{
  float invf = 1.0f / f;
  return a * invf;
}

ccl_device_inline float3 operator/(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_div_ps(a.m128, b.m128));
#  else
  return make_float3(a.x / b.x, a.y / b.y, a.z / b.z);
#  endif
}

ccl_device_inline float3 operator+(const float3 &a, const float f)
{
  return a + make_float3(f, f, f);
}

ccl_device_inline float3 operator+(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_add_ps(a.m128, b.m128));
#  else
  return make_float3(a.x + b.x, a.y + b.y, a.z + b.z);
#  endif
}

ccl_device_inline float3 operator-(const float3 &a, const float f)
{
  return a - make_float3(f, f, f);
}

ccl_device_inline float3 operator-(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_sub_ps(a.m128, b.m128));
#  else
  return make_float3(a.x - b.x, a.y - b.y, a.z - b.z);
#  endif
}

ccl_device_inline float3 operator+=(float3 &a, const float3 &b)
{
  return a = a + b;
}

ccl_device_inline float3 operator-=(float3 &a, const float3 &b)
{
  return a = a - b;
}

ccl_device_inline float3 operator*=(float3 &a, const float3 &b)
{
  return a = a * b;
}

ccl_device_inline float3 operator*=(float3 &a, float f)
{
  return a = a * f;
}

ccl_device_inline float3 operator/=(float3 &a, const float3 &b)
{
  return a = a / b;
}

ccl_device_inline float3 operator/=(float3 &a, float f)
{
  float invf = 1.0f / f;
  return a = a * invf;
}

ccl_device_inline bool operator==(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return (_mm_movemask_ps(_mm_cmpeq_ps(a.m128, b.m128)) & 7) == 7;
#  else
  return (a.x == b.x && a.y == b.y && a.z == b.z);
#  endif
}

ccl_device_inline bool operator!=(const float3 &a, const float3 &b)
{
  return !(a == b);
}

ccl_device_inline float distance(const float3 &a, const float3 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_dp_ps(a, b, 0x7F));
#  else
  return a.x * b.x + a.y * b.y + a.z * b.z;
#  endif
}

ccl_device_inline float dot_xy(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_hadd_ps(_mm_mul_ps(a, b), b));
#  else
  return a.x * b.x + a.y * b.y;
#  endif
}

ccl_device_inline float3 cross(const float3 &a, const float3 &b)
{
  float3 r = make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
  return r;
}

ccl_device_inline float3 normalize(const float3 &a)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  __m128 norm = _mm_sqrt_ps(_mm_dp_ps(a.m128, a.m128, 0x7F));
  return float3(_mm_div_ps(a.m128, norm));
#  else
  return a / len(a);
#  endif
}

ccl_device_inline float3 min(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_min_ps(a.m128, b.m128));
#  else
  return make_float3(fminf(a.x, b.x), fminf(a.y, b.y), fminf(a.z, b.z));
#  endif
}

ccl_device_inline float3 max(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_max_ps(a.m128, b.m128));
#  else
  return make_float3(fmaxf(a.x, b.x), fmaxf(a.y, b.y), fmaxf(a.z, b.z));
#  endif
}

ccl_device_inline float3 clamp(const float3 &a, const float3 &mn, const float3 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float3 fabs(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  __m128 mask = _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff));
  return float3(_mm_and_ps(a.m128, mask));
#  else
  return make_float3(fabsf(a.x), fabsf(a.y), fabsf(a.z));
#  endif
}

ccl_device_inline float3 sqrt(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_sqrt_ps(a));
#  else
  return make_float3(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z));
#  endif
}

ccl_device_inline float3 floor(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_floor_ps(a));
#  else
  return make_float3(floorf(a.x), floorf(a.y), floorf(a.z));
#  endif
}

ccl_device_inline float3 ceil(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_ceil_ps(a));
#  else
  return make_float3(ceilf(a.x), ceilf(a.y), ceilf(a.z));
#  endif
}

ccl_device_inline float3 mix(const float3 &a, const float3 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float3 rcp(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  /* Don't use _mm_rcp_ps due to poor precision. */
  return float3(_mm_div_ps(_mm_set_ps1(1.0f), a.m128));
#  else
  return make_float3(1.0f / a.x, 1.0f / a.y, 1.0f / a.z);
#  endif
}
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float min3(const float3 a)
{
  return min(min(a.x, a.y), a.z);
}

ccl_device_inline float max3(const float3 a)
{
  return max(max(a.x, a.y), a.z);
}

ccl_device_inline float len(const float3 a)
{
#if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_sqrt_ss(_mm_dp_ps(a.m128, a.m128, 0x7F)));
#else
  return sqrtf(dot(a, a));
#endif
}

ccl_device_inline float len_squared(const float3 a)
{
  return dot(a, a);
}

ccl_device_inline float3 reflect(const float3 incident, const float3 normal)
{
  float3 unit_normal = normalize(normal);
  return incident - 2.0f * unit_normal * dot(incident, unit_normal);
}

ccl_device_inline float3 project(const float3 v, const float3 v_proj)
{
  float len_squared = dot(v_proj, v_proj);
  return (len_squared != 0.0f) ? (dot(v, v_proj) / len_squared) * v_proj :
                                 make_float3(0.0f, 0.0f, 0.0f);
}

ccl_device_inline float3 saturate3(const float3 a)
{
  return make_float3(saturate(a.x), saturate(a.y), saturate(a.z));
}

ccl_device_inline float3 normalize_len(const float3 a, float *t)
{
  *t = len(a);
  float x = 1.0f / *t;
  return a * x;
}

ccl_device_inline float3 safe_normalize(const float3 a)
{
  float t = len(a);
  return (t != 0.0f) ? a * (1.0f / t) : a;
}

ccl_device_inline float3 safe_normalize_len(const float3 a, float *t)
{
  *t = len(a);
  return (*t != 0.0f) ? a / (*t) : a;
}

ccl_device_inline float3 safe_divide_float3_float3(const float3 a, const float3 b)
{
  return make_float3((b.x != 0.0f) ? a.x / b.x : 0.0f,
                     (b.y != 0.0f) ? a.y / b.y : 0.0f,
                     (b.z != 0.0f) ? a.z / b.z : 0.0f);
}

ccl_device_inline float3 safe_divide_float3_float(const float3 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float3(0.0f, 0.0f, 0.0f);
}

ccl_device_inline float3 interp(const float3 a, const float3 b, const float t)
{
  return a + t * (b - a);
}

ccl_device_inline float3 sqr3(const float3 a)
{
  return a * a;
}

ccl_device_inline float reduce_add(const float3 a)
{
  return (a.x + a.y + a.z);
}

ccl_device_inline float average(const float3 a)
{
  return reduce_add(a) * (1.0f / 3.0f);
}

ccl_device_inline bool isequal_float3(const float3 a, const float3 b)
{
#ifdef __KERNEL_OPENCL__
  return all(a == b);
#else
  return a == b;
#endif
}

ccl_device_inline float3 pow3(const float3 v, const float e)
{
  return make_float3(powf(v.x, e), powf(v.y, e), powf(v.z, e));
}

ccl_device_inline float3 exp3(const float3 v)
{
  return make_float3(expf(v.x), expf(v.y), expf(v.z));
}

ccl_device_inline float3 log3(const float3 v)
{
  return make_float3(logf(v.x), logf(v.y), logf(v.z));
}

ccl_device_inline int3 quick_floor_to_int3(const float3 a)
{
#ifdef __KERNEL_SSE__
  int3 b = int3(_mm_cvttps_epi32(a.m128));
  int3 isneg = int3(_mm_castps_si128(_mm_cmplt_ps(a.m128, _mm_set_ps1(0.0f))));
  /* Unsaturated add 0xffffffff is the same as subtract -1. */
  return b + isneg;
#else
  return make_int3(quick_floor_to_int(a.x), quick_floor_to_int(a.y), quick_floor_to_int(a.z));
#endif
}

ccl_device_inline bool isfinite3_safe(const float3 v)
{
  return isfinite_safe(v.x) && isfinite_safe(v.y) && isfinite_safe(v.z);
}

ccl_device_inline float3 ensure_finite3(float3 v)
{
  if (!isfinite_safe(v.x))
    v.x = 0.0f;
  if (!isfinite_safe(v.y))
    v.y = 0.0f;
  if (!isfinite_safe(v.z))
    v.z = 0.0f;
  return v;
}

CCL_NAMESPACE_END

#endif

#line 425 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT4_H__
#define __COM_KERNEL_MATH_FLOAT4_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float4 operator-(const float4 &a);
ccl_device_inline float4 operator*(const float4 &a, const float4 &b);
ccl_device_inline float4 operator*(const float4 &a, const float f);
ccl_device_inline float4 operator*(const float f, const float4 &a);
ccl_device_inline float4 operator/(const float4 &a, float f);
ccl_device_inline float4 operator/(const float f, const float4 &a);
ccl_device_inline float4 operator/(const float4 &a, const float4 &b);
ccl_device_inline float4 operator+(const float4 &a, const float f);
ccl_device_inline float4 operator+(const float f, const float4 &a);
ccl_device_inline float4 operator+(const float4 &a, const float4 &b);
ccl_device_inline float4 operator-(const float4 &a, const float f);
ccl_device_inline float4 operator-(const float f, const float4 &a);
ccl_device_inline float4 operator-(const float4 &a, const float4 &b);
ccl_device_inline float4 operator+=(float4 &a, const float4 &b);
ccl_device_inline float4 operator*=(float4 &a, const float4 &b);
ccl_device_inline float4 operator*=(float4 &a, const float f);
ccl_device_inline float4 operator/=(float4 &a, const float f);

ccl_device_inline int4 operator<(const float4 &a, const float4 &b);
ccl_device_inline int4 operator>(const float4 &a, const float4 &b);
ccl_device_inline int4 operator>=(const float4 &a, const float4 &b);
ccl_device_inline int4 operator<=(const float4 &a, const float4 &b);
ccl_device_inline int4 operator==(const float4 &a, const float4 &b);
ccl_device_inline int4 operator!=(const float4 &a, const float4 &b);

ccl_device_inline float distance(const float4 &a, const float4 &b);
ccl_device_inline float dot(const float4 &a, const float4 &b);
ccl_device_inline float len_squared(const float4 &a);
ccl_device_inline float4 rcp(const float4 &a);
ccl_device_inline float4 sqrt(const float4 &a);
ccl_device_inline float4 sqr(const float4 &a);
ccl_device_inline float4 cross(const float4 &a, const float4 &b);
ccl_device_inline float average(const float4 &a);
ccl_device_inline float len(const float4 &a);
ccl_device_inline float4 normalize(const float4 &a);
ccl_device_inline float4 safe_normalize(const float4 &a);
ccl_device_inline float4 min(const float4 &a, const float4 &b);
ccl_device_inline float4 min(const float4 &a, const float b);
ccl_device_inline float4 max(const float4 &a, const float4 &b);
ccl_device_inline float4 max(const float4 &a, const float b);
ccl_device_inline float4 clamp(const float4 &a, const float4 &mn, const float4 &mx);
ccl_device_inline float4 clamp(const float4 &a, const float mn, const float mx);
ccl_device_inline float4 fabs(const float4 &a);
ccl_device_inline float4 floor(const float4 &a);
ccl_device_inline float4 mix(const float4 &a, const float4 &b, const float t);
#endif /* !__KERNEL_OPENCL__*/

ccl_device_inline float4 safe_divide_float4_float(const float4 a, const float b);
ccl_device_inline float4 clamp_to_normal_f4(const float4 a);

#ifdef __KERNEL_SSE__
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &b);
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &a, const float4 &b);

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &b);

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &a, const float4 &b);
template<> __forceinline const float4 shuffle<2, 3, 2, 3>(const float4 &a, const float4 &b);

#  ifdef __KERNEL_SSE3__
template<> __forceinline const float4 shuffle<0, 0, 2, 2>(const float4 &b);
template<> __forceinline const float4 shuffle<1, 1, 3, 3>(const float4 &b);
#  endif
#endif /* __KERNEL_SSE__ */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline float4 select(const float4 &b_false, const float4 &a_true, const int4 &mask);
ccl_device_inline float4 reduce_min(const float4 &a);
ccl_device_inline float4 reduce_max(const float4 &a);
ccl_device_inline float4 reduce_add(const float4 &a);
#endif /* !__KERNEL_COMPUTE__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float4 operator-(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  __m128 mask = _mm_castsi128_ps(_mm_set1_epi32(0x80000000));
  return float4(_mm_xor_ps(a.m128, mask));
#  else
  return make_float4(-a.x, -a.y, -a.z, -a.w);
#  endif
}

ccl_device_inline float4 operator*(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_mul_ps(a.m128, b.m128));
#  else
  return make_float4(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
#  endif
}

ccl_device_inline float4 operator*(const float4 &a, const float f)
{
#  if defined(__KERNEL_SSE__)
  return a * make_float4_1(f);
#  else
  return make_float4(a.x * f, a.y * f, a.z * f, a.w * f);
#  endif
}

ccl_device_inline float4 operator*(const float f, const float4 &a)
{
  return a * f;
}

ccl_device_inline float4 operator/(const float4 &a, const float f)
{
  return a * (1.0f / f);
}

ccl_device_inline float4 operator/(const float f, const float4 &a)
{
  return make_float4_1(f) / a;
}
ccl_device_inline float4 operator/(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_div_ps(a.m128, b.m128));
#  else
  return make_float4(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
#  endif
}

ccl_device_inline float4 operator+(const float4 &a, const float f)
{
  return a + make_float4(f, f, f, f);
}

ccl_device_inline float4 operator+(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_add_ps(a.m128, b.m128));
#  else
  return make_float4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
#  endif
}

ccl_device_inline float4 operator+(const float f, const float4 &a)
{
  return make_float4(f, f, f, f) + a;
}

ccl_device_inline float4 operator-(const float4 &a, const float f)
{
  return a - make_float4(f, f, f, f);
}

ccl_device_inline float4 operator-(const float f, const float4 &a)
{
  return make_float4(f, f, f, f) - a;
}

ccl_device_inline float4 operator-(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_sub_ps(a.m128, b.m128));
#  else
  return make_float4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
#  endif
}

ccl_device_inline float4 operator+=(float4 &a, const float4 &b)
{
  return a = a + b;
}

ccl_device_inline float4 operator-=(float4 &a, const float4 &b)
{
  return a = a - b;
}

ccl_device_inline float4 operator*=(float4 &a, const float4 &b)
{
  return a = a * b;
}

ccl_device_inline float4 operator*=(float4 &a, const float f)
{
  return a = a * f;
}

ccl_device_inline float4 operator/=(float4 &a, const float f)
{
  return a = a / f;
}

ccl_device_inline int4 operator<(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmplt_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x < b.x, a.y < b.y, a.z < b.z, a.w < b.w);
#  endif
}

ccl_device_inline int4 operator>(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpgt_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x > b.x, a.y > b.y, a.z > b.z, a.w > b.w);
#  endif
}

ccl_device_inline int4 operator>=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpge_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x >= b.x, a.y >= b.y, a.z >= b.z, a.w >= b.w);
#  endif
}

ccl_device_inline int4 operator<=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmple_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x <= b.x, a.y <= b.y, a.z <= b.z, a.w <= b.w);
#  endif
}

ccl_device_inline int4 operator==(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpeq_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w);
#  endif
}

ccl_device_inline int4 operator!=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpneq_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x != b.x, a.y != b.y, a.z != b.z, a.w != b.w);
#  endif
}

ccl_device_inline float distance(const float4 &a, const float4 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float4 &a, const float4 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_dp_ps(a, b, 0xFF));
#  else
  return (a.x * b.x + a.y * b.y) + (a.z * b.z + a.w * b.w);
#  endif
}

ccl_device_inline float len_squared(const float4 &a)
{
  return dot(a, a);
}

ccl_device_inline float4 rcp(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  /* Don't use _mm_rcp_ps due to poor precision. */
  return float4(_mm_div_ps(_mm_set_ps1(1.0f), a.m128));
#  else
  return make_float4(1.0f / a.x, 1.0f / a.y, 1.0f / a.z, 1.0f / a.w);
#  endif
}

ccl_device_inline float4 sqrt(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_sqrt_ps(a.m128));
#  else
  return make_float4(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z), sqrtf(a.w));
#  endif
}

ccl_device_inline float4 sqr(const float4 &a)
{
  return a * a;
}

ccl_device_inline float4 cross(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return (shuffle<1, 2, 0, 0>(a) * shuffle<2, 0, 1, 0>(b)) -
         (shuffle<2, 0, 1, 0>(a) * shuffle<1, 2, 0, 0>(b));
#  else
  return make_float4(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x, 0.0f);
#  endif
}

ccl_device_inline float4 reduce_add(const float4 &a)
{
#  ifdef __KERNEL_SSE__
#    ifdef __KERNEL_SSE3__
  float4 h(_mm_hadd_ps(a.m128, a.m128));
  return float4(_mm_hadd_ps(h.m128, h.m128));
#    else
  float4 h(shuffle<1, 0, 3, 2>(a) + a);
  return shuffle<2, 3, 0, 1>(h) + h;
#    endif
#  else
  float sum = (a.x + a.y) + (a.z + a.w);
  return make_float4(sum, sum, sum, sum);
#  endif
}

ccl_device_inline float average(const float4 &a)
{
  return reduce_add(a).x * 0.25f;
}

ccl_device_inline float len(const float4 &a)
{
  return sqrtf(dot(a, a));
}

ccl_device_inline float4 normalize(const float4 &a)
{
  return a / len(a);
}

ccl_device_inline float4 safe_normalize(const float4 &a)
{
  float t = len(a);
  return (t != 0.0f) ? a / t : a;
}

ccl_device_inline float4 min(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_min_ps(a.m128, b.m128));
#  else
  return make_float4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));
#  endif
}

ccl_device_inline float4 min(const float4 &a, const float b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_min_ps(a.m128, _mm_set1_ps(b)));
#  else
  return make_float4(fminf(a.x, b), fminf(a.y, b), fminf(a.z, b), fminf(a.w, b));
#  endif
}

ccl_device_inline float4 max(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_max_ps(a.m128, b.m128));
#  else
  return make_float4(fmaxf(a.x, b.x), fmaxf(a.y, b.y), fmaxf(a.z, b.z), fmaxf(a.w, b.w));
#  endif
}

ccl_device_inline float4 max(const float4 &a, const float b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_max_ps(a.m128, _mm_set1_ps(b)));
#  else
  return make_float4(fminf(a.x, b), fminf(a.y, b), fminf(a.z, b), fminf(a.w, b));
#  endif
}

ccl_device_inline float4 clamp(const float4 &a, const float4 &mn, const float4 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float4 clamp(const float4 &a, const float mn, const float mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float4 fabs(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_and_ps(a.m128, _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff))));
#  else
  return make_float4(fabsf(a.x), fabsf(a.y), fabsf(a.z), fabsf(a.w));
#  endif
}

ccl_device_inline float4 floor(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_floor_ps(a));
#  else
  return make_float4(floorf(a.x), floorf(a.y), floorf(a.z), floorf(a.w));
#  endif
}

ccl_device_inline float4 mix(const float4 &a, const float4 &b, const float t)
{
  return a + t * (b - a);
}

#endif /* !__KERNEL_COMPUTE__*/

#ifdef __KERNEL_SSE__
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &b)
{
  return float4(_mm_castsi128_ps(
      _mm_shuffle_epi32(_mm_castps_si128(b), _MM_SHUFFLE(index_3, index_2, index_1, index_0))));
}

template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &a, const float4 &b)
{
  return float4(_mm_shuffle_ps(a.m128, b.m128, _MM_SHUFFLE(index_3, index_2, index_1, index_0)));
}

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &b)
{
  return float4(_mm_castpd_ps(_mm_movedup_pd(_mm_castps_pd(b))));
}

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &a, const float4 &b)
{
  return float4(_mm_movelh_ps(a.m128, b.m128));
}

template<> __forceinline const float4 shuffle<2, 3, 2, 3>(const float4 &a, const float4 &b)
{
  return float4(_mm_movehl_ps(b.m128, a.m128));
}

#  ifdef __KERNEL_SSE3__
template<> __forceinline const float4 shuffle<0, 0, 2, 2>(const float4 &b)
{
  return float4(_mm_moveldup_ps(b));
}

template<> __forceinline const float4 shuffle<1, 1, 3, 3>(const float4 &b)
{
  return float4(_mm_movehdup_ps(b));
}
#  endif /* __KERNEL_SSE3__ */
#endif   /* __KERNEL_SSE__ */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline float4 select(const float4 &b_false, const float4 &a_true, const int4 &mask)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_blendv_ps(b_false.m128, a_true.m128, _mm_castsi128_ps(mask.m128)));
#  else
  return make_float4((mask.x) ? a_true.x : b_false.x,
                     (mask.y) ? a_true.y : b_false.y,
                     (mask.z) ? a_true.z : b_false.z,
                     (mask.w) ? a_true.w : b_false.w);
#  endif
}

ccl_device_inline float4 reduce_min(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  float4 h = min(shuffle<1, 0, 3, 2>(a), a);
  return min(shuffle<2, 3, 0, 1>(h), h);
#  else
  return make_float4(min(min(a.x, a.y), min(a.z, a.w)));
#  endif
}

ccl_device_inline float4 reduce_max(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  float4 h = max(shuffle<1, 0, 3, 2>(a), a);
  return max(shuffle<2, 3, 0, 1>(h), h);
#  else
  return make_float4(max(max(a.x, a.y), max(a.z, a.w)));
#  endif
}

#endif /* !__KERNEL_COMPUTE__ */

ccl_device_inline float4 safe_divide_float4_float(const float4 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float4(0.0f, 0.0f, 0.0f, 0.0f);
}

ccl_device_inline float4 clamp_to_normal_f4(const float4 a)
{
  return min(max(a, 0.0f), 1.0f);
}

CCL_NAMESPACE_END

#endif

#line 426 ".kernel_util/COM_kernel_math.h"

CCL_NAMESPACE_BEGIN

#ifndef __KERNEL_OPENCL__
/* Interpolation */

template<class A, class B> A lerp(const A &a, const A &b, const B &t)
{
  return (A)(a * ((B)1 - t) + b * t);
}

#endif /* __KERNEL_OPENCL__ */

/* Triangle */
#ifndef __KERNEL_OPENCL__
ccl_device_inline float triangle_area(const float3 &v1, const float3 &v2, const float3 &v3)
#else
ccl_device_inline float triangle_area(const float3 v1, const float3 v2, const float3 v3)
#endif
{
  return len(cross(v3 - v2, v1 - v2)) * 0.5f;
}

/* Orthonormal vectors */

ccl_device_inline void make_orthonormals(const float3 N, float3 *a, float3 *b)
{
#if 0
  if (fabsf(N.y) >= 0.999f) {
    *a = make_float3(1, 0, 0);
    *b = make_float3(0, 0, 1);
    return;
  }
  if (fabsf(N.z) >= 0.999f) {
    *a = make_float3(1, 0, 0);
    *b = make_float3(0, 1, 0);
    return;
  }
#endif

  if (N.x != N.y || N.x != N.z)
    *a = make_float3(N.z - N.y, N.x - N.z, N.y - N.x);  //(1,1,1)x N
  else
    *a = make_float3(N.z - N.y, N.x + N.z, -N.y - N.x);  //(-1,1,1)x N

  *a = normalize(*a);
  *b = cross(N, *a);
}

/* Color division */

ccl_device_inline float3 safe_invert_color(const float3 a)
{
  float x, y, z;

  x = (a.x != 0.0f) ? 1.0f / a.x : 0.0f;
  y = (a.y != 0.0f) ? 1.0f / a.y : 0.0f;
  z = (a.z != 0.0f) ? 1.0f / a.z : 0.0f;

  return make_float3(x, y, z);
}

ccl_device_inline float3 safe_divide_color(const float3 a, const float3 b)
{
  float x, y, z;

  x = (b.x != 0.0f) ? a.x / b.x : 0.0f;
  y = (b.y != 0.0f) ? a.y / b.y : 0.0f;
  z = (b.z != 0.0f) ? a.z / b.z : 0.0f;

  return make_float3(x, y, z);
}

ccl_device_inline float3 safe_divide_even_color(const float3 a, const float3 b)
{
  float x, y, z;

  x = (b.x != 0.0f) ? a.x / b.x : 0.0f;
  y = (b.y != 0.0f) ? a.y / b.y : 0.0f;
  z = (b.z != 0.0f) ? a.z / b.z : 0.0f;

  /* try to get gray even if b is zero */
  if (b.x == 0.0f) {
    if (b.y == 0.0f) {
      x = z;
      y = z;
    }
    else if (b.z == 0.0f) {
      x = y;
      z = y;
    }
    else
      x = 0.5f * (y + z);
  }
  else if (b.y == 0.0f) {
    if (b.z == 0.0f) {
      y = x;
      z = x;
    }
    else
      y = 0.5f * (x + z);
  }
  else if (b.z == 0.0f) {
    z = 0.5f * (x + y);
  }

  return make_float3(x, y, z);
}

/* Rotation of point around axis and angle */

ccl_device_inline float3 rotate_around_axis(const float3 p, const float3 axis, const float angle)
{
  float costheta = cosf(angle);
  float sintheta = sinf(angle);
  float3 r;

  r.x = ((costheta + (1 - costheta) * axis.x * axis.x) * p.x) +
        (((1 - costheta) * axis.x * axis.y - axis.z * sintheta) * p.y) +
        (((1 - costheta) * axis.x * axis.z + axis.y * sintheta) * p.z);

  r.y = (((1 - costheta) * axis.x * axis.y + axis.z * sintheta) * p.x) +
        ((costheta + (1 - costheta) * axis.y * axis.y) * p.y) +
        (((1 - costheta) * axis.y * axis.z - axis.x * sintheta) * p.z);

  r.z = (((1 - costheta) * axis.x * axis.z - axis.y * sintheta) * p.x) +
        (((1 - costheta) * axis.y * axis.z + axis.x * sintheta) * p.y) +
        ((costheta + (1 - costheta) * axis.z * axis.z) * p.z);

  return r;
}

/* NaN-safe math ops */

ccl_device_inline float safe_sqrtf(const float f)
{
  return sqrtf(max(f, 0.0f));
}

ccl_device_inline float inversesqrtf(const float f)
{
  return (f > 0.0f) ? 1.0f / sqrtf(f) : 0.0f;
}

ccl_device float safe_asinf(const float a)
{
  return asinf(clamp(a, -1.0f, 1.0f));
}

ccl_device float safe_acosf(const float a)
{
  return acosf(clamp(a, -1.0f, 1.0f));
}

ccl_device float compatible_powf(const float x, const float y)
{
#ifdef __KERNEL_COMPUTE__
  if (y == 0.0f) /* x^0 -> 1, including 0^0 */
    return 1.0f;

  /* GPU pow doesn't accept negative x, do manual checks here */
  if (x < 0.0f) {
    if (fmodf(-y, 2.0f) == 0.0f)
      return powf(-x, y);
    else
      return -powf(-x, y);
  }
  else if (x == 0.0f)
    return 0.0f;
#endif
  return powf(x, y);
}

ccl_device float safe_powf(const float a, const float b)
{
  if (UNLIKELY(a < 0.0f && b != float_to_int(b)))
    return 0.0f;

  return compatible_powf(a, b);
}

ccl_device float safe_divide(const float a, const float b)
{
  return (b != 0.0f) ? a / b : 0.0f;
}

ccl_device float safe_logf(const float a, const float b)
{
  if (UNLIKELY(a <= 0.0f || b <= 0.0f))
    return 0.0f;

  return safe_divide(logf(a), logf(b));
}

ccl_device float safe_modulo(const float a, const float b)
{
  return (b != 0.0f) ? fmodf(a, b) : 0.0f;
}

ccl_device_inline float sqr(const float a)
{
  return a * a;
}

ccl_device_inline float pow20(const float a)
{
  return sqr(sqr(sqr(sqr(a)) * a));
}

ccl_device_inline float pow22(float a)
{
  return sqr(a * sqr(sqr(sqr(a)) * a));
}

ccl_device_inline float beta(float x, float y)
{
#ifndef __KERNEL_OPENCL__
  return expf(lgammaf(x) + lgammaf(y) - lgammaf(x + y));
#else
  return expf(lgamma(x) + lgamma(y) - lgamma(x + y));
#endif
}

ccl_device_inline float xor_signmask(const float x, const int y)
{
  return __int_as_float(__float_as_int(x) ^ y);
}

ccl_device float bits_to_01(const uint bits)
{
  return bits * (1.0f / (float)0xFFFFFFFF);
}

ccl_device_inline uint count_leading_zeros(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return __clz(x);
#elif defined(__KERNEL_OPENCL__)
  return clz(x);
#else
  assert(x != 0);
#  ifdef _MSC_VER
  unsigned long leading_zero = 0;
  _BitScanReverse(&leading_zero, x);
  return (31 - leading_zero);
#  else
  return __builtin_clz(x);
#  endif
#endif
}

ccl_device_inline uint count_trailing_zeros(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return (__ffs(x) - 1);
#elif defined(__KERNEL_OPENCL__)
  return (31 - count_leading_zeros(x & -x));
#else
  assert(x != 0);
#  ifdef _MSC_VER
  unsigned long ctz = 0;
  _BitScanForward(&ctz, x);
  return ctz;
#  else
  return __builtin_ctz(x);
#  endif
#endif
}

ccl_device_inline uint find_first_set(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return __ffs(x);
#elif defined(__KERNEL_OPENCL__)
  return (x != 0) ? (32 - count_leading_zeros(x & (-x))) : 0;
#else
#  ifdef _MSC_VER
  return (x != 0) ? (32 - count_leading_zeros(x & (-x))) : 0;
#  else
  return __builtin_ffs(x);
#  endif
#endif
}

/* projections */
ccl_device_inline float2 map_to_tube(const float3 co)
{
  float len, u, v;
  len = sqrtf(co.x * co.x + co.y * co.y);
  if (len > 0.0f) {
    u = (1.0f - (atan2f(co.x / len, co.y / len) / M_PI_F)) * 0.5f;
    v = (co.z + 1.0f) * 0.5f;
  }
  else {
    u = v = 0.0f;
  }
  return make_float2(u, v);
}

ccl_device_inline float2 map_to_sphere(const float3 co)
{
  float l = len(co);
  float u, v;
  if (l > 0.0f) {
    if (UNLIKELY(co.x == 0.0f && co.y == 0.0f)) {
      u = 0.0f; /* othwise domain error */
    }
    else {
      u = (1.0f - atan2f(co.x, co.y) / M_PI_F) / 2.0f;
    }
    v = 1.0f - safe_acosf(co.z / l) / M_PI_F;
  }
  else {
    u = v = 0.0f;
  }
  return make_float2(u, v);
}

/* Compares two floats.
 * Returns true if their absolute difference is smaller than abs_diff (for numbers near zero)
 * or their relative difference is less than ulp_diff ULPs.
 * Based on
 * https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
 */

ccl_device_inline float compare_floats(const float a,
                                       const float b,
                                       const float abs_diff,
                                       const int ulp_diff)
{
  if (fabsf(a - b) < abs_diff) {
    return true;
  }

  if ((a < 0.0f) != (b < 0.0f)) {
    return false;
  }

  return (abs(__float_as_int(a) - __float_as_int(b)) < ulp_diff);
}

ccl_device_inline float clamp_to_normal(const float a)
{
  return min(max(a, 0.0f), 1.0f);
}

ccl_device_inline float4 interp_f4f4(const float4 a, const float4 b, const float t)
{
  const float s = 1.0f - t;

  return s * a + t * b;
}

CCL_NAMESPACE_END

#endif

#line 4 ".kernel_util/COM_kernel_geom.h"

/* All this methods has been taken from blendlib math_geom.c file.
 * They are adapted for vectors and kernel compatibility */
CCL_NAMESPACE_BEGIN

#define KEY_LINEAR 0
#define KEY_CARDINAL 1
#define KEY_BSPLINE 2
#define KEY_CATMULL_ROM 3

ccl_device_inline float2 closest_to_line_v2(const float2 p, const float2 l1, const float2 l2)
{
  float2 u = l2 - l1;
  float2 h = p - l1;
  float lambda = dot(u, h) / dot(u, u);
  return l1 + u * lambda;
}

ccl_device_inline void key_curve_position_weights(const float t, float data[4], const int type)
{
  float t2, t3, fc;

  if (type == KEY_LINEAR) {
    data[0] = 0.0f;
    data[1] = -t + 1.0f;
    data[2] = t;
    data[3] = 0.0f;
  }
  else if (type == KEY_CARDINAL) {
    t2 = t * t;
    t3 = t2 * t;
    fc = 0.71f;

    data[0] = -fc * t3 + 2.0f * fc * t2 - fc * t;
    data[1] = (2.0f - fc) * t3 + (fc - 3.0f) * t2 + 1.0f;
    data[2] = (fc - 2.0f) * t3 + (3.0f - 2.0f * fc) * t2 + fc * t;
    data[3] = fc * t3 - fc * t2;
  }
  else if (type == KEY_BSPLINE) {
    t2 = t * t;
    t3 = t2 * t;

    data[0] = -0.16666666f * t3 + 0.5f * t2 - 0.5f * t + 0.16666666f;
    data[1] = 0.5f * t3 - t2 + 0.66666666f;
    data[2] = -0.5f * t3 + 0.5f * t2 + 0.5f * t + 0.16666666f;
    data[3] = 0.16666666f * t3;
  }
  else if (type == KEY_CATMULL_ROM) {
    t2 = t * t;
    t3 = t2 * t;
    fc = 0.5f;

    data[0] = -fc * t3 + 2.0f * fc * t2 - fc * t;
    data[1] = (2.0f - fc) * t3 + (fc - 3.0f) * t2 + 1.0f;
    data[2] = (fc - 2.0f) * t3 + (3.0f - 2.0f * fc) * t2 + fc * t;
    data[3] = fc * t3 - fc * t2;
  }
}

CCL_NAMESPACE_END

#endif

#line 6 ".kernel_util/COM_kernel_color.h"
#line 1 ".kernel_util/COM_kernel_math.h"
#ifndef __COM_KERNEL_MATH_H__
#define __COM_KERNEL_MATH_H__

/* Math
 *
 * Basic math functions on scalar and vector types. This header is used by
 * both the kernel code when compiled as C++, and other C++ non-kernel code. */

#ifndef __KERNEL_COMPUTE__
#  include <cmath>
#endif

#ifndef __KERNEL_OPENCL__
#  include <float.h>
#  include <math.h>
#  include <stdio.h>
#endif /* __KERNEL_OPENCL__ */

#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 19 ".kernel_util/COM_kernel_math.h"

CCL_NAMESPACE_BEGIN

/* Float Pi variations */

/* Division */
#ifndef M_PI_F
#  define M_PI_F (3.1415926535897932f) /* pi */
#endif
#ifndef M_PI_2_F
#  define M_PI_2_F (1.5707963267948966f) /* pi/2 */
#endif
#ifndef M_PI_4_F
#  define M_PI_4_F (0.7853981633974830f) /* pi/4 */
#endif
#ifndef M_1_PI_F
#  define M_1_PI_F (0.3183098861837067f) /* 1/pi */
#endif
#ifndef M_2_PI_F
#  define M_2_PI_F (0.6366197723675813f) /* 2/pi */
#endif
#ifndef M_1_2PI_F
#  define M_1_2PI_F (0.1591549430918953f) /* 1/(2*pi) */
#endif
#ifndef M_SQRT_PI_8_F
#  define M_SQRT_PI_8_F (0.6266570686577501f) /* sqrt(pi/8) */
#endif
#ifndef M_LN_2PI_F
#  define M_LN_2PI_F (1.8378770664093454f) /* ln(2*pi) */
#endif

/* Multiplication */
#ifndef M_2PI_F
#  define M_2PI_F (6.2831853071795864f) /* 2*pi */
#endif
#ifndef M_4PI_F
#  define M_4PI_F (12.566370614359172f) /* 4*pi */
#endif

/* Float sqrt variations */
#ifndef M_SQRT2_F
#  define M_SQRT2_F (1.4142135623730950f) /* sqrt(2) */
#endif
#ifndef M_LN2_F
#  define M_LN2_F (0.6931471805599453f) /* ln(2) */
#endif
#ifndef M_LN10_F
#  define M_LN10_F (2.3025850929940457f) /* ln(10) */
#endif

#ifndef RAD2DEGF
#  define RAD2DEGF(_rad) ((_rad) * (float)(180.0f / M_PI_F))
#endif
#ifndef DEG2RADF
#  define DEG2RADF(_deg) ((_deg) * (float)(M_PI_F / 180.0f))
#endif

/* Scalar */

#ifdef _WIN32
#  ifndef __KERNEL_OPENCL__
ccl_device_inline float fmaxf(float a, float b)
{
  return (a > b) ? a : b;
}

ccl_device_inline float fminf(float a, float b)
{
  return (a < b) ? a : b;
}
#  endif /* !__KERNEL_OPENCL__ */
#endif   /* _WIN32 */

#ifndef __KERNEL_COMPUTE__
using std::isfinite;
using std::isnan;
using std::sqrt;

ccl_device_inline int abs(const int x)
{
  return (x > 0) ? x : -x;
}

ccl_device_inline int max(const int a, const int b)
{
  return (a > b) ? a : b;
}

ccl_device_inline int min(const int a, const int b)
{
  return (a < b) ? a : b;
}

ccl_device_inline float max(const float a, const float b)
{
  return (a > b) ? a : b;
}

ccl_device_inline float min(const float a, const float b)
{
  return (a < b) ? a : b;
}
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline float fminf3(const float a, const float b, const float c)
{
  return fminf(fminf(a, b), c);
}

ccl_device_inline float fmaxf3(const float a, const float b, const float c)
{
  return fmaxf(fmaxf(a, b), c);
}

ccl_device_inline float fminf4(const float a, const float b, const float c, const float d)
{
  return fminf(fminf(a, b), fminf(c, d));
}

ccl_device_inline float fmaxf4(const float a, const float b, const float c, const float d)
{
  return fmaxf(fmaxf(a, b), fmaxf(c, d));
}

#ifndef __KERNEL_OPENCL__
/* Int/Float conversion */

ccl_device_inline int as_int(uint i)
{
  union {
    uint ui;
    int i;
  } u;
  u.ui = i;
  return u.i;
}

ccl_device_inline uint as_uint(int i)
{
  union {
    uint ui;
    int i;
  } u;
  u.i = i;
  return u.ui;
}

ccl_device_inline uint as_uint(float f)
{
  union {
    uint i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline int __float_as_int(float f)
{
  union {
    int i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline float __int_as_float(int i)
{
  union {
    int i;
    float f;
  } u;
  u.i = i;
  return u.f;
}

ccl_device_inline uint __float_as_uint(float f)
{
  union {
    uint i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline float __uint_as_float(uint i)
{
  union {
    uint i;
    float f;
  } u;
  u.i = i;
  return u.f;
}

ccl_device_inline int4 __float4_as_int4(float4 f)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(f.m128));
#  else
  return make_int4(
      __float_as_int(f.x), __float_as_int(f.y), __float_as_int(f.z), __float_as_int(f.w));
#  endif
}

ccl_device_inline float4 __int4_as_float4(int4 i)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_castsi128_ps(i.m128));
#  else
  return make_float4(
      __int_as_float(i.x), __int_as_float(i.y), __int_as_float(i.z), __int_as_float(i.w));
#  endif
}
#endif /* __KERNEL_OPENCL__ */

/* Versions of functions which are safe for fast math. */
ccl_device_inline bool isnan_safe(const float f)
{
  unsigned int x = __float_as_uint(f);
  return (x << 1) > 0xff000000u;
}

ccl_device_inline bool isfinite_safe(const float f)
{
  /* By IEEE 754 rule, 2*Inf equals Inf */
  unsigned int x = __float_as_uint(f);
  return (f == f) && (x == 0 || x == (1u << 31) || (f != 2.0f * f)) && !((x << 1) > 0xff000000u);
}

ccl_device_inline float ensure_finite(const float v)
{
  return isfinite_safe(v) ? v : 0.0f;
}

#ifndef __KERNEL_OPENCL__
ccl_device_inline int clamp(const int a, const int mn, const int mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float clamp(const float a, const float mn, const float mx)
{
  return fminf(fmaxf(a, mn), mx);
}

ccl_device_inline float mix(const float a, const float b, const float t)
{
  return a + t * (b - a);
}

ccl_device_inline float smoothstep(const float edge0, const float edge1, const float x)
{
  float result;
  if (x < edge0)
    result = 0.0f;
  else if (x >= edge1)
    result = 1.0f;
  else {
    float t = (x - edge0) / (edge1 - edge0);
    result = (3.0f - 2.0f * t) * (t * t);
  }
  return result;
}

#endif /* __KERNEL_OPENCL__ */

#ifndef __KERNEL_CUDA__
ccl_device_inline float saturate(const float a)
{
  return clamp(a, 0.0f, 1.0f);
}
#endif /* __KERNEL_CUDA__ */

ccl_device_inline int float_to_int(const float f)
{
  return (int)f;
}

ccl_device_inline int floor_to_int(const float f)
{
  return float_to_int(floorf(f));
}

ccl_device_inline int quick_floor_to_int(const float x)
{
  return float_to_int(x) - ((x < 0) ? 1 : 0);
}

ccl_device_inline float floorfrac(const float x, int *i)
{
  *i = quick_floor_to_int(x);
  return x - *i;
}

ccl_device_inline int ceil_to_int(const float f)
{
  return float_to_int(ceilf(f));
}

ccl_device_inline float fractf(const float x)
{
  return x - floorf(x);
}

/* Adapted from godotengine math_funcs.h. */
ccl_device_inline float wrapf(const float value, const float max, const float min)
{
  float range = max - min;
  return (range != 0.0f) ? value - (range * floorf((value - min) / range)) : min;
}

ccl_device_inline float pingpongf(const float a, const float b)
{
  return (b != 0.0f) ? fabsf(fractf((a - b) / (b * 2.0f)) * b * 2.0f - b) : 0.0f;
}

ccl_device_inline float smoothminf(const float a, const float b, const float k)
{
  if (k != 0.0f) {
    float h = fmaxf(k - fabsf(a - b), 0.0f) / k;
    return fminf(a, b) - h * h * h * k * (1.0f / 6.0f);
  }
  else {
    return fminf(a, b);
  }
}

ccl_device_inline float signf(const float f)
{
  return (f < 0.0f) ? -1.0f : 1.0f;
}

ccl_device_inline float nonzerof(const float f, const float eps)
{
  if (fabsf(f) < eps)
    return signf(f) * eps;
  else
    return f;
}

/* Signum function testing for zero. Matches GLSL and OSL functions. */
ccl_device_inline float compatible_signf(const float f)
{
  if (f == 0.0f) {
    return 0.0f;
  }
  else {
    return signf(f);
  }
}

ccl_device_inline float smoothstepf(const float f)
{
  float ff = f * f;
  return (3.0f * ff - 2.0f * ff * f);
}

ccl_device_inline int mod(const int x, const int m)
{
  return (x % m + m) % m;
}

ccl_device_inline float3 float2_to_float3(const float2 a)
{
  return make_float3(a.x, a.y, 0.0f);
}

ccl_device_inline float3 float4_to_float3(const float4 a)
{
  return make_float3(a.x, a.y, a.z);
}

ccl_device_inline float4 float3_to_float4(const float3 a)
{
  return make_float4(a.x, a.y, a.z, 1.0f);
}

ccl_device_inline float inverse_lerp(const float a, const float b, const float x)
{
  return (x - a) / (b - a);
}

/* Cubic interpolation between b and c, a and d are the previous and next point. */
ccl_device_inline float cubic_interp(
    const float a, const float b, const float c, const float d, const float x)
{
  return 0.5f *
             (((d + 3.0f * (b - c) - a) * x + (2.0f * a - 5.0f * b + 4.0f * c - d)) * x +
              (c - a)) *
             x +
         b;
}

CCL_NAMESPACE_END

#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 418 ".kernel_util/COM_kernel_math.h"

#line 1 ".kernel_util/COM_kernel_math_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT2_H__
#define __COM_KERNEL_MATH_INT2_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline bool operator==(const int2 a, const int2 b);
ccl_device_inline int2 operator+(const int2 &a, const int2 &b);
ccl_device_inline int2 operator+=(int2 &a, const int2 &b);
ccl_device_inline int2 operator-(const int2 &a, const int2 &b);
ccl_device_inline int2 operator*(const int2 &a, const int2 &b);
ccl_device_inline int2 operator/(const int2 &a, const int2 &b);
#endif /* !__KERNEL_OPENCL__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline bool operator==(const int2 a, const int2 b)
{
  return (a.x == b.x && a.y == b.y);
}

ccl_device_inline int2 operator+(const int2 &a, const int2 &b)
{
  return make_int2(a.x + b.x, a.y + b.y);
}

ccl_device_inline int2 operator+=(int2 &a, const int2 &b)
{
  return a = a + b;
}

ccl_device_inline int2 operator-(const int2 &a, const int2 &b)
{
  return make_int2(a.x - b.x, a.y - b.y);
}

ccl_device_inline int2 operator*(const int2 &a, const int2 &b)
{
  return make_int2(a.x * b.x, a.y * b.y);
}

ccl_device_inline int2 operator/(const int2 &a, const int2 &b)
{
  return make_int2(a.x / b.x, a.y / b.y);
}
#endif /* !__KERNEL_OPENCL__ */

CCL_NAMESPACE_END

#endif

#line 420 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT3_H__
#define __COM_KERNEL_MATH_INT3_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline int3 min(int3 a, int3 b);
ccl_device_inline int3 max(int3 a, int3 b);
ccl_device_inline int3 clamp(const int3 &a, int mn, int mx);
ccl_device_inline int3 clamp(const int3 &a, int3 &mn, int mx);
#endif /* !__KERNEL_OPENCL__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline int3 min(int3 a, int3 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int3(_mm_min_epi32(a.m128, b.m128));
#  else
  return make_int3(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));
#  endif
}

ccl_device_inline int3 max(int3 a, int3 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int3(_mm_max_epi32(a.m128, b.m128));
#  else
  return make_int3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));
#  endif
}

ccl_device_inline int3 clamp(const int3 &a, int mn, int mx)
{
#  ifdef __KERNEL_SSE__
  return min(max(a, make_int3_1(mn)), make_int3_1(mx));
#  else
  return make_int3(clamp(a.x, mn, mx), clamp(a.y, mn, mx), clamp(a.z, mn, mx));
#  endif
}

ccl_device_inline int3 clamp(const int3 &a, int3 &mn, int mx)
{
#  ifdef __KERNEL_SSE__
  return min(max(a, mn), make_int3_1(mx));
#  else
  return make_int3(clamp(a.x, mn.x, mx), clamp(a.y, mn.y, mx), clamp(a.z, mn.z, mx));
#  endif
}

ccl_device_inline bool operator==(const int3 &a, const int3 &b)
{
  return a.x == b.x && a.y == b.y && a.z == b.z;
}

ccl_device_inline bool operator!=(const int3 &a, const int3 &b)
{
  return !(a == b);
}

ccl_device_inline bool operator<(const int3 &a, const int3 &b)
{
  return a.x < b.x && a.y < b.y && a.z < b.z;
}

ccl_device_inline int3 operator+(const int3 &a, const int3 &b)
{
#  ifdef __KERNEL_SSE__
  return int3(_mm_add_epi32(a.m128, b.m128));
#  else
  return make_int3(a.x + b.x, a.y + b.y, a.z + b.z);
#  endif
}

ccl_device_inline int3 operator-(const int3 &a, const int3 &b)
{
#  ifdef __KERNEL_SSE__
  return int3(_mm_sub_epi32(a.m128, b.m128));
#  else
  return make_int3(a.x - b.x, a.y - b.y, a.z - b.z);
#  endif
}
#endif /* !__KERNEL_OPENCL__ */

CCL_NAMESPACE_END

#endif /* __COM_kernel_MATH_INT3_H__ */

#line 421 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT4_H__
#define __COM_KERNEL_MATH_INT4_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline int4 operator+(const int4 &a, const int4 &b);
ccl_device_inline int4 operator+=(int4 &a, const int4 &b);
ccl_device_inline int4 operator>>(const int4 &a, int i);
ccl_device_inline int4 operator<<(const int4 &a, int i);
ccl_device_inline int4 operator<(const int4 &a, const int4 &b);
ccl_device_inline int4 operator>=(const int4 &a, const int4 &b);
ccl_device_inline int4 operator&(const int4 &a, const int4 &b);
ccl_device_inline int4 min(int4 a, int4 b);
ccl_device_inline int4 max(int4 a, int4 b);
ccl_device_inline int4 clamp(const int4 &a, const int4 &mn, const int4 &mx);
ccl_device_inline int4 select(const int4 &mask, const int4 &a, const int4 &b);
#endif /* __KERNEL_COMPUTE__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline int4 operator+(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_add_epi32(a.m128, b.m128));
#  else
  return make_int4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
#  endif
}

ccl_device_inline int4 operator+=(int4 &a, const int4 &b)
{
  return a = a + b;
}

ccl_device_inline int4 operator>>(const int4 &a, int i)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_srai_epi32(a.m128, i));
#  else
  return make_int4(a.x >> i, a.y >> i, a.z >> i, a.w >> i);
#  endif
}

ccl_device_inline int4 operator<<(const int4 &a, int i)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_slli_epi32(a.m128, i));
#  else
  return make_int4(a.x << i, a.y << i, a.z << i, a.w << i);
#  endif
}

ccl_device_inline int4 operator<(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_cmplt_epi32(a.m128, b.m128));
#  else
  return make_int4(a.x < b.x, a.y < b.y, a.z < b.z, a.w < b.w);
#  endif
}

ccl_device_inline int4 operator>=(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_xor_si128(_mm_set1_epi32(0xffffffff), _mm_cmplt_epi32(a.m128, b.m128)));
#  else
  return make_int4(a.x >= b.x, a.y >= b.y, a.z >= b.z, a.w >= b.w);
#  endif
}

ccl_device_inline int4 operator&(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_and_si128(a.m128, b.m128));
#  else
  return make_int4(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
#  endif
}

ccl_device_inline int4 min(int4 a, int4 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int4(_mm_min_epi32(a.m128, b.m128));
#  else
  return make_int4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));
#  endif
}

ccl_device_inline int4 max(int4 a, int4 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int4(_mm_max_epi32(a.m128, b.m128));
#  else
  return make_int4(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z), max(a.w, b.w));
#  endif
}

ccl_device_inline int4 clamp(const int4 &a, const int4 &mn, const int4 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline int4 select(const int4 &mask, const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  const __m128 m = _mm_cvtepi32_ps(mask);
  /* TODO(sergey): avoid cvt. */
  return int4(_mm_castps_si128(
      _mm_or_ps(_mm_and_ps(m, _mm_castsi128_ps(a)), _mm_andnot_ps(m, _mm_castsi128_ps(b)))));
#  else
  return make_int4(
      (mask.x) ? a.x : b.x, (mask.y) ? a.y : b.y, (mask.z) ? a.z : b.z, (mask.w) ? a.w : b.w);
#  endif
}

ccl_device_inline int4 load_int4(const int *v)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_loadu_si128((__m128i *)v));
#  else
  return make_int4(v[0], v[1], v[2], v[3]);
#  endif
}
#endif /* __KERNEL_COMPUTE__ */

CCL_NAMESPACE_END

#endif

#line 422 ".kernel_util/COM_kernel_math.h"

#line 1 ".kernel_util/COM_kernel_math_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT2_H__
#define __COM_KERNEL_MATH_FLOAT2_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float2 operator-(const float2 &a);
ccl_device_inline float2 operator*(const float2 &a, const float2 &b);
ccl_device_inline float2 operator*(const float2 &a, float f);
ccl_device_inline float2 operator*(float f, const float2 &a);
ccl_device_inline float2 operator/(float f, const float2 &a);
ccl_device_inline float2 operator/(const float2 &a, float f);
ccl_device_inline float2 operator/(const float2 &a, const float2 &b);
ccl_device_inline float2 operator+(const float2 &a, const float f);
ccl_device_inline float2 operator+(const float2 &a, const float2 &b);
ccl_device_inline float2 operator-(const float2 &a, const float f);
ccl_device_inline float2 operator-(const float2 &a, const float2 &b);
ccl_device_inline float2 operator+=(float2 &a, const float2 &b);
ccl_device_inline float2 operator*=(float2 &a, const float2 &b);
ccl_device_inline float2 operator*=(float2 &a, float f);
ccl_device_inline float2 operator/=(float2 &a, const float2 &b);
ccl_device_inline float2 operator/=(float2 &a, float f);

ccl_device_inline bool operator==(const float2 &a, const float2 &b);
ccl_device_inline bool operator!=(const float2 &a, const float2 &b);

ccl_device_inline float average(const float2 &a);
ccl_device_inline float distance(const float2 &a, const float2 &b);
ccl_device_inline float dot(const float2 &a, const float2 &b);
ccl_device_inline float cross(const float2 &a, const float2 &b);
ccl_device_inline float len(const float2 &a);
ccl_device_inline float2 normalize(const float2 &a);
ccl_device_inline float2 normalize_len(const float2 &a, float *t);
ccl_device_inline float2 safe_normalize(const float2 &a);
ccl_device_inline float2 min(const float2 &a, const float2 &b);
ccl_device_inline float2 max(const float2 &a, const float2 &b);
ccl_device_inline float2 clamp(const float2 &a, const float2 &mn, const float2 &mx);
ccl_device_inline float2 fabs(const float2 &a);
ccl_device_inline float2 as_float2(const float4 &a);
ccl_device_inline float2 interp(const float2 &a, const float2 &b, float t);
ccl_device_inline float2 floor(const float2 &a);
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float2 safe_divide_float2_float(const float2 a, const float b);

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float2 operator-(const float2 &a)
{
  return make_float2(-a.x, -a.y);
}

ccl_device_inline float2 operator*(const float2 &a, const float2 &b)
{
  return make_float2(a.x * b.x, a.y * b.y);
}

ccl_device_inline float2 operator*(const float2 &a, float f)
{
  return make_float2(a.x * f, a.y * f);
}

ccl_device_inline float2 operator*(float f, const float2 &a)
{
  return make_float2(a.x * f, a.y * f);
}

ccl_device_inline float2 operator/(float f, const float2 &a)
{
  return make_float2(f / a.x, f / a.y);
}

ccl_device_inline float2 operator/(const float2 &a, float f)
{
  float invf = 1.0f / f;
  return make_float2(a.x * invf, a.y * invf);
}

ccl_device_inline float2 operator/(const float2 &a, const float2 &b)
{
  return make_float2(a.x / b.x, a.y / b.y);
}

ccl_device_inline float2 operator+(const float2 &a, const float f)
{
  return a + make_float2(f, f);
}

ccl_device_inline float2 operator+(const float2 &a, const float2 &b)
{
  return make_float2(a.x + b.x, a.y + b.y);
}

ccl_device_inline float2 operator-(const float2 &a, const float f)
{
  return a - make_float2(f, f);
}

ccl_device_inline float2 operator-(const float2 &a, const float2 &b)
{
  return make_float2(a.x - b.x, a.y - b.y);
}

ccl_device_inline float2 operator+=(float2 &a, const float2 &b)
{
  return a = a + b;
}

ccl_device_inline float2 operator*=(float2 &a, const float2 &b)
{
  return a = a * b;
}

ccl_device_inline float2 operator*=(float2 &a, float f)
{
  return a = a * f;
}

ccl_device_inline float2 operator/=(float2 &a, const float2 &b)
{
  return a = a / b;
}

ccl_device_inline float2 operator/=(float2 &a, float f)
{
  float invf = 1.0f / f;
  return a = a * invf;
}

ccl_device_inline bool operator==(const float2 &a, const float2 &b)
{
  return (a.x == b.x && a.y == b.y);
}

ccl_device_inline bool operator!=(const float2 &a, const float2 &b)
{
  return !(a == b);
}

ccl_device_inline float average(const float2 &a)
{
  return (a.x + a.y) * (1.0f / 2.0f);
}

ccl_device_inline float distance(const float2 &a, const float2 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float2 &a, const float2 &b)
{
  return a.x * b.x + a.y * b.y;
}

ccl_device_inline float cross(const float2 &a, const float2 &b)
{
  return (a.x * b.y - a.y * b.x);
}

ccl_device_inline float len(const float2 &a)
{
  return sqrtf(dot(a, a));
}

ccl_device_inline float2 normalize(const float2 &a)
{
  return a / len(a);
}

ccl_device_inline float2 normalize_len(const float2 &a, float *t)
{
  *t = len(a);
  return a / (*t);
}

ccl_device_inline float2 safe_normalize(const float2 &a)
{
  float t = len(a);
  return (t != 0.0f) ? a / t : a;
}

ccl_device_inline float2 min(const float2 &a, const float2 &b)
{
  return make_float2(fminf(a.x, b.x), fminf(a.y, b.y));
}

ccl_device_inline float2 max(const float2 &a, const float2 &b)
{
  return make_float2(fmaxf(a.x, b.x), fmaxf(a.y, b.y));
}

ccl_device_inline float2 clamp(const float2 &a, const float2 &mn, const float2 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float2 fabs(const float2 &a)
{
  return make_float2(fabsf(a.x), fabsf(a.y));
}

ccl_device_inline float2 as_float2(const float4 &a)
{
  return make_float2(a.x, a.y);
}

ccl_device_inline float2 interp(const float2 &a, const float2 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float2 mix(const float2 &a, const float2 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float2 floor(const float2 &a)
{
  return make_float2(floorf(a.x), floorf(a.y));
}

#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float2 safe_divide_float2_float(const float2 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float2(0.0f, 0.0f);
}

CCL_NAMESPACE_END

#endif

#line 424 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT3_H__
#define __COM_KERNEL_MATH_FLOAT3_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float3 operator-(const float3 &a);
ccl_device_inline float3 operator*(const float3 &a, const float3 &b);
ccl_device_inline float3 operator*(const float3 &a, const float f);
ccl_device_inline float3 operator*(const float f, const float3 &a);
ccl_device_inline float3 operator/(const float f, const float3 &a);
ccl_device_inline float3 operator/(const float3 &a, const float f);
ccl_device_inline float3 operator/(const float3 &a, const float3 &b);
ccl_device_inline float3 operator+(const float3 &a, const float f);
ccl_device_inline float3 operator+(const float3 &a, const float3 &b);
ccl_device_inline float3 operator-(const float3 &a, const float f);
ccl_device_inline float3 operator-(const float3 &a, const float3 &b);
ccl_device_inline float3 operator+=(float3 &a, const float3 &b);
ccl_device_inline float3 operator-=(float3 &a, const float3 &b);
ccl_device_inline float3 operator*=(float3 &a, const float3 &b);
ccl_device_inline float3 operator*=(float3 &a, float f);
ccl_device_inline float3 operator/=(float3 &a, const float3 &b);
ccl_device_inline float3 operator/=(float3 &a, float f);

ccl_device_inline bool operator==(const float3 &a, const float3 &b);
ccl_device_inline bool operator!=(const float3 &a, const float3 &b);

ccl_device_inline float distance(const float3 &a, const float3 &b);
ccl_device_inline float dot(const float3 &a, const float3 &b);
ccl_device_inline float dot_xy(const float3 &a, const float3 &b);
ccl_device_inline float3 cross(const float3 &a, const float3 &b);
ccl_device_inline float3 normalize(const float3 &a);
ccl_device_inline float3 min(const float3 &a, const float3 &b);
ccl_device_inline float3 max(const float3 &a, const float3 &b);
ccl_device_inline float3 clamp(const float3 &a, const float3 &mn, const float3 &mx);
ccl_device_inline float3 fabs(const float3 &a);
ccl_device_inline float3 mix(const float3 &a, const float3 &b, float t);
ccl_device_inline float3 rcp(const float3 &a);
ccl_device_inline float3 sqrt(const float3 &a);
ccl_device_inline float3 floor(const float3 &a);
ccl_device_inline float3 ceil(const float3 &a);
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float min3(float3 a);
ccl_device_inline float max3(float3 a);
ccl_device_inline float len(const float3 a);
ccl_device_inline float len_squared(const float3 a);

ccl_device_inline float3 reflect(const float3 incident, const float3 normal);
ccl_device_inline float3 project(const float3 v, const float3 v_proj);

ccl_device_inline float3 saturate3(float3 a);
ccl_device_inline float3 safe_normalize(const float3 a);
ccl_device_inline float3 normalize_len(const float3 a, float *t);
ccl_device_inline float3 safe_normalize_len(const float3 a, float *t);
ccl_device_inline float3 safe_divide_float3_float3(const float3 a, const float3 b);
ccl_device_inline float3 safe_divide_float3_float(const float3 a, const float b);
ccl_device_inline float3 interp(float3 a, float3 b, float t);
ccl_device_inline float3 sqr3(float3 a);
ccl_device_inline float reduce_add(const float3 a);
ccl_device_inline float average(const float3 a);
ccl_device_inline bool isequal_float3(const float3 a, const float3 b);

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float3 operator-(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_xor_ps(a.m128, _mm_castsi128_ps(_mm_set1_epi32(0x80000000))));
#  else
  return make_float3(-a.x, -a.y, -a.z);
#  endif
}

ccl_device_inline float3 operator*(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_mul_ps(a.m128, b.m128));
#  else
  return make_float3(a.x * b.x, a.y * b.y, a.z * b.z);
#  endif
}

ccl_device_inline float3 operator*(const float3 &a, const float f)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_mul_ps(a.m128, _mm_set1_ps(f)));
#  else
  return make_float3(a.x * f, a.y * f, a.z * f);
#  endif
}

ccl_device_inline float3 operator*(const float f, const float3 &a)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_mul_ps(_mm_set1_ps(f), a.m128));
#  else
  return make_float3(a.x * f, a.y * f, a.z * f);
#  endif
}

ccl_device_inline float3 operator/(const float f, const float3 &a)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_div_ps(_mm_set1_ps(f), a.m128));
#  else
  return make_float3(f / a.x, f / a.y, f / a.z);
#  endif
}

ccl_device_inline float3 operator/(const float3 &a, const float f)
{
  float invf = 1.0f / f;
  return a * invf;
}

ccl_device_inline float3 operator/(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_div_ps(a.m128, b.m128));
#  else
  return make_float3(a.x / b.x, a.y / b.y, a.z / b.z);
#  endif
}

ccl_device_inline float3 operator+(const float3 &a, const float f)
{
  return a + make_float3(f, f, f);
}

ccl_device_inline float3 operator+(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_add_ps(a.m128, b.m128));
#  else
  return make_float3(a.x + b.x, a.y + b.y, a.z + b.z);
#  endif
}

ccl_device_inline float3 operator-(const float3 &a, const float f)
{
  return a - make_float3(f, f, f);
}

ccl_device_inline float3 operator-(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_sub_ps(a.m128, b.m128));
#  else
  return make_float3(a.x - b.x, a.y - b.y, a.z - b.z);
#  endif
}

ccl_device_inline float3 operator+=(float3 &a, const float3 &b)
{
  return a = a + b;
}

ccl_device_inline float3 operator-=(float3 &a, const float3 &b)
{
  return a = a - b;
}

ccl_device_inline float3 operator*=(float3 &a, const float3 &b)
{
  return a = a * b;
}

ccl_device_inline float3 operator*=(float3 &a, float f)
{
  return a = a * f;
}

ccl_device_inline float3 operator/=(float3 &a, const float3 &b)
{
  return a = a / b;
}

ccl_device_inline float3 operator/=(float3 &a, float f)
{
  float invf = 1.0f / f;
  return a = a * invf;
}

ccl_device_inline bool operator==(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return (_mm_movemask_ps(_mm_cmpeq_ps(a.m128, b.m128)) & 7) == 7;
#  else
  return (a.x == b.x && a.y == b.y && a.z == b.z);
#  endif
}

ccl_device_inline bool operator!=(const float3 &a, const float3 &b)
{
  return !(a == b);
}

ccl_device_inline float distance(const float3 &a, const float3 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_dp_ps(a, b, 0x7F));
#  else
  return a.x * b.x + a.y * b.y + a.z * b.z;
#  endif
}

ccl_device_inline float dot_xy(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_hadd_ps(_mm_mul_ps(a, b), b));
#  else
  return a.x * b.x + a.y * b.y;
#  endif
}

ccl_device_inline float3 cross(const float3 &a, const float3 &b)
{
  float3 r = make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
  return r;
}

ccl_device_inline float3 normalize(const float3 &a)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  __m128 norm = _mm_sqrt_ps(_mm_dp_ps(a.m128, a.m128, 0x7F));
  return float3(_mm_div_ps(a.m128, norm));
#  else
  return a / len(a);
#  endif
}

ccl_device_inline float3 min(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_min_ps(a.m128, b.m128));
#  else
  return make_float3(fminf(a.x, b.x), fminf(a.y, b.y), fminf(a.z, b.z));
#  endif
}

ccl_device_inline float3 max(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_max_ps(a.m128, b.m128));
#  else
  return make_float3(fmaxf(a.x, b.x), fmaxf(a.y, b.y), fmaxf(a.z, b.z));
#  endif
}

ccl_device_inline float3 clamp(const float3 &a, const float3 &mn, const float3 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float3 fabs(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  __m128 mask = _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff));
  return float3(_mm_and_ps(a.m128, mask));
#  else
  return make_float3(fabsf(a.x), fabsf(a.y), fabsf(a.z));
#  endif
}

ccl_device_inline float3 sqrt(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_sqrt_ps(a));
#  else
  return make_float3(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z));
#  endif
}

ccl_device_inline float3 floor(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_floor_ps(a));
#  else
  return make_float3(floorf(a.x), floorf(a.y), floorf(a.z));
#  endif
}

ccl_device_inline float3 ceil(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_ceil_ps(a));
#  else
  return make_float3(ceilf(a.x), ceilf(a.y), ceilf(a.z));
#  endif
}

ccl_device_inline float3 mix(const float3 &a, const float3 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float3 rcp(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  /* Don't use _mm_rcp_ps due to poor precision. */
  return float3(_mm_div_ps(_mm_set_ps1(1.0f), a.m128));
#  else
  return make_float3(1.0f / a.x, 1.0f / a.y, 1.0f / a.z);
#  endif
}
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float min3(const float3 a)
{
  return min(min(a.x, a.y), a.z);
}

ccl_device_inline float max3(const float3 a)
{
  return max(max(a.x, a.y), a.z);
}

ccl_device_inline float len(const float3 a)
{
#if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_sqrt_ss(_mm_dp_ps(a.m128, a.m128, 0x7F)));
#else
  return sqrtf(dot(a, a));
#endif
}

ccl_device_inline float len_squared(const float3 a)
{
  return dot(a, a);
}

ccl_device_inline float3 reflect(const float3 incident, const float3 normal)
{
  float3 unit_normal = normalize(normal);
  return incident - 2.0f * unit_normal * dot(incident, unit_normal);
}

ccl_device_inline float3 project(const float3 v, const float3 v_proj)
{
  float len_squared = dot(v_proj, v_proj);
  return (len_squared != 0.0f) ? (dot(v, v_proj) / len_squared) * v_proj :
                                 make_float3(0.0f, 0.0f, 0.0f);
}

ccl_device_inline float3 saturate3(const float3 a)
{
  return make_float3(saturate(a.x), saturate(a.y), saturate(a.z));
}

ccl_device_inline float3 normalize_len(const float3 a, float *t)
{
  *t = len(a);
  float x = 1.0f / *t;
  return a * x;
}

ccl_device_inline float3 safe_normalize(const float3 a)
{
  float t = len(a);
  return (t != 0.0f) ? a * (1.0f / t) : a;
}

ccl_device_inline float3 safe_normalize_len(const float3 a, float *t)
{
  *t = len(a);
  return (*t != 0.0f) ? a / (*t) : a;
}

ccl_device_inline float3 safe_divide_float3_float3(const float3 a, const float3 b)
{
  return make_float3((b.x != 0.0f) ? a.x / b.x : 0.0f,
                     (b.y != 0.0f) ? a.y / b.y : 0.0f,
                     (b.z != 0.0f) ? a.z / b.z : 0.0f);
}

ccl_device_inline float3 safe_divide_float3_float(const float3 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float3(0.0f, 0.0f, 0.0f);
}

ccl_device_inline float3 interp(const float3 a, const float3 b, const float t)
{
  return a + t * (b - a);
}

ccl_device_inline float3 sqr3(const float3 a)
{
  return a * a;
}

ccl_device_inline float reduce_add(const float3 a)
{
  return (a.x + a.y + a.z);
}

ccl_device_inline float average(const float3 a)
{
  return reduce_add(a) * (1.0f / 3.0f);
}

ccl_device_inline bool isequal_float3(const float3 a, const float3 b)
{
#ifdef __KERNEL_OPENCL__
  return all(a == b);
#else
  return a == b;
#endif
}

ccl_device_inline float3 pow3(const float3 v, const float e)
{
  return make_float3(powf(v.x, e), powf(v.y, e), powf(v.z, e));
}

ccl_device_inline float3 exp3(const float3 v)
{
  return make_float3(expf(v.x), expf(v.y), expf(v.z));
}

ccl_device_inline float3 log3(const float3 v)
{
  return make_float3(logf(v.x), logf(v.y), logf(v.z));
}

ccl_device_inline int3 quick_floor_to_int3(const float3 a)
{
#ifdef __KERNEL_SSE__
  int3 b = int3(_mm_cvttps_epi32(a.m128));
  int3 isneg = int3(_mm_castps_si128(_mm_cmplt_ps(a.m128, _mm_set_ps1(0.0f))));
  /* Unsaturated add 0xffffffff is the same as subtract -1. */
  return b + isneg;
#else
  return make_int3(quick_floor_to_int(a.x), quick_floor_to_int(a.y), quick_floor_to_int(a.z));
#endif
}

ccl_device_inline bool isfinite3_safe(const float3 v)
{
  return isfinite_safe(v.x) && isfinite_safe(v.y) && isfinite_safe(v.z);
}

ccl_device_inline float3 ensure_finite3(float3 v)
{
  if (!isfinite_safe(v.x))
    v.x = 0.0f;
  if (!isfinite_safe(v.y))
    v.y = 0.0f;
  if (!isfinite_safe(v.z))
    v.z = 0.0f;
  return v;
}

CCL_NAMESPACE_END

#endif

#line 425 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT4_H__
#define __COM_KERNEL_MATH_FLOAT4_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float4 operator-(const float4 &a);
ccl_device_inline float4 operator*(const float4 &a, const float4 &b);
ccl_device_inline float4 operator*(const float4 &a, const float f);
ccl_device_inline float4 operator*(const float f, const float4 &a);
ccl_device_inline float4 operator/(const float4 &a, float f);
ccl_device_inline float4 operator/(const float f, const float4 &a);
ccl_device_inline float4 operator/(const float4 &a, const float4 &b);
ccl_device_inline float4 operator+(const float4 &a, const float f);
ccl_device_inline float4 operator+(const float f, const float4 &a);
ccl_device_inline float4 operator+(const float4 &a, const float4 &b);
ccl_device_inline float4 operator-(const float4 &a, const float f);
ccl_device_inline float4 operator-(const float f, const float4 &a);
ccl_device_inline float4 operator-(const float4 &a, const float4 &b);
ccl_device_inline float4 operator+=(float4 &a, const float4 &b);
ccl_device_inline float4 operator*=(float4 &a, const float4 &b);
ccl_device_inline float4 operator*=(float4 &a, const float f);
ccl_device_inline float4 operator/=(float4 &a, const float f);

ccl_device_inline int4 operator<(const float4 &a, const float4 &b);
ccl_device_inline int4 operator>(const float4 &a, const float4 &b);
ccl_device_inline int4 operator>=(const float4 &a, const float4 &b);
ccl_device_inline int4 operator<=(const float4 &a, const float4 &b);
ccl_device_inline int4 operator==(const float4 &a, const float4 &b);
ccl_device_inline int4 operator!=(const float4 &a, const float4 &b);

ccl_device_inline float distance(const float4 &a, const float4 &b);
ccl_device_inline float dot(const float4 &a, const float4 &b);
ccl_device_inline float len_squared(const float4 &a);
ccl_device_inline float4 rcp(const float4 &a);
ccl_device_inline float4 sqrt(const float4 &a);
ccl_device_inline float4 sqr(const float4 &a);
ccl_device_inline float4 cross(const float4 &a, const float4 &b);
ccl_device_inline float average(const float4 &a);
ccl_device_inline float len(const float4 &a);
ccl_device_inline float4 normalize(const float4 &a);
ccl_device_inline float4 safe_normalize(const float4 &a);
ccl_device_inline float4 min(const float4 &a, const float4 &b);
ccl_device_inline float4 min(const float4 &a, const float b);
ccl_device_inline float4 max(const float4 &a, const float4 &b);
ccl_device_inline float4 max(const float4 &a, const float b);
ccl_device_inline float4 clamp(const float4 &a, const float4 &mn, const float4 &mx);
ccl_device_inline float4 clamp(const float4 &a, const float mn, const float mx);
ccl_device_inline float4 fabs(const float4 &a);
ccl_device_inline float4 floor(const float4 &a);
ccl_device_inline float4 mix(const float4 &a, const float4 &b, const float t);
#endif /* !__KERNEL_OPENCL__*/

ccl_device_inline float4 safe_divide_float4_float(const float4 a, const float b);
ccl_device_inline float4 clamp_to_normal_f4(const float4 a);

#ifdef __KERNEL_SSE__
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &b);
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &a, const float4 &b);

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &b);

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &a, const float4 &b);
template<> __forceinline const float4 shuffle<2, 3, 2, 3>(const float4 &a, const float4 &b);

#  ifdef __KERNEL_SSE3__
template<> __forceinline const float4 shuffle<0, 0, 2, 2>(const float4 &b);
template<> __forceinline const float4 shuffle<1, 1, 3, 3>(const float4 &b);
#  endif
#endif /* __KERNEL_SSE__ */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline float4 select(const float4 &b_false, const float4 &a_true, const int4 &mask);
ccl_device_inline float4 reduce_min(const float4 &a);
ccl_device_inline float4 reduce_max(const float4 &a);
ccl_device_inline float4 reduce_add(const float4 &a);
#endif /* !__KERNEL_COMPUTE__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float4 operator-(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  __m128 mask = _mm_castsi128_ps(_mm_set1_epi32(0x80000000));
  return float4(_mm_xor_ps(a.m128, mask));
#  else
  return make_float4(-a.x, -a.y, -a.z, -a.w);
#  endif
}

ccl_device_inline float4 operator*(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_mul_ps(a.m128, b.m128));
#  else
  return make_float4(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
#  endif
}

ccl_device_inline float4 operator*(const float4 &a, const float f)
{
#  if defined(__KERNEL_SSE__)
  return a * make_float4_1(f);
#  else
  return make_float4(a.x * f, a.y * f, a.z * f, a.w * f);
#  endif
}

ccl_device_inline float4 operator*(const float f, const float4 &a)
{
  return a * f;
}

ccl_device_inline float4 operator/(const float4 &a, const float f)
{
  return a * (1.0f / f);
}

ccl_device_inline float4 operator/(const float f, const float4 &a)
{
  return make_float4_1(f) / a;
}
ccl_device_inline float4 operator/(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_div_ps(a.m128, b.m128));
#  else
  return make_float4(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
#  endif
}

ccl_device_inline float4 operator+(const float4 &a, const float f)
{
  return a + make_float4(f, f, f, f);
}

ccl_device_inline float4 operator+(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_add_ps(a.m128, b.m128));
#  else
  return make_float4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
#  endif
}

ccl_device_inline float4 operator+(const float f, const float4 &a)
{
  return make_float4(f, f, f, f) + a;
}

ccl_device_inline float4 operator-(const float4 &a, const float f)
{
  return a - make_float4(f, f, f, f);
}

ccl_device_inline float4 operator-(const float f, const float4 &a)
{
  return make_float4(f, f, f, f) - a;
}

ccl_device_inline float4 operator-(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_sub_ps(a.m128, b.m128));
#  else
  return make_float4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
#  endif
}

ccl_device_inline float4 operator+=(float4 &a, const float4 &b)
{
  return a = a + b;
}

ccl_device_inline float4 operator-=(float4 &a, const float4 &b)
{
  return a = a - b;
}

ccl_device_inline float4 operator*=(float4 &a, const float4 &b)
{
  return a = a * b;
}

ccl_device_inline float4 operator*=(float4 &a, const float f)
{
  return a = a * f;
}

ccl_device_inline float4 operator/=(float4 &a, const float f)
{
  return a = a / f;
}

ccl_device_inline int4 operator<(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmplt_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x < b.x, a.y < b.y, a.z < b.z, a.w < b.w);
#  endif
}

ccl_device_inline int4 operator>(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpgt_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x > b.x, a.y > b.y, a.z > b.z, a.w > b.w);
#  endif
}

ccl_device_inline int4 operator>=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpge_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x >= b.x, a.y >= b.y, a.z >= b.z, a.w >= b.w);
#  endif
}

ccl_device_inline int4 operator<=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmple_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x <= b.x, a.y <= b.y, a.z <= b.z, a.w <= b.w);
#  endif
}

ccl_device_inline int4 operator==(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpeq_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w);
#  endif
}

ccl_device_inline int4 operator!=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpneq_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x != b.x, a.y != b.y, a.z != b.z, a.w != b.w);
#  endif
}

ccl_device_inline float distance(const float4 &a, const float4 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float4 &a, const float4 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_dp_ps(a, b, 0xFF));
#  else
  return (a.x * b.x + a.y * b.y) + (a.z * b.z + a.w * b.w);
#  endif
}

ccl_device_inline float len_squared(const float4 &a)
{
  return dot(a, a);
}

ccl_device_inline float4 rcp(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  /* Don't use _mm_rcp_ps due to poor precision. */
  return float4(_mm_div_ps(_mm_set_ps1(1.0f), a.m128));
#  else
  return make_float4(1.0f / a.x, 1.0f / a.y, 1.0f / a.z, 1.0f / a.w);
#  endif
}

ccl_device_inline float4 sqrt(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_sqrt_ps(a.m128));
#  else
  return make_float4(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z), sqrtf(a.w));
#  endif
}

ccl_device_inline float4 sqr(const float4 &a)
{
  return a * a;
}

ccl_device_inline float4 cross(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return (shuffle<1, 2, 0, 0>(a) * shuffle<2, 0, 1, 0>(b)) -
         (shuffle<2, 0, 1, 0>(a) * shuffle<1, 2, 0, 0>(b));
#  else
  return make_float4(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x, 0.0f);
#  endif
}

ccl_device_inline float4 reduce_add(const float4 &a)
{
#  ifdef __KERNEL_SSE__
#    ifdef __KERNEL_SSE3__
  float4 h(_mm_hadd_ps(a.m128, a.m128));
  return float4(_mm_hadd_ps(h.m128, h.m128));
#    else
  float4 h(shuffle<1, 0, 3, 2>(a) + a);
  return shuffle<2, 3, 0, 1>(h) + h;
#    endif
#  else
  float sum = (a.x + a.y) + (a.z + a.w);
  return make_float4(sum, sum, sum, sum);
#  endif
}

ccl_device_inline float average(const float4 &a)
{
  return reduce_add(a).x * 0.25f;
}

ccl_device_inline float len(const float4 &a)
{
  return sqrtf(dot(a, a));
}

ccl_device_inline float4 normalize(const float4 &a)
{
  return a / len(a);
}

ccl_device_inline float4 safe_normalize(const float4 &a)
{
  float t = len(a);
  return (t != 0.0f) ? a / t : a;
}

ccl_device_inline float4 min(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_min_ps(a.m128, b.m128));
#  else
  return make_float4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));
#  endif
}

ccl_device_inline float4 min(const float4 &a, const float b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_min_ps(a.m128, _mm_set1_ps(b)));
#  else
  return make_float4(fminf(a.x, b), fminf(a.y, b), fminf(a.z, b), fminf(a.w, b));
#  endif
}

ccl_device_inline float4 max(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_max_ps(a.m128, b.m128));
#  else
  return make_float4(fmaxf(a.x, b.x), fmaxf(a.y, b.y), fmaxf(a.z, b.z), fmaxf(a.w, b.w));
#  endif
}

ccl_device_inline float4 max(const float4 &a, const float b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_max_ps(a.m128, _mm_set1_ps(b)));
#  else
  return make_float4(fminf(a.x, b), fminf(a.y, b), fminf(a.z, b), fminf(a.w, b));
#  endif
}

ccl_device_inline float4 clamp(const float4 &a, const float4 &mn, const float4 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float4 clamp(const float4 &a, const float mn, const float mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float4 fabs(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_and_ps(a.m128, _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff))));
#  else
  return make_float4(fabsf(a.x), fabsf(a.y), fabsf(a.z), fabsf(a.w));
#  endif
}

ccl_device_inline float4 floor(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_floor_ps(a));
#  else
  return make_float4(floorf(a.x), floorf(a.y), floorf(a.z), floorf(a.w));
#  endif
}

ccl_device_inline float4 mix(const float4 &a, const float4 &b, const float t)
{
  return a + t * (b - a);
}

#endif /* !__KERNEL_COMPUTE__*/

#ifdef __KERNEL_SSE__
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &b)
{
  return float4(_mm_castsi128_ps(
      _mm_shuffle_epi32(_mm_castps_si128(b), _MM_SHUFFLE(index_3, index_2, index_1, index_0))));
}

template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &a, const float4 &b)
{
  return float4(_mm_shuffle_ps(a.m128, b.m128, _MM_SHUFFLE(index_3, index_2, index_1, index_0)));
}

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &b)
{
  return float4(_mm_castpd_ps(_mm_movedup_pd(_mm_castps_pd(b))));
}

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &a, const float4 &b)
{
  return float4(_mm_movelh_ps(a.m128, b.m128));
}

template<> __forceinline const float4 shuffle<2, 3, 2, 3>(const float4 &a, const float4 &b)
{
  return float4(_mm_movehl_ps(b.m128, a.m128));
}

#  ifdef __KERNEL_SSE3__
template<> __forceinline const float4 shuffle<0, 0, 2, 2>(const float4 &b)
{
  return float4(_mm_moveldup_ps(b));
}

template<> __forceinline const float4 shuffle<1, 1, 3, 3>(const float4 &b)
{
  return float4(_mm_movehdup_ps(b));
}
#  endif /* __KERNEL_SSE3__ */
#endif   /* __KERNEL_SSE__ */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline float4 select(const float4 &b_false, const float4 &a_true, const int4 &mask)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_blendv_ps(b_false.m128, a_true.m128, _mm_castsi128_ps(mask.m128)));
#  else
  return make_float4((mask.x) ? a_true.x : b_false.x,
                     (mask.y) ? a_true.y : b_false.y,
                     (mask.z) ? a_true.z : b_false.z,
                     (mask.w) ? a_true.w : b_false.w);
#  endif
}

ccl_device_inline float4 reduce_min(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  float4 h = min(shuffle<1, 0, 3, 2>(a), a);
  return min(shuffle<2, 3, 0, 1>(h), h);
#  else
  return make_float4(min(min(a.x, a.y), min(a.z, a.w)));
#  endif
}

ccl_device_inline float4 reduce_max(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  float4 h = max(shuffle<1, 0, 3, 2>(a), a);
  return max(shuffle<2, 3, 0, 1>(h), h);
#  else
  return make_float4(max(max(a.x, a.y), max(a.z, a.w)));
#  endif
}

#endif /* !__KERNEL_COMPUTE__ */

ccl_device_inline float4 safe_divide_float4_float(const float4 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float4(0.0f, 0.0f, 0.0f, 0.0f);
}

ccl_device_inline float4 clamp_to_normal_f4(const float4 a)
{
  return min(max(a, 0.0f), 1.0f);
}

CCL_NAMESPACE_END

#endif

#line 426 ".kernel_util/COM_kernel_math.h"

CCL_NAMESPACE_BEGIN

#ifndef __KERNEL_OPENCL__
/* Interpolation */

template<class A, class B> A lerp(const A &a, const A &b, const B &t)
{
  return (A)(a * ((B)1 - t) + b * t);
}

#endif /* __KERNEL_OPENCL__ */

/* Triangle */
#ifndef __KERNEL_OPENCL__
ccl_device_inline float triangle_area(const float3 &v1, const float3 &v2, const float3 &v3)
#else
ccl_device_inline float triangle_area(const float3 v1, const float3 v2, const float3 v3)
#endif
{
  return len(cross(v3 - v2, v1 - v2)) * 0.5f;
}

/* Orthonormal vectors */

ccl_device_inline void make_orthonormals(const float3 N, float3 *a, float3 *b)
{
#if 0
  if (fabsf(N.y) >= 0.999f) {
    *a = make_float3(1, 0, 0);
    *b = make_float3(0, 0, 1);
    return;
  }
  if (fabsf(N.z) >= 0.999f) {
    *a = make_float3(1, 0, 0);
    *b = make_float3(0, 1, 0);
    return;
  }
#endif

  if (N.x != N.y || N.x != N.z)
    *a = make_float3(N.z - N.y, N.x - N.z, N.y - N.x);  //(1,1,1)x N
  else
    *a = make_float3(N.z - N.y, N.x + N.z, -N.y - N.x);  //(-1,1,1)x N

  *a = normalize(*a);
  *b = cross(N, *a);
}

/* Color division */

ccl_device_inline float3 safe_invert_color(const float3 a)
{
  float x, y, z;

  x = (a.x != 0.0f) ? 1.0f / a.x : 0.0f;
  y = (a.y != 0.0f) ? 1.0f / a.y : 0.0f;
  z = (a.z != 0.0f) ? 1.0f / a.z : 0.0f;

  return make_float3(x, y, z);
}

ccl_device_inline float3 safe_divide_color(const float3 a, const float3 b)
{
  float x, y, z;

  x = (b.x != 0.0f) ? a.x / b.x : 0.0f;
  y = (b.y != 0.0f) ? a.y / b.y : 0.0f;
  z = (b.z != 0.0f) ? a.z / b.z : 0.0f;

  return make_float3(x, y, z);
}

ccl_device_inline float3 safe_divide_even_color(const float3 a, const float3 b)
{
  float x, y, z;

  x = (b.x != 0.0f) ? a.x / b.x : 0.0f;
  y = (b.y != 0.0f) ? a.y / b.y : 0.0f;
  z = (b.z != 0.0f) ? a.z / b.z : 0.0f;

  /* try to get gray even if b is zero */
  if (b.x == 0.0f) {
    if (b.y == 0.0f) {
      x = z;
      y = z;
    }
    else if (b.z == 0.0f) {
      x = y;
      z = y;
    }
    else
      x = 0.5f * (y + z);
  }
  else if (b.y == 0.0f) {
    if (b.z == 0.0f) {
      y = x;
      z = x;
    }
    else
      y = 0.5f * (x + z);
  }
  else if (b.z == 0.0f) {
    z = 0.5f * (x + y);
  }

  return make_float3(x, y, z);
}

/* Rotation of point around axis and angle */

ccl_device_inline float3 rotate_around_axis(const float3 p, const float3 axis, const float angle)
{
  float costheta = cosf(angle);
  float sintheta = sinf(angle);
  float3 r;

  r.x = ((costheta + (1 - costheta) * axis.x * axis.x) * p.x) +
        (((1 - costheta) * axis.x * axis.y - axis.z * sintheta) * p.y) +
        (((1 - costheta) * axis.x * axis.z + axis.y * sintheta) * p.z);

  r.y = (((1 - costheta) * axis.x * axis.y + axis.z * sintheta) * p.x) +
        ((costheta + (1 - costheta) * axis.y * axis.y) * p.y) +
        (((1 - costheta) * axis.y * axis.z - axis.x * sintheta) * p.z);

  r.z = (((1 - costheta) * axis.x * axis.z - axis.y * sintheta) * p.x) +
        (((1 - costheta) * axis.y * axis.z + axis.x * sintheta) * p.y) +
        ((costheta + (1 - costheta) * axis.z * axis.z) * p.z);

  return r;
}

/* NaN-safe math ops */

ccl_device_inline float safe_sqrtf(const float f)
{
  return sqrtf(max(f, 0.0f));
}

ccl_device_inline float inversesqrtf(const float f)
{
  return (f > 0.0f) ? 1.0f / sqrtf(f) : 0.0f;
}

ccl_device float safe_asinf(const float a)
{
  return asinf(clamp(a, -1.0f, 1.0f));
}

ccl_device float safe_acosf(const float a)
{
  return acosf(clamp(a, -1.0f, 1.0f));
}

ccl_device float compatible_powf(const float x, const float y)
{
#ifdef __KERNEL_COMPUTE__
  if (y == 0.0f) /* x^0 -> 1, including 0^0 */
    return 1.0f;

  /* GPU pow doesn't accept negative x, do manual checks here */
  if (x < 0.0f) {
    if (fmodf(-y, 2.0f) == 0.0f)
      return powf(-x, y);
    else
      return -powf(-x, y);
  }
  else if (x == 0.0f)
    return 0.0f;
#endif
  return powf(x, y);
}

ccl_device float safe_powf(const float a, const float b)
{
  if (UNLIKELY(a < 0.0f && b != float_to_int(b)))
    return 0.0f;

  return compatible_powf(a, b);
}

ccl_device float safe_divide(const float a, const float b)
{
  return (b != 0.0f) ? a / b : 0.0f;
}

ccl_device float safe_logf(const float a, const float b)
{
  if (UNLIKELY(a <= 0.0f || b <= 0.0f))
    return 0.0f;

  return safe_divide(logf(a), logf(b));
}

ccl_device float safe_modulo(const float a, const float b)
{
  return (b != 0.0f) ? fmodf(a, b) : 0.0f;
}

ccl_device_inline float sqr(const float a)
{
  return a * a;
}

ccl_device_inline float pow20(const float a)
{
  return sqr(sqr(sqr(sqr(a)) * a));
}

ccl_device_inline float pow22(float a)
{
  return sqr(a * sqr(sqr(sqr(a)) * a));
}

ccl_device_inline float beta(float x, float y)
{
#ifndef __KERNEL_OPENCL__
  return expf(lgammaf(x) + lgammaf(y) - lgammaf(x + y));
#else
  return expf(lgamma(x) + lgamma(y) - lgamma(x + y));
#endif
}

ccl_device_inline float xor_signmask(const float x, const int y)
{
  return __int_as_float(__float_as_int(x) ^ y);
}

ccl_device float bits_to_01(const uint bits)
{
  return bits * (1.0f / (float)0xFFFFFFFF);
}

ccl_device_inline uint count_leading_zeros(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return __clz(x);
#elif defined(__KERNEL_OPENCL__)
  return clz(x);
#else
  assert(x != 0);
#  ifdef _MSC_VER
  unsigned long leading_zero = 0;
  _BitScanReverse(&leading_zero, x);
  return (31 - leading_zero);
#  else
  return __builtin_clz(x);
#  endif
#endif
}

ccl_device_inline uint count_trailing_zeros(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return (__ffs(x) - 1);
#elif defined(__KERNEL_OPENCL__)
  return (31 - count_leading_zeros(x & -x));
#else
  assert(x != 0);
#  ifdef _MSC_VER
  unsigned long ctz = 0;
  _BitScanForward(&ctz, x);
  return ctz;
#  else
  return __builtin_ctz(x);
#  endif
#endif
}

ccl_device_inline uint find_first_set(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return __ffs(x);
#elif defined(__KERNEL_OPENCL__)
  return (x != 0) ? (32 - count_leading_zeros(x & (-x))) : 0;
#else
#  ifdef _MSC_VER
  return (x != 0) ? (32 - count_leading_zeros(x & (-x))) : 0;
#  else
  return __builtin_ffs(x);
#  endif
#endif
}

/* projections */
ccl_device_inline float2 map_to_tube(const float3 co)
{
  float len, u, v;
  len = sqrtf(co.x * co.x + co.y * co.y);
  if (len > 0.0f) {
    u = (1.0f - (atan2f(co.x / len, co.y / len) / M_PI_F)) * 0.5f;
    v = (co.z + 1.0f) * 0.5f;
  }
  else {
    u = v = 0.0f;
  }
  return make_float2(u, v);
}

ccl_device_inline float2 map_to_sphere(const float3 co)
{
  float l = len(co);
  float u, v;
  if (l > 0.0f) {
    if (UNLIKELY(co.x == 0.0f && co.y == 0.0f)) {
      u = 0.0f; /* othwise domain error */
    }
    else {
      u = (1.0f - atan2f(co.x, co.y) / M_PI_F) / 2.0f;
    }
    v = 1.0f - safe_acosf(co.z / l) / M_PI_F;
  }
  else {
    u = v = 0.0f;
  }
  return make_float2(u, v);
}

/* Compares two floats.
 * Returns true if their absolute difference is smaller than abs_diff (for numbers near zero)
 * or their relative difference is less than ulp_diff ULPs.
 * Based on
 * https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
 */

ccl_device_inline float compare_floats(const float a,
                                       const float b,
                                       const float abs_diff,
                                       const int ulp_diff)
{
  if (fabsf(a - b) < abs_diff) {
    return true;
  }

  if ((a < 0.0f) != (b < 0.0f)) {
    return false;
  }

  return (abs(__float_as_int(a) - __float_as_int(b)) < ulp_diff);
}

ccl_device_inline float clamp_to_normal(const float a)
{
  return min(max(a, 0.0f), 1.0f);
}

ccl_device_inline float4 interp_f4f4(const float4 a, const float4 b, const float t)
{
  const float s = 1.0f - t;

  return s * a + t * b;
}

CCL_NAMESPACE_END

#endif

#line 7 ".kernel_util/COM_kernel_color.h"

CCL_NAMESPACE_BEGIN

/* YCbCr */
#ifndef BLI_YCC_ITU_BT601
#  define BLI_YCC_ITU_BT601 0
#endif
#ifndef BLI_YCC_ITU_BT709
#  define BLI_YCC_ITU_BT709 1
#endif
#ifndef BLI_YCC_JFIF_0_255
#  define BLI_YCC_JFIF_0_255 2
#endif
/* END of YCbCr */

/* **************** ColorBand ********************* */
/* colormode */
#define COLBAND_BLEND_RGB 0
#define COLBAND_BLEND_HSV 1
#define COLBAND_BLEND_HSL 2

/* interpolation */
#define COLBAND_INTERP_LINEAR 0
#define COLBAND_INTERP_EASE 1
#define COLBAND_INTERP_B_SPLINE 2
#define COLBAND_INTERP_CARDINAL 3
#define COLBAND_INTERP_CONSTANT 4

/* color interpolation */
#define COLBAND_HUE_NEAR 0
#define COLBAND_HUE_FAR 1
#define COLBAND_HUE_CW 2
#define COLBAND_HUE_CCW 3
/* **************** END of ColorBand ********************* */

ccl_constant float4 BLACK_PIXEL = make_float4(0, 0, 0, 1);
ccl_constant float4 TRANSPARENT_PIXEL = make_float4(0, 0, 0, 0);

ccl_device_inline float4 premul_to_straight(const float4 premul)
{
  if (premul.w == 0.0f || premul.w == 1.0f) {
    return premul;
  }
  else {
    float4 result = premul * (1.0f / premul.w);
    result.w = premul.w;
    return result;
  }
}

ccl_device_inline float4 straight_to_premul(const float4 straight)
{
  float4 result = straight * straight.w;
  result.w = straight.w;
  return result;
}

ccl_device_inline float4 hsv_to_rgb(const float4 hsv)
{
  float4 rgb;

  rgb.x = fabsf(hsv.x * 6.0f - 3.0f) - 1.0f;
  rgb.y = 2.0f - fabsf(hsv.x * 6.0f - 2.0f);
  rgb.z = 2.0f - fabsf(hsv.x * 6.0f - 4.0f);

  rgb = clamp(rgb, 0.0f, 1.0f);
  rgb = ((rgb - 1.0f) * hsv.y + 1.0f) * hsv.z;
  rgb.w = hsv.w;

  return rgb;
}

ccl_device_inline float4 hsl_to_rgb(const float4 hsl)
{
  float4 rgb;

  rgb.x = fabsf(hsl.x * 6.0f - 3.0f) - 1.0f;
  rgb.y = 2.0f - fabsf(hsl.x * 6.0f - 2.0f);
  rgb.z = 2.0f - fabsf(hsl.x * 6.0f - 4.0f);

  rgb = clamp(rgb, 0.0f, 1.0f);

  float chroma = (1.0f - fabsf(2.0f * hsl.z - 1.0f)) * hsl.y;
  rgb = (rgb - 0.5f) * chroma + hsl.z;
  rgb.w = hsl.w;

  return rgb;
}

// In compositor only BLI_YUV_ITU_BT709 color space is used
ccl_device_inline float4 rgb_to_yuv(const float4 rgb)
{
  float4 yuv;
  yuv.x = 0.2126f * rgb.x + 0.7152f * rgb.y + 0.0722f * rgb.z;
  yuv.y = -0.09991f * rgb.x - 0.33609f * rgb.y + 0.436f * rgb.z;
  yuv.z = 0.615f * rgb.x - 0.55861f * rgb.y - 0.05639f * rgb.z;
  yuv.w = rgb.w;
  return yuv;
}

// In compositor only BLI_YUV_ITU_BT709 color space is used
ccl_device_inline float4 yuv_to_rgb(const float4 yuv)
{
  float4 rgb;
  rgb.x = yuv.x + 1.28033f * yuv.z;
  rgb.y = yuv.x - 0.21482f * yuv.y - 0.38059f * yuv.z;
  rgb.z = yuv.x + 2.12798f * yuv.y;
  rgb.w = yuv.w;
  return rgb;
}

/* The RGB inputs are supposed gamma corrected and in the range 0 - 1.0f
 */
ccl_device_inline float4 rgb_to_ycc(float4 rgb, int colorspace)
{
  float4 ycc;

  float alpha = rgb.w;
  rgb = 255.0f * rgb;
  switch (colorspace) {
    case BLI_YCC_ITU_BT601:
      ycc.x = (0.257f * rgb.x) + (0.504f * rgb.y) + (0.098f * rgb.z) + 16.0f;
      ycc.y = (-0.148f * rgb.x) - (0.291f * rgb.y) + (0.439f * rgb.z) + 128.0f;
      ycc.z = (0.439f * rgb.x) - (0.368f * rgb.y) - (0.071f * rgb.z) + 128.0f;
      break;
    case BLI_YCC_ITU_BT709:
      ycc.x = (0.183f * rgb.x) + (0.614f * rgb.y) + (0.062f * rgb.z) + 16.0f;
      ycc.y = (-0.101f * rgb.x) - (0.338f * rgb.y) + (0.439f * rgb.z) + 128.0f;
      ycc.z = (0.439f * rgb.x) - (0.399f * rgb.y) - (0.040f * rgb.z) + 128.0f;
      break;
    case BLI_YCC_JFIF_0_255:
      ycc.x = (0.299f * rgb.x) + (0.587f * rgb.y) + (0.114f * rgb.z);
      ycc.y = (-0.16874f * rgb.x) - (0.33126f * rgb.y) + (0.5f * rgb.z) + 128.0f;
      ycc.z = (0.5f * rgb.x) - (0.41869f * rgb.y) - (0.08131f * rgb.z) + 128.0f;
      break;
    default:
      kernel_assert(!"invalid colorspace");
      break;
  }
  ycc /= 255.0f;
  ycc.w = alpha;
  return ycc;
}

/* May have a bug. See FIXME comment in blendlib math_color.c */
ccl_device_inline float4 ycc_to_rgb(float4 ycc, const int colorspace)
{
  float4 rgb;
  float alpha = ycc.w;
  ycc *= 255.0f;
  switch (colorspace) {
    case BLI_YCC_ITU_BT601:
      rgb.x = 1.164f * (ycc.x - 16.0f) + 1.596f * (ycc.z - 128.0f);
      rgb.y = 1.164f * (ycc.x - 16.0f) - 0.813f * (ycc.z - 128.0f) - 0.392f * (ycc.y - 128.0f);
      rgb.z = 1.164f * (ycc.x - 16.0f) + 2.017f * (ycc.y - 128.0f);
      break;
    case BLI_YCC_ITU_BT709:
      rgb.x = 1.164f * (ycc.x - 16.0f) + 1.793f * (ycc.z - 128.0f);
      rgb.y = 1.164f * (ycc.x - 16.0f) - 0.534f * (ycc.z - 128.0f) - 0.213f * (ycc.y - 128.0f);
      rgb.z = 1.164f * (ycc.x - 16.0f) + 2.115f * (ycc.y - 128.0f);
      break;
    case BLI_YCC_JFIF_0_255:
      rgb.x = ycc.x + 1.402f * ycc.z - 179.456f;
      rgb.y = ycc.x - 0.34414f * ycc.y - 0.71414f * ycc.z + 135.45984f;
      rgb.z = ycc.x + 1.772f * ycc.y - 226.816f;
      break;
    default:
      kernel_assert(!"invalid colorspace");
      break;
  }
  rgb = rgb / 255.0f;
  rgb.w = alpha;
  return rgb;
}

ccl_device_inline float4 rgb_to_hsv(float4 rgb)
{
  float k = 0.0f;
  float chroma;
  float min_gb;

  if (rgb.y < rgb.z) {
    SWAP(float, rgb.y, rgb.z);
    k = -1.0f;
  }
  min_gb = rgb.z;
  if (rgb.x < rgb.y) {
    SWAP(float, rgb.x, rgb.y);
    k = -2.0f / 6.0f - k;
    min_gb = fminf(rgb.y, rgb.z);
  }

  chroma = rgb.x - min_gb;

  float4 hsv;
  hsv.x = fabsf(k + (rgb.y - rgb.z) / (6.0f * chroma + 1e-20f));
  hsv.y = chroma / (rgb.x + 1e-20f);
  hsv.z = rgb.x;
  hsv.w = rgb.w;
  return hsv;
}

ccl_device_inline float4 rgb_to_hsl(const float4 rgb)
{
  float4 hsl;
  const float cmax = fmaxf3(rgb.x, rgb.y, rgb.z);
  const float cmin = fminf3(rgb.x, rgb.y, rgb.z);
  hsl.z = fminf(1.0, (cmax + cmin) / 2.0f);

  if (cmax == cmin) {
    hsl.x = hsl.y = 0.0f;  // achromatic
  }
  else {
    float d = cmax - cmin;
    hsl.y = hsl.z > 0.5f ? d / (2.0f - cmax - cmin) : d / (cmax + cmin);
    if (cmax == rgb.x) {
      hsl.x = (rgb.y - rgb.z) / d + (rgb.y < rgb.z ? 6.0f : 0.0f);
    }
    else if (cmax == rgb.y) {
      hsl.x = (rgb.z - rgb.x) / d + 2.0f;
    }
    else {
      hsl.x = (rgb.x - rgb.y) / d + 4.0f;
    }
  }
  hsl.x /= 6.0f;
  hsl.w = rgb.w;
  return hsl;
}

ccl_device_inline float srgb_to_linearrgb(const float c)
{
  if (c < 0.04045f) {
    return (c < 0.0f) ? 0.0f : c * (1.0f / 12.92f);
  }
  else {
    return powf((c + 0.055f) * (1.0f / 1.055f), 2.4f);
  }
}

ccl_device_inline float linearrgb_to_srgb(const float c)
{
  if (c < 0.0031308f) {
    return (c < 0.0f) ? 0.0f : c * 12.92f;
  }
  else {
    return 1.055f * powf(c, 1.0f / 2.4f) - 0.055f;
  }
}

/**  COLORBAND **/

ccl_device_inline float colorband_hue_interp(
    const int ipotype_hue, const float mfac, const float fac, float h1, float h2)
{
  float h_interp;
  int mode = 0;

#define HUE_INTERP(h_a, h_b) ((mfac * (h_a)) + (fac * (h_b)))
#define HUE_MOD(h) (((h) < 1.0f) ? (h) : (h)-1.0f)

  h1 = HUE_MOD(h1);
  h2 = HUE_MOD(h2);

  kernel_assert(h1 >= 0.0f && h1 < 1.0f);
  kernel_assert(h2 >= 0.0f && h2 < 1.0f);

  switch (ipotype_hue) {
    case COLBAND_HUE_NEAR: {
      if ((h1 < h2) && (h2 - h1) > +0.5f) {
        mode = 1;
      }
      else if ((h1 > h2) && (h2 - h1) < -0.5f) {
        mode = 2;
      }
      else {
        mode = 0;
      }
      break;
    }
    case COLBAND_HUE_FAR: {
      /* Do full loop in Hue space in case both stops are the same... */
      if (h1 == h2) {
        mode = 1;
      }
      else if ((h1 < h2) && (h2 - h1) < +0.5f) {
        mode = 1;
      }
      else if ((h1 > h2) && (h2 - h1) > -0.5f) {
        mode = 2;
      }
      else {
        mode = 0;
      }
      break;
    }
    case COLBAND_HUE_CCW: {
      if (h1 > h2) {
        mode = 2;
      }
      else {
        mode = 0;
      }
      break;
    }
    case COLBAND_HUE_CW: {
      if (h1 < h2) {
        mode = 1;
      }
      else {
        mode = 0;
      }
      break;
    }
  }

  switch (mode) {
    case 0:
      h_interp = HUE_INTERP(h1, h2);
      break;
    case 1:
      h_interp = HUE_INTERP(h1 + 1.0f, h2);
      h_interp = HUE_MOD(h_interp);
      break;
    case 2:
      h_interp = HUE_INTERP(h1, h2 + 1.0f);
      h_interp = HUE_MOD(h_interp);
      break;
  }

  kernel_assert(h_interp >= 0.0f && h_interp < 1.0f);

#undef HUE_INTERP
#undef HUE_MOD

  return h_interp;
}

ccl_device_inline float4 colorband_evaluate(const float input_factor,
                                            const int n_bands,
                                            const int interp_type,
                                            const int hue_interp_type,
                                            const int color_mode,
                                            ccl_global float4 *bands_colors,
                                            ccl_global float *bands_pos)
{
  int cbd1, cbd2, cbd0, cbd3;
  int ipotype;

  if (n_bands == 0) {
    return make_float4(0.0f, 0.0f, 0.0f, 1.0f);
  }

  cbd1 = 0;

  /* Note: when ipotype >= COLBAND_INTERP_B_SPLINE,
   * we cannot do early-out with a constant color before first color stop and after last one,
   * because interpolation starts before and ends after those... */
  ipotype = (color_mode == COLBAND_BLEND_RGB) ? interp_type : COLBAND_INTERP_LINEAR;

  if (n_bands == 1) {
    return bands_colors[cbd1];
  }
  else if ((input_factor <= bands_pos[cbd1]) &&
           (ipotype == COLBAND_INTERP_LINEAR || ipotype == COLBAND_INTERP_EASE ||
            ipotype == COLBAND_INTERP_CONSTANT)) {
    /* We are before first color stop. */
    return bands_colors[cbd1];
  }
  else {
    // float4 left_color, right_color;
    // float left_pos, right_pos;
    int pos_idx;
    const float right_pos = 1.0f;
    const float left_pos = 0.0f;

    /* we're looking for first pos > in */
    for (pos_idx = 0; pos_idx < n_bands; pos_idx++) {
      if (bands_pos[pos_idx] > input_factor) {
        break;
      }
    }
    cbd1 += pos_idx;

    float pos1_value = bands_pos[cbd1];
    float pos2_value;
    if (pos_idx == n_bands) {
      cbd2 = cbd1 - 1;
      pos2_value = bands_pos[cbd2];
      cbd1 = cbd2;
      pos1_value = right_pos;
    }
    else if (pos_idx == 0) {
      cbd2 = cbd1;
      pos2_value = left_pos;
    }
    else {
      cbd2 = cbd1 - 1;
      pos2_value = bands_pos[cbd2];
    }

    if ((pos_idx == n_bands) &&
        (ipotype == COLBAND_INTERP_LINEAR || ipotype == COLBAND_INTERP_EASE ||
         ipotype == COLBAND_INTERP_CONSTANT)) {
      /* We are after last color stop. */
      return bands_colors[cbd2];
    }
    else if (ipotype == COLBAND_INTERP_CONSTANT) {
      /* constant */
      return bands_colors[cbd2];
    }
    else {
      float fac;
      if (pos2_value != pos1_value) {
        fac = (input_factor - pos1_value) / (pos2_value - pos1_value);
      }
      else {
        /* was setting to 0.0 in 2.56 & previous, but this
         * is incorrect for the last element, see [#26732] */
        fac = (pos_idx != n_bands) ? 0.0f : 1.0f;
      }

      if (ipotype == COLBAND_INTERP_B_SPLINE || ipotype == COLBAND_INTERP_CARDINAL) {
        /* ipo from right to left: 3 2 1 0 */
        float t[4];

        if (pos_idx >= n_bands - 1) {
          cbd0 = cbd1;
        }
        else {
          cbd0 = cbd1 + 1;
        }
        if (pos_idx < 2) {
          cbd3 = cbd2;
        }
        else {
          cbd3 = cbd2 - 1;
        }

        fac = clamp(fac, 0.0f, 1.0f);

        if (ipotype == COLBAND_INTERP_CARDINAL) {
          key_curve_position_weights(fac, t, KEY_CARDINAL);
        }
        else {
          key_curve_position_weights(fac, t, KEY_BSPLINE);
        }

        float4 result = t[3] * bands_colors[cbd3] + t[2] * bands_colors[cbd2] +
                        t[1] * bands_colors[cbd1] + t[0] * bands_colors[cbd0];
        clamp(result, 0.0f, 1.0f);
        return result;
      }
      else {
        if (ipotype == COLBAND_INTERP_EASE) {
          const float fac2 = fac * fac;
          fac = 3.0f * fac2 - 2.0f * fac2 * fac;
        }
        const float mfac = 1.0f - fac;

        if (UNLIKELY(color_mode == COLBAND_BLEND_HSV)) {
          float4 col1 = rgb_to_hsv(bands_colors[cbd1]);
          float4 col2 = rgb_to_hsv(bands_colors[cbd2]);
          float4 result;

          result.x = colorband_hue_interp(hue_interp_type, mfac, fac, col1.x, col2.x);
          result.y = mfac * col1.y + fac * col2.y;
          result.z = mfac * col1.z + fac * col2.z;
          result.w = mfac * bands_colors[cbd1].w + fac * bands_colors[cbd2].w;

          return hsv_to_rgb(result);
        }
        else if (UNLIKELY(color_mode == COLBAND_BLEND_HSL)) {
          float4 col1 = rgb_to_hsl(bands_colors[cbd1]);
          float4 col2 = rgb_to_hsl(bands_colors[cbd2]);
          float4 result;

          result.x = colorband_hue_interp(hue_interp_type, mfac, fac, col1.x, col2.x);
          result.y = mfac * col1.y + fac * col2.y;
          result.z = mfac * col1.z + fac * col2.z;
          result.w = mfac * bands_colors[cbd1].w + fac * bands_colors[cbd2].w;

          return hsl_to_rgb(result);
        }
        else {
          /* COLBAND_BLEND_RGB */
          return mfac * bands_colors[cbd1] + fac * bands_colors[cbd2];
        }
      }
    }
  }
}

/** END of COLORBAND **/

CCL_NAMESPACE_END

#endif

#line 4 ".kernel_util/COM_kernel_algo.h"
#line 1 ".kernel_util/COM_kernel_geom.h"
#ifndef __COM_KERNEL_GEOM_H__
#define __COM_KERNEL_GEOM_H__

#line 1 ".kernel_util/COM_kernel_math.h"
#ifndef __COM_KERNEL_MATH_H__
#define __COM_KERNEL_MATH_H__

/* Math
 *
 * Basic math functions on scalar and vector types. This header is used by
 * both the kernel code when compiled as C++, and other C++ non-kernel code. */

#ifndef __KERNEL_COMPUTE__
#  include <cmath>
#endif

#ifndef __KERNEL_OPENCL__
#  include <float.h>
#  include <math.h>
#  include <stdio.h>
#endif /* __KERNEL_OPENCL__ */

#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 19 ".kernel_util/COM_kernel_math.h"

CCL_NAMESPACE_BEGIN

/* Float Pi variations */

/* Division */
#ifndef M_PI_F
#  define M_PI_F (3.1415926535897932f) /* pi */
#endif
#ifndef M_PI_2_F
#  define M_PI_2_F (1.5707963267948966f) /* pi/2 */
#endif
#ifndef M_PI_4_F
#  define M_PI_4_F (0.7853981633974830f) /* pi/4 */
#endif
#ifndef M_1_PI_F
#  define M_1_PI_F (0.3183098861837067f) /* 1/pi */
#endif
#ifndef M_2_PI_F
#  define M_2_PI_F (0.6366197723675813f) /* 2/pi */
#endif
#ifndef M_1_2PI_F
#  define M_1_2PI_F (0.1591549430918953f) /* 1/(2*pi) */
#endif
#ifndef M_SQRT_PI_8_F
#  define M_SQRT_PI_8_F (0.6266570686577501f) /* sqrt(pi/8) */
#endif
#ifndef M_LN_2PI_F
#  define M_LN_2PI_F (1.8378770664093454f) /* ln(2*pi) */
#endif

/* Multiplication */
#ifndef M_2PI_F
#  define M_2PI_F (6.2831853071795864f) /* 2*pi */
#endif
#ifndef M_4PI_F
#  define M_4PI_F (12.566370614359172f) /* 4*pi */
#endif

/* Float sqrt variations */
#ifndef M_SQRT2_F
#  define M_SQRT2_F (1.4142135623730950f) /* sqrt(2) */
#endif
#ifndef M_LN2_F
#  define M_LN2_F (0.6931471805599453f) /* ln(2) */
#endif
#ifndef M_LN10_F
#  define M_LN10_F (2.3025850929940457f) /* ln(10) */
#endif

#ifndef RAD2DEGF
#  define RAD2DEGF(_rad) ((_rad) * (float)(180.0f / M_PI_F))
#endif
#ifndef DEG2RADF
#  define DEG2RADF(_deg) ((_deg) * (float)(M_PI_F / 180.0f))
#endif

/* Scalar */

#ifdef _WIN32
#  ifndef __KERNEL_OPENCL__
ccl_device_inline float fmaxf(float a, float b)
{
  return (a > b) ? a : b;
}

ccl_device_inline float fminf(float a, float b)
{
  return (a < b) ? a : b;
}
#  endif /* !__KERNEL_OPENCL__ */
#endif   /* _WIN32 */

#ifndef __KERNEL_COMPUTE__
using std::isfinite;
using std::isnan;
using std::sqrt;

ccl_device_inline int abs(const int x)
{
  return (x > 0) ? x : -x;
}

ccl_device_inline int max(const int a, const int b)
{
  return (a > b) ? a : b;
}

ccl_device_inline int min(const int a, const int b)
{
  return (a < b) ? a : b;
}

ccl_device_inline float max(const float a, const float b)
{
  return (a > b) ? a : b;
}

ccl_device_inline float min(const float a, const float b)
{
  return (a < b) ? a : b;
}
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline float fminf3(const float a, const float b, const float c)
{
  return fminf(fminf(a, b), c);
}

ccl_device_inline float fmaxf3(const float a, const float b, const float c)
{
  return fmaxf(fmaxf(a, b), c);
}

ccl_device_inline float fminf4(const float a, const float b, const float c, const float d)
{
  return fminf(fminf(a, b), fminf(c, d));
}

ccl_device_inline float fmaxf4(const float a, const float b, const float c, const float d)
{
  return fmaxf(fmaxf(a, b), fmaxf(c, d));
}

#ifndef __KERNEL_OPENCL__
/* Int/Float conversion */

ccl_device_inline int as_int(uint i)
{
  union {
    uint ui;
    int i;
  } u;
  u.ui = i;
  return u.i;
}

ccl_device_inline uint as_uint(int i)
{
  union {
    uint ui;
    int i;
  } u;
  u.i = i;
  return u.ui;
}

ccl_device_inline uint as_uint(float f)
{
  union {
    uint i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline int __float_as_int(float f)
{
  union {
    int i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline float __int_as_float(int i)
{
  union {
    int i;
    float f;
  } u;
  u.i = i;
  return u.f;
}

ccl_device_inline uint __float_as_uint(float f)
{
  union {
    uint i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline float __uint_as_float(uint i)
{
  union {
    uint i;
    float f;
  } u;
  u.i = i;
  return u.f;
}

ccl_device_inline int4 __float4_as_int4(float4 f)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(f.m128));
#  else
  return make_int4(
      __float_as_int(f.x), __float_as_int(f.y), __float_as_int(f.z), __float_as_int(f.w));
#  endif
}

ccl_device_inline float4 __int4_as_float4(int4 i)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_castsi128_ps(i.m128));
#  else
  return make_float4(
      __int_as_float(i.x), __int_as_float(i.y), __int_as_float(i.z), __int_as_float(i.w));
#  endif
}
#endif /* __KERNEL_OPENCL__ */

/* Versions of functions which are safe for fast math. */
ccl_device_inline bool isnan_safe(const float f)
{
  unsigned int x = __float_as_uint(f);
  return (x << 1) > 0xff000000u;
}

ccl_device_inline bool isfinite_safe(const float f)
{
  /* By IEEE 754 rule, 2*Inf equals Inf */
  unsigned int x = __float_as_uint(f);
  return (f == f) && (x == 0 || x == (1u << 31) || (f != 2.0f * f)) && !((x << 1) > 0xff000000u);
}

ccl_device_inline float ensure_finite(const float v)
{
  return isfinite_safe(v) ? v : 0.0f;
}

#ifndef __KERNEL_OPENCL__
ccl_device_inline int clamp(const int a, const int mn, const int mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float clamp(const float a, const float mn, const float mx)
{
  return fminf(fmaxf(a, mn), mx);
}

ccl_device_inline float mix(const float a, const float b, const float t)
{
  return a + t * (b - a);
}

ccl_device_inline float smoothstep(const float edge0, const float edge1, const float x)
{
  float result;
  if (x < edge0)
    result = 0.0f;
  else if (x >= edge1)
    result = 1.0f;
  else {
    float t = (x - edge0) / (edge1 - edge0);
    result = (3.0f - 2.0f * t) * (t * t);
  }
  return result;
}

#endif /* __KERNEL_OPENCL__ */

#ifndef __KERNEL_CUDA__
ccl_device_inline float saturate(const float a)
{
  return clamp(a, 0.0f, 1.0f);
}
#endif /* __KERNEL_CUDA__ */

ccl_device_inline int float_to_int(const float f)
{
  return (int)f;
}

ccl_device_inline int floor_to_int(const float f)
{
  return float_to_int(floorf(f));
}

ccl_device_inline int quick_floor_to_int(const float x)
{
  return float_to_int(x) - ((x < 0) ? 1 : 0);
}

ccl_device_inline float floorfrac(const float x, int *i)
{
  *i = quick_floor_to_int(x);
  return x - *i;
}

ccl_device_inline int ceil_to_int(const float f)
{
  return float_to_int(ceilf(f));
}

ccl_device_inline float fractf(const float x)
{
  return x - floorf(x);
}

/* Adapted from godotengine math_funcs.h. */
ccl_device_inline float wrapf(const float value, const float max, const float min)
{
  float range = max - min;
  return (range != 0.0f) ? value - (range * floorf((value - min) / range)) : min;
}

ccl_device_inline float pingpongf(const float a, const float b)
{
  return (b != 0.0f) ? fabsf(fractf((a - b) / (b * 2.0f)) * b * 2.0f - b) : 0.0f;
}

ccl_device_inline float smoothminf(const float a, const float b, const float k)
{
  if (k != 0.0f) {
    float h = fmaxf(k - fabsf(a - b), 0.0f) / k;
    return fminf(a, b) - h * h * h * k * (1.0f / 6.0f);
  }
  else {
    return fminf(a, b);
  }
}

ccl_device_inline float signf(const float f)
{
  return (f < 0.0f) ? -1.0f : 1.0f;
}

ccl_device_inline float nonzerof(const float f, const float eps)
{
  if (fabsf(f) < eps)
    return signf(f) * eps;
  else
    return f;
}

/* Signum function testing for zero. Matches GLSL and OSL functions. */
ccl_device_inline float compatible_signf(const float f)
{
  if (f == 0.0f) {
    return 0.0f;
  }
  else {
    return signf(f);
  }
}

ccl_device_inline float smoothstepf(const float f)
{
  float ff = f * f;
  return (3.0f * ff - 2.0f * ff * f);
}

ccl_device_inline int mod(const int x, const int m)
{
  return (x % m + m) % m;
}

ccl_device_inline float3 float2_to_float3(const float2 a)
{
  return make_float3(a.x, a.y, 0.0f);
}

ccl_device_inline float3 float4_to_float3(const float4 a)
{
  return make_float3(a.x, a.y, a.z);
}

ccl_device_inline float4 float3_to_float4(const float3 a)
{
  return make_float4(a.x, a.y, a.z, 1.0f);
}

ccl_device_inline float inverse_lerp(const float a, const float b, const float x)
{
  return (x - a) / (b - a);
}

/* Cubic interpolation between b and c, a and d are the previous and next point. */
ccl_device_inline float cubic_interp(
    const float a, const float b, const float c, const float d, const float x)
{
  return 0.5f *
             (((d + 3.0f * (b - c) - a) * x + (2.0f * a - 5.0f * b + 4.0f * c - d)) * x +
              (c - a)) *
             x +
         b;
}

CCL_NAMESPACE_END

#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 418 ".kernel_util/COM_kernel_math.h"

#line 1 ".kernel_util/COM_kernel_math_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT2_H__
#define __COM_KERNEL_MATH_INT2_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline bool operator==(const int2 a, const int2 b);
ccl_device_inline int2 operator+(const int2 &a, const int2 &b);
ccl_device_inline int2 operator+=(int2 &a, const int2 &b);
ccl_device_inline int2 operator-(const int2 &a, const int2 &b);
ccl_device_inline int2 operator*(const int2 &a, const int2 &b);
ccl_device_inline int2 operator/(const int2 &a, const int2 &b);
#endif /* !__KERNEL_OPENCL__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline bool operator==(const int2 a, const int2 b)
{
  return (a.x == b.x && a.y == b.y);
}

ccl_device_inline int2 operator+(const int2 &a, const int2 &b)
{
  return make_int2(a.x + b.x, a.y + b.y);
}

ccl_device_inline int2 operator+=(int2 &a, const int2 &b)
{
  return a = a + b;
}

ccl_device_inline int2 operator-(const int2 &a, const int2 &b)
{
  return make_int2(a.x - b.x, a.y - b.y);
}

ccl_device_inline int2 operator*(const int2 &a, const int2 &b)
{
  return make_int2(a.x * b.x, a.y * b.y);
}

ccl_device_inline int2 operator/(const int2 &a, const int2 &b)
{
  return make_int2(a.x / b.x, a.y / b.y);
}
#endif /* !__KERNEL_OPENCL__ */

CCL_NAMESPACE_END

#endif

#line 420 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT3_H__
#define __COM_KERNEL_MATH_INT3_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline int3 min(int3 a, int3 b);
ccl_device_inline int3 max(int3 a, int3 b);
ccl_device_inline int3 clamp(const int3 &a, int mn, int mx);
ccl_device_inline int3 clamp(const int3 &a, int3 &mn, int mx);
#endif /* !__KERNEL_OPENCL__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline int3 min(int3 a, int3 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int3(_mm_min_epi32(a.m128, b.m128));
#  else
  return make_int3(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));
#  endif
}

ccl_device_inline int3 max(int3 a, int3 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int3(_mm_max_epi32(a.m128, b.m128));
#  else
  return make_int3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));
#  endif
}

ccl_device_inline int3 clamp(const int3 &a, int mn, int mx)
{
#  ifdef __KERNEL_SSE__
  return min(max(a, make_int3_1(mn)), make_int3_1(mx));
#  else
  return make_int3(clamp(a.x, mn, mx), clamp(a.y, mn, mx), clamp(a.z, mn, mx));
#  endif
}

ccl_device_inline int3 clamp(const int3 &a, int3 &mn, int mx)
{
#  ifdef __KERNEL_SSE__
  return min(max(a, mn), make_int3_1(mx));
#  else
  return make_int3(clamp(a.x, mn.x, mx), clamp(a.y, mn.y, mx), clamp(a.z, mn.z, mx));
#  endif
}

ccl_device_inline bool operator==(const int3 &a, const int3 &b)
{
  return a.x == b.x && a.y == b.y && a.z == b.z;
}

ccl_device_inline bool operator!=(const int3 &a, const int3 &b)
{
  return !(a == b);
}

ccl_device_inline bool operator<(const int3 &a, const int3 &b)
{
  return a.x < b.x && a.y < b.y && a.z < b.z;
}

ccl_device_inline int3 operator+(const int3 &a, const int3 &b)
{
#  ifdef __KERNEL_SSE__
  return int3(_mm_add_epi32(a.m128, b.m128));
#  else
  return make_int3(a.x + b.x, a.y + b.y, a.z + b.z);
#  endif
}

ccl_device_inline int3 operator-(const int3 &a, const int3 &b)
{
#  ifdef __KERNEL_SSE__
  return int3(_mm_sub_epi32(a.m128, b.m128));
#  else
  return make_int3(a.x - b.x, a.y - b.y, a.z - b.z);
#  endif
}
#endif /* !__KERNEL_OPENCL__ */

CCL_NAMESPACE_END

#endif /* __COM_kernel_MATH_INT3_H__ */

#line 421 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT4_H__
#define __COM_KERNEL_MATH_INT4_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline int4 operator+(const int4 &a, const int4 &b);
ccl_device_inline int4 operator+=(int4 &a, const int4 &b);
ccl_device_inline int4 operator>>(const int4 &a, int i);
ccl_device_inline int4 operator<<(const int4 &a, int i);
ccl_device_inline int4 operator<(const int4 &a, const int4 &b);
ccl_device_inline int4 operator>=(const int4 &a, const int4 &b);
ccl_device_inline int4 operator&(const int4 &a, const int4 &b);
ccl_device_inline int4 min(int4 a, int4 b);
ccl_device_inline int4 max(int4 a, int4 b);
ccl_device_inline int4 clamp(const int4 &a, const int4 &mn, const int4 &mx);
ccl_device_inline int4 select(const int4 &mask, const int4 &a, const int4 &b);
#endif /* __KERNEL_COMPUTE__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline int4 operator+(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_add_epi32(a.m128, b.m128));
#  else
  return make_int4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
#  endif
}

ccl_device_inline int4 operator+=(int4 &a, const int4 &b)
{
  return a = a + b;
}

ccl_device_inline int4 operator>>(const int4 &a, int i)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_srai_epi32(a.m128, i));
#  else
  return make_int4(a.x >> i, a.y >> i, a.z >> i, a.w >> i);
#  endif
}

ccl_device_inline int4 operator<<(const int4 &a, int i)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_slli_epi32(a.m128, i));
#  else
  return make_int4(a.x << i, a.y << i, a.z << i, a.w << i);
#  endif
}

ccl_device_inline int4 operator<(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_cmplt_epi32(a.m128, b.m128));
#  else
  return make_int4(a.x < b.x, a.y < b.y, a.z < b.z, a.w < b.w);
#  endif
}

ccl_device_inline int4 operator>=(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_xor_si128(_mm_set1_epi32(0xffffffff), _mm_cmplt_epi32(a.m128, b.m128)));
#  else
  return make_int4(a.x >= b.x, a.y >= b.y, a.z >= b.z, a.w >= b.w);
#  endif
}

ccl_device_inline int4 operator&(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_and_si128(a.m128, b.m128));
#  else
  return make_int4(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
#  endif
}

ccl_device_inline int4 min(int4 a, int4 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int4(_mm_min_epi32(a.m128, b.m128));
#  else
  return make_int4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));
#  endif
}

ccl_device_inline int4 max(int4 a, int4 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int4(_mm_max_epi32(a.m128, b.m128));
#  else
  return make_int4(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z), max(a.w, b.w));
#  endif
}

ccl_device_inline int4 clamp(const int4 &a, const int4 &mn, const int4 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline int4 select(const int4 &mask, const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  const __m128 m = _mm_cvtepi32_ps(mask);
  /* TODO(sergey): avoid cvt. */
  return int4(_mm_castps_si128(
      _mm_or_ps(_mm_and_ps(m, _mm_castsi128_ps(a)), _mm_andnot_ps(m, _mm_castsi128_ps(b)))));
#  else
  return make_int4(
      (mask.x) ? a.x : b.x, (mask.y) ? a.y : b.y, (mask.z) ? a.z : b.z, (mask.w) ? a.w : b.w);
#  endif
}

ccl_device_inline int4 load_int4(const int *v)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_loadu_si128((__m128i *)v));
#  else
  return make_int4(v[0], v[1], v[2], v[3]);
#  endif
}
#endif /* __KERNEL_COMPUTE__ */

CCL_NAMESPACE_END

#endif

#line 422 ".kernel_util/COM_kernel_math.h"

#line 1 ".kernel_util/COM_kernel_math_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT2_H__
#define __COM_KERNEL_MATH_FLOAT2_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float2 operator-(const float2 &a);
ccl_device_inline float2 operator*(const float2 &a, const float2 &b);
ccl_device_inline float2 operator*(const float2 &a, float f);
ccl_device_inline float2 operator*(float f, const float2 &a);
ccl_device_inline float2 operator/(float f, const float2 &a);
ccl_device_inline float2 operator/(const float2 &a, float f);
ccl_device_inline float2 operator/(const float2 &a, const float2 &b);
ccl_device_inline float2 operator+(const float2 &a, const float f);
ccl_device_inline float2 operator+(const float2 &a, const float2 &b);
ccl_device_inline float2 operator-(const float2 &a, const float f);
ccl_device_inline float2 operator-(const float2 &a, const float2 &b);
ccl_device_inline float2 operator+=(float2 &a, const float2 &b);
ccl_device_inline float2 operator*=(float2 &a, const float2 &b);
ccl_device_inline float2 operator*=(float2 &a, float f);
ccl_device_inline float2 operator/=(float2 &a, const float2 &b);
ccl_device_inline float2 operator/=(float2 &a, float f);

ccl_device_inline bool operator==(const float2 &a, const float2 &b);
ccl_device_inline bool operator!=(const float2 &a, const float2 &b);

ccl_device_inline float average(const float2 &a);
ccl_device_inline float distance(const float2 &a, const float2 &b);
ccl_device_inline float dot(const float2 &a, const float2 &b);
ccl_device_inline float cross(const float2 &a, const float2 &b);
ccl_device_inline float len(const float2 &a);
ccl_device_inline float2 normalize(const float2 &a);
ccl_device_inline float2 normalize_len(const float2 &a, float *t);
ccl_device_inline float2 safe_normalize(const float2 &a);
ccl_device_inline float2 min(const float2 &a, const float2 &b);
ccl_device_inline float2 max(const float2 &a, const float2 &b);
ccl_device_inline float2 clamp(const float2 &a, const float2 &mn, const float2 &mx);
ccl_device_inline float2 fabs(const float2 &a);
ccl_device_inline float2 as_float2(const float4 &a);
ccl_device_inline float2 interp(const float2 &a, const float2 &b, float t);
ccl_device_inline float2 floor(const float2 &a);
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float2 safe_divide_float2_float(const float2 a, const float b);

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float2 operator-(const float2 &a)
{
  return make_float2(-a.x, -a.y);
}

ccl_device_inline float2 operator*(const float2 &a, const float2 &b)
{
  return make_float2(a.x * b.x, a.y * b.y);
}

ccl_device_inline float2 operator*(const float2 &a, float f)
{
  return make_float2(a.x * f, a.y * f);
}

ccl_device_inline float2 operator*(float f, const float2 &a)
{
  return make_float2(a.x * f, a.y * f);
}

ccl_device_inline float2 operator/(float f, const float2 &a)
{
  return make_float2(f / a.x, f / a.y);
}

ccl_device_inline float2 operator/(const float2 &a, float f)
{
  float invf = 1.0f / f;
  return make_float2(a.x * invf, a.y * invf);
}

ccl_device_inline float2 operator/(const float2 &a, const float2 &b)
{
  return make_float2(a.x / b.x, a.y / b.y);
}

ccl_device_inline float2 operator+(const float2 &a, const float f)
{
  return a + make_float2(f, f);
}

ccl_device_inline float2 operator+(const float2 &a, const float2 &b)
{
  return make_float2(a.x + b.x, a.y + b.y);
}

ccl_device_inline float2 operator-(const float2 &a, const float f)
{
  return a - make_float2(f, f);
}

ccl_device_inline float2 operator-(const float2 &a, const float2 &b)
{
  return make_float2(a.x - b.x, a.y - b.y);
}

ccl_device_inline float2 operator+=(float2 &a, const float2 &b)
{
  return a = a + b;
}

ccl_device_inline float2 operator*=(float2 &a, const float2 &b)
{
  return a = a * b;
}

ccl_device_inline float2 operator*=(float2 &a, float f)
{
  return a = a * f;
}

ccl_device_inline float2 operator/=(float2 &a, const float2 &b)
{
  return a = a / b;
}

ccl_device_inline float2 operator/=(float2 &a, float f)
{
  float invf = 1.0f / f;
  return a = a * invf;
}

ccl_device_inline bool operator==(const float2 &a, const float2 &b)
{
  return (a.x == b.x && a.y == b.y);
}

ccl_device_inline bool operator!=(const float2 &a, const float2 &b)
{
  return !(a == b);
}

ccl_device_inline float average(const float2 &a)
{
  return (a.x + a.y) * (1.0f / 2.0f);
}

ccl_device_inline float distance(const float2 &a, const float2 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float2 &a, const float2 &b)
{
  return a.x * b.x + a.y * b.y;
}

ccl_device_inline float cross(const float2 &a, const float2 &b)
{
  return (a.x * b.y - a.y * b.x);
}

ccl_device_inline float len(const float2 &a)
{
  return sqrtf(dot(a, a));
}

ccl_device_inline float2 normalize(const float2 &a)
{
  return a / len(a);
}

ccl_device_inline float2 normalize_len(const float2 &a, float *t)
{
  *t = len(a);
  return a / (*t);
}

ccl_device_inline float2 safe_normalize(const float2 &a)
{
  float t = len(a);
  return (t != 0.0f) ? a / t : a;
}

ccl_device_inline float2 min(const float2 &a, const float2 &b)
{
  return make_float2(fminf(a.x, b.x), fminf(a.y, b.y));
}

ccl_device_inline float2 max(const float2 &a, const float2 &b)
{
  return make_float2(fmaxf(a.x, b.x), fmaxf(a.y, b.y));
}

ccl_device_inline float2 clamp(const float2 &a, const float2 &mn, const float2 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float2 fabs(const float2 &a)
{
  return make_float2(fabsf(a.x), fabsf(a.y));
}

ccl_device_inline float2 as_float2(const float4 &a)
{
  return make_float2(a.x, a.y);
}

ccl_device_inline float2 interp(const float2 &a, const float2 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float2 mix(const float2 &a, const float2 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float2 floor(const float2 &a)
{
  return make_float2(floorf(a.x), floorf(a.y));
}

#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float2 safe_divide_float2_float(const float2 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float2(0.0f, 0.0f);
}

CCL_NAMESPACE_END

#endif

#line 424 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT3_H__
#define __COM_KERNEL_MATH_FLOAT3_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float3 operator-(const float3 &a);
ccl_device_inline float3 operator*(const float3 &a, const float3 &b);
ccl_device_inline float3 operator*(const float3 &a, const float f);
ccl_device_inline float3 operator*(const float f, const float3 &a);
ccl_device_inline float3 operator/(const float f, const float3 &a);
ccl_device_inline float3 operator/(const float3 &a, const float f);
ccl_device_inline float3 operator/(const float3 &a, const float3 &b);
ccl_device_inline float3 operator+(const float3 &a, const float f);
ccl_device_inline float3 operator+(const float3 &a, const float3 &b);
ccl_device_inline float3 operator-(const float3 &a, const float f);
ccl_device_inline float3 operator-(const float3 &a, const float3 &b);
ccl_device_inline float3 operator+=(float3 &a, const float3 &b);
ccl_device_inline float3 operator-=(float3 &a, const float3 &b);
ccl_device_inline float3 operator*=(float3 &a, const float3 &b);
ccl_device_inline float3 operator*=(float3 &a, float f);
ccl_device_inline float3 operator/=(float3 &a, const float3 &b);
ccl_device_inline float3 operator/=(float3 &a, float f);

ccl_device_inline bool operator==(const float3 &a, const float3 &b);
ccl_device_inline bool operator!=(const float3 &a, const float3 &b);

ccl_device_inline float distance(const float3 &a, const float3 &b);
ccl_device_inline float dot(const float3 &a, const float3 &b);
ccl_device_inline float dot_xy(const float3 &a, const float3 &b);
ccl_device_inline float3 cross(const float3 &a, const float3 &b);
ccl_device_inline float3 normalize(const float3 &a);
ccl_device_inline float3 min(const float3 &a, const float3 &b);
ccl_device_inline float3 max(const float3 &a, const float3 &b);
ccl_device_inline float3 clamp(const float3 &a, const float3 &mn, const float3 &mx);
ccl_device_inline float3 fabs(const float3 &a);
ccl_device_inline float3 mix(const float3 &a, const float3 &b, float t);
ccl_device_inline float3 rcp(const float3 &a);
ccl_device_inline float3 sqrt(const float3 &a);
ccl_device_inline float3 floor(const float3 &a);
ccl_device_inline float3 ceil(const float3 &a);
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float min3(float3 a);
ccl_device_inline float max3(float3 a);
ccl_device_inline float len(const float3 a);
ccl_device_inline float len_squared(const float3 a);

ccl_device_inline float3 reflect(const float3 incident, const float3 normal);
ccl_device_inline float3 project(const float3 v, const float3 v_proj);

ccl_device_inline float3 saturate3(float3 a);
ccl_device_inline float3 safe_normalize(const float3 a);
ccl_device_inline float3 normalize_len(const float3 a, float *t);
ccl_device_inline float3 safe_normalize_len(const float3 a, float *t);
ccl_device_inline float3 safe_divide_float3_float3(const float3 a, const float3 b);
ccl_device_inline float3 safe_divide_float3_float(const float3 a, const float b);
ccl_device_inline float3 interp(float3 a, float3 b, float t);
ccl_device_inline float3 sqr3(float3 a);
ccl_device_inline float reduce_add(const float3 a);
ccl_device_inline float average(const float3 a);
ccl_device_inline bool isequal_float3(const float3 a, const float3 b);

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float3 operator-(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_xor_ps(a.m128, _mm_castsi128_ps(_mm_set1_epi32(0x80000000))));
#  else
  return make_float3(-a.x, -a.y, -a.z);
#  endif
}

ccl_device_inline float3 operator*(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_mul_ps(a.m128, b.m128));
#  else
  return make_float3(a.x * b.x, a.y * b.y, a.z * b.z);
#  endif
}

ccl_device_inline float3 operator*(const float3 &a, const float f)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_mul_ps(a.m128, _mm_set1_ps(f)));
#  else
  return make_float3(a.x * f, a.y * f, a.z * f);
#  endif
}

ccl_device_inline float3 operator*(const float f, const float3 &a)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_mul_ps(_mm_set1_ps(f), a.m128));
#  else
  return make_float3(a.x * f, a.y * f, a.z * f);
#  endif
}

ccl_device_inline float3 operator/(const float f, const float3 &a)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_div_ps(_mm_set1_ps(f), a.m128));
#  else
  return make_float3(f / a.x, f / a.y, f / a.z);
#  endif
}

ccl_device_inline float3 operator/(const float3 &a, const float f)
{
  float invf = 1.0f / f;
  return a * invf;
}

ccl_device_inline float3 operator/(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_div_ps(a.m128, b.m128));
#  else
  return make_float3(a.x / b.x, a.y / b.y, a.z / b.z);
#  endif
}

ccl_device_inline float3 operator+(const float3 &a, const float f)
{
  return a + make_float3(f, f, f);
}

ccl_device_inline float3 operator+(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_add_ps(a.m128, b.m128));
#  else
  return make_float3(a.x + b.x, a.y + b.y, a.z + b.z);
#  endif
}

ccl_device_inline float3 operator-(const float3 &a, const float f)
{
  return a - make_float3(f, f, f);
}

ccl_device_inline float3 operator-(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_sub_ps(a.m128, b.m128));
#  else
  return make_float3(a.x - b.x, a.y - b.y, a.z - b.z);
#  endif
}

ccl_device_inline float3 operator+=(float3 &a, const float3 &b)
{
  return a = a + b;
}

ccl_device_inline float3 operator-=(float3 &a, const float3 &b)
{
  return a = a - b;
}

ccl_device_inline float3 operator*=(float3 &a, const float3 &b)
{
  return a = a * b;
}

ccl_device_inline float3 operator*=(float3 &a, float f)
{
  return a = a * f;
}

ccl_device_inline float3 operator/=(float3 &a, const float3 &b)
{
  return a = a / b;
}

ccl_device_inline float3 operator/=(float3 &a, float f)
{
  float invf = 1.0f / f;
  return a = a * invf;
}

ccl_device_inline bool operator==(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return (_mm_movemask_ps(_mm_cmpeq_ps(a.m128, b.m128)) & 7) == 7;
#  else
  return (a.x == b.x && a.y == b.y && a.z == b.z);
#  endif
}

ccl_device_inline bool operator!=(const float3 &a, const float3 &b)
{
  return !(a == b);
}

ccl_device_inline float distance(const float3 &a, const float3 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_dp_ps(a, b, 0x7F));
#  else
  return a.x * b.x + a.y * b.y + a.z * b.z;
#  endif
}

ccl_device_inline float dot_xy(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_hadd_ps(_mm_mul_ps(a, b), b));
#  else
  return a.x * b.x + a.y * b.y;
#  endif
}

ccl_device_inline float3 cross(const float3 &a, const float3 &b)
{
  float3 r = make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
  return r;
}

ccl_device_inline float3 normalize(const float3 &a)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  __m128 norm = _mm_sqrt_ps(_mm_dp_ps(a.m128, a.m128, 0x7F));
  return float3(_mm_div_ps(a.m128, norm));
#  else
  return a / len(a);
#  endif
}

ccl_device_inline float3 min(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_min_ps(a.m128, b.m128));
#  else
  return make_float3(fminf(a.x, b.x), fminf(a.y, b.y), fminf(a.z, b.z));
#  endif
}

ccl_device_inline float3 max(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_max_ps(a.m128, b.m128));
#  else
  return make_float3(fmaxf(a.x, b.x), fmaxf(a.y, b.y), fmaxf(a.z, b.z));
#  endif
}

ccl_device_inline float3 clamp(const float3 &a, const float3 &mn, const float3 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float3 fabs(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  __m128 mask = _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff));
  return float3(_mm_and_ps(a.m128, mask));
#  else
  return make_float3(fabsf(a.x), fabsf(a.y), fabsf(a.z));
#  endif
}

ccl_device_inline float3 sqrt(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_sqrt_ps(a));
#  else
  return make_float3(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z));
#  endif
}

ccl_device_inline float3 floor(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_floor_ps(a));
#  else
  return make_float3(floorf(a.x), floorf(a.y), floorf(a.z));
#  endif
}

ccl_device_inline float3 ceil(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_ceil_ps(a));
#  else
  return make_float3(ceilf(a.x), ceilf(a.y), ceilf(a.z));
#  endif
}

ccl_device_inline float3 mix(const float3 &a, const float3 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float3 rcp(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  /* Don't use _mm_rcp_ps due to poor precision. */
  return float3(_mm_div_ps(_mm_set_ps1(1.0f), a.m128));
#  else
  return make_float3(1.0f / a.x, 1.0f / a.y, 1.0f / a.z);
#  endif
}
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float min3(const float3 a)
{
  return min(min(a.x, a.y), a.z);
}

ccl_device_inline float max3(const float3 a)
{
  return max(max(a.x, a.y), a.z);
}

ccl_device_inline float len(const float3 a)
{
#if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_sqrt_ss(_mm_dp_ps(a.m128, a.m128, 0x7F)));
#else
  return sqrtf(dot(a, a));
#endif
}

ccl_device_inline float len_squared(const float3 a)
{
  return dot(a, a);
}

ccl_device_inline float3 reflect(const float3 incident, const float3 normal)
{
  float3 unit_normal = normalize(normal);
  return incident - 2.0f * unit_normal * dot(incident, unit_normal);
}

ccl_device_inline float3 project(const float3 v, const float3 v_proj)
{
  float len_squared = dot(v_proj, v_proj);
  return (len_squared != 0.0f) ? (dot(v, v_proj) / len_squared) * v_proj :
                                 make_float3(0.0f, 0.0f, 0.0f);
}

ccl_device_inline float3 saturate3(const float3 a)
{
  return make_float3(saturate(a.x), saturate(a.y), saturate(a.z));
}

ccl_device_inline float3 normalize_len(const float3 a, float *t)
{
  *t = len(a);
  float x = 1.0f / *t;
  return a * x;
}

ccl_device_inline float3 safe_normalize(const float3 a)
{
  float t = len(a);
  return (t != 0.0f) ? a * (1.0f / t) : a;
}

ccl_device_inline float3 safe_normalize_len(const float3 a, float *t)
{
  *t = len(a);
  return (*t != 0.0f) ? a / (*t) : a;
}

ccl_device_inline float3 safe_divide_float3_float3(const float3 a, const float3 b)
{
  return make_float3((b.x != 0.0f) ? a.x / b.x : 0.0f,
                     (b.y != 0.0f) ? a.y / b.y : 0.0f,
                     (b.z != 0.0f) ? a.z / b.z : 0.0f);
}

ccl_device_inline float3 safe_divide_float3_float(const float3 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float3(0.0f, 0.0f, 0.0f);
}

ccl_device_inline float3 interp(const float3 a, const float3 b, const float t)
{
  return a + t * (b - a);
}

ccl_device_inline float3 sqr3(const float3 a)
{
  return a * a;
}

ccl_device_inline float reduce_add(const float3 a)
{
  return (a.x + a.y + a.z);
}

ccl_device_inline float average(const float3 a)
{
  return reduce_add(a) * (1.0f / 3.0f);
}

ccl_device_inline bool isequal_float3(const float3 a, const float3 b)
{
#ifdef __KERNEL_OPENCL__
  return all(a == b);
#else
  return a == b;
#endif
}

ccl_device_inline float3 pow3(const float3 v, const float e)
{
  return make_float3(powf(v.x, e), powf(v.y, e), powf(v.z, e));
}

ccl_device_inline float3 exp3(const float3 v)
{
  return make_float3(expf(v.x), expf(v.y), expf(v.z));
}

ccl_device_inline float3 log3(const float3 v)
{
  return make_float3(logf(v.x), logf(v.y), logf(v.z));
}

ccl_device_inline int3 quick_floor_to_int3(const float3 a)
{
#ifdef __KERNEL_SSE__
  int3 b = int3(_mm_cvttps_epi32(a.m128));
  int3 isneg = int3(_mm_castps_si128(_mm_cmplt_ps(a.m128, _mm_set_ps1(0.0f))));
  /* Unsaturated add 0xffffffff is the same as subtract -1. */
  return b + isneg;
#else
  return make_int3(quick_floor_to_int(a.x), quick_floor_to_int(a.y), quick_floor_to_int(a.z));
#endif
}

ccl_device_inline bool isfinite3_safe(const float3 v)
{
  return isfinite_safe(v.x) && isfinite_safe(v.y) && isfinite_safe(v.z);
}

ccl_device_inline float3 ensure_finite3(float3 v)
{
  if (!isfinite_safe(v.x))
    v.x = 0.0f;
  if (!isfinite_safe(v.y))
    v.y = 0.0f;
  if (!isfinite_safe(v.z))
    v.z = 0.0f;
  return v;
}

CCL_NAMESPACE_END

#endif

#line 425 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT4_H__
#define __COM_KERNEL_MATH_FLOAT4_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float4 operator-(const float4 &a);
ccl_device_inline float4 operator*(const float4 &a, const float4 &b);
ccl_device_inline float4 operator*(const float4 &a, const float f);
ccl_device_inline float4 operator*(const float f, const float4 &a);
ccl_device_inline float4 operator/(const float4 &a, float f);
ccl_device_inline float4 operator/(const float f, const float4 &a);
ccl_device_inline float4 operator/(const float4 &a, const float4 &b);
ccl_device_inline float4 operator+(const float4 &a, const float f);
ccl_device_inline float4 operator+(const float f, const float4 &a);
ccl_device_inline float4 operator+(const float4 &a, const float4 &b);
ccl_device_inline float4 operator-(const float4 &a, const float f);
ccl_device_inline float4 operator-(const float f, const float4 &a);
ccl_device_inline float4 operator-(const float4 &a, const float4 &b);
ccl_device_inline float4 operator+=(float4 &a, const float4 &b);
ccl_device_inline float4 operator*=(float4 &a, const float4 &b);
ccl_device_inline float4 operator*=(float4 &a, const float f);
ccl_device_inline float4 operator/=(float4 &a, const float f);

ccl_device_inline int4 operator<(const float4 &a, const float4 &b);
ccl_device_inline int4 operator>(const float4 &a, const float4 &b);
ccl_device_inline int4 operator>=(const float4 &a, const float4 &b);
ccl_device_inline int4 operator<=(const float4 &a, const float4 &b);
ccl_device_inline int4 operator==(const float4 &a, const float4 &b);
ccl_device_inline int4 operator!=(const float4 &a, const float4 &b);

ccl_device_inline float distance(const float4 &a, const float4 &b);
ccl_device_inline float dot(const float4 &a, const float4 &b);
ccl_device_inline float len_squared(const float4 &a);
ccl_device_inline float4 rcp(const float4 &a);
ccl_device_inline float4 sqrt(const float4 &a);
ccl_device_inline float4 sqr(const float4 &a);
ccl_device_inline float4 cross(const float4 &a, const float4 &b);
ccl_device_inline float average(const float4 &a);
ccl_device_inline float len(const float4 &a);
ccl_device_inline float4 normalize(const float4 &a);
ccl_device_inline float4 safe_normalize(const float4 &a);
ccl_device_inline float4 min(const float4 &a, const float4 &b);
ccl_device_inline float4 min(const float4 &a, const float b);
ccl_device_inline float4 max(const float4 &a, const float4 &b);
ccl_device_inline float4 max(const float4 &a, const float b);
ccl_device_inline float4 clamp(const float4 &a, const float4 &mn, const float4 &mx);
ccl_device_inline float4 clamp(const float4 &a, const float mn, const float mx);
ccl_device_inline float4 fabs(const float4 &a);
ccl_device_inline float4 floor(const float4 &a);
ccl_device_inline float4 mix(const float4 &a, const float4 &b, const float t);
#endif /* !__KERNEL_OPENCL__*/

ccl_device_inline float4 safe_divide_float4_float(const float4 a, const float b);
ccl_device_inline float4 clamp_to_normal_f4(const float4 a);

#ifdef __KERNEL_SSE__
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &b);
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &a, const float4 &b);

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &b);

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &a, const float4 &b);
template<> __forceinline const float4 shuffle<2, 3, 2, 3>(const float4 &a, const float4 &b);

#  ifdef __KERNEL_SSE3__
template<> __forceinline const float4 shuffle<0, 0, 2, 2>(const float4 &b);
template<> __forceinline const float4 shuffle<1, 1, 3, 3>(const float4 &b);
#  endif
#endif /* __KERNEL_SSE__ */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline float4 select(const float4 &b_false, const float4 &a_true, const int4 &mask);
ccl_device_inline float4 reduce_min(const float4 &a);
ccl_device_inline float4 reduce_max(const float4 &a);
ccl_device_inline float4 reduce_add(const float4 &a);
#endif /* !__KERNEL_COMPUTE__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float4 operator-(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  __m128 mask = _mm_castsi128_ps(_mm_set1_epi32(0x80000000));
  return float4(_mm_xor_ps(a.m128, mask));
#  else
  return make_float4(-a.x, -a.y, -a.z, -a.w);
#  endif
}

ccl_device_inline float4 operator*(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_mul_ps(a.m128, b.m128));
#  else
  return make_float4(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
#  endif
}

ccl_device_inline float4 operator*(const float4 &a, const float f)
{
#  if defined(__KERNEL_SSE__)
  return a * make_float4_1(f);
#  else
  return make_float4(a.x * f, a.y * f, a.z * f, a.w * f);
#  endif
}

ccl_device_inline float4 operator*(const float f, const float4 &a)
{
  return a * f;
}

ccl_device_inline float4 operator/(const float4 &a, const float f)
{
  return a * (1.0f / f);
}

ccl_device_inline float4 operator/(const float f, const float4 &a)
{
  return make_float4_1(f) / a;
}
ccl_device_inline float4 operator/(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_div_ps(a.m128, b.m128));
#  else
  return make_float4(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
#  endif
}

ccl_device_inline float4 operator+(const float4 &a, const float f)
{
  return a + make_float4(f, f, f, f);
}

ccl_device_inline float4 operator+(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_add_ps(a.m128, b.m128));
#  else
  return make_float4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
#  endif
}

ccl_device_inline float4 operator+(const float f, const float4 &a)
{
  return make_float4(f, f, f, f) + a;
}

ccl_device_inline float4 operator-(const float4 &a, const float f)
{
  return a - make_float4(f, f, f, f);
}

ccl_device_inline float4 operator-(const float f, const float4 &a)
{
  return make_float4(f, f, f, f) - a;
}

ccl_device_inline float4 operator-(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_sub_ps(a.m128, b.m128));
#  else
  return make_float4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
#  endif
}

ccl_device_inline float4 operator+=(float4 &a, const float4 &b)
{
  return a = a + b;
}

ccl_device_inline float4 operator-=(float4 &a, const float4 &b)
{
  return a = a - b;
}

ccl_device_inline float4 operator*=(float4 &a, const float4 &b)
{
  return a = a * b;
}

ccl_device_inline float4 operator*=(float4 &a, const float f)
{
  return a = a * f;
}

ccl_device_inline float4 operator/=(float4 &a, const float f)
{
  return a = a / f;
}

ccl_device_inline int4 operator<(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmplt_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x < b.x, a.y < b.y, a.z < b.z, a.w < b.w);
#  endif
}

ccl_device_inline int4 operator>(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpgt_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x > b.x, a.y > b.y, a.z > b.z, a.w > b.w);
#  endif
}

ccl_device_inline int4 operator>=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpge_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x >= b.x, a.y >= b.y, a.z >= b.z, a.w >= b.w);
#  endif
}

ccl_device_inline int4 operator<=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmple_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x <= b.x, a.y <= b.y, a.z <= b.z, a.w <= b.w);
#  endif
}

ccl_device_inline int4 operator==(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpeq_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w);
#  endif
}

ccl_device_inline int4 operator!=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpneq_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x != b.x, a.y != b.y, a.z != b.z, a.w != b.w);
#  endif
}

ccl_device_inline float distance(const float4 &a, const float4 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float4 &a, const float4 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_dp_ps(a, b, 0xFF));
#  else
  return (a.x * b.x + a.y * b.y) + (a.z * b.z + a.w * b.w);
#  endif
}

ccl_device_inline float len_squared(const float4 &a)
{
  return dot(a, a);
}

ccl_device_inline float4 rcp(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  /* Don't use _mm_rcp_ps due to poor precision. */
  return float4(_mm_div_ps(_mm_set_ps1(1.0f), a.m128));
#  else
  return make_float4(1.0f / a.x, 1.0f / a.y, 1.0f / a.z, 1.0f / a.w);
#  endif
}

ccl_device_inline float4 sqrt(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_sqrt_ps(a.m128));
#  else
  return make_float4(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z), sqrtf(a.w));
#  endif
}

ccl_device_inline float4 sqr(const float4 &a)
{
  return a * a;
}

ccl_device_inline float4 cross(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return (shuffle<1, 2, 0, 0>(a) * shuffle<2, 0, 1, 0>(b)) -
         (shuffle<2, 0, 1, 0>(a) * shuffle<1, 2, 0, 0>(b));
#  else
  return make_float4(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x, 0.0f);
#  endif
}

ccl_device_inline float4 reduce_add(const float4 &a)
{
#  ifdef __KERNEL_SSE__
#    ifdef __KERNEL_SSE3__
  float4 h(_mm_hadd_ps(a.m128, a.m128));
  return float4(_mm_hadd_ps(h.m128, h.m128));
#    else
  float4 h(shuffle<1, 0, 3, 2>(a) + a);
  return shuffle<2, 3, 0, 1>(h) + h;
#    endif
#  else
  float sum = (a.x + a.y) + (a.z + a.w);
  return make_float4(sum, sum, sum, sum);
#  endif
}

ccl_device_inline float average(const float4 &a)
{
  return reduce_add(a).x * 0.25f;
}

ccl_device_inline float len(const float4 &a)
{
  return sqrtf(dot(a, a));
}

ccl_device_inline float4 normalize(const float4 &a)
{
  return a / len(a);
}

ccl_device_inline float4 safe_normalize(const float4 &a)
{
  float t = len(a);
  return (t != 0.0f) ? a / t : a;
}

ccl_device_inline float4 min(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_min_ps(a.m128, b.m128));
#  else
  return make_float4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));
#  endif
}

ccl_device_inline float4 min(const float4 &a, const float b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_min_ps(a.m128, _mm_set1_ps(b)));
#  else
  return make_float4(fminf(a.x, b), fminf(a.y, b), fminf(a.z, b), fminf(a.w, b));
#  endif
}

ccl_device_inline float4 max(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_max_ps(a.m128, b.m128));
#  else
  return make_float4(fmaxf(a.x, b.x), fmaxf(a.y, b.y), fmaxf(a.z, b.z), fmaxf(a.w, b.w));
#  endif
}

ccl_device_inline float4 max(const float4 &a, const float b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_max_ps(a.m128, _mm_set1_ps(b)));
#  else
  return make_float4(fminf(a.x, b), fminf(a.y, b), fminf(a.z, b), fminf(a.w, b));
#  endif
}

ccl_device_inline float4 clamp(const float4 &a, const float4 &mn, const float4 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float4 clamp(const float4 &a, const float mn, const float mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float4 fabs(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_and_ps(a.m128, _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff))));
#  else
  return make_float4(fabsf(a.x), fabsf(a.y), fabsf(a.z), fabsf(a.w));
#  endif
}

ccl_device_inline float4 floor(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_floor_ps(a));
#  else
  return make_float4(floorf(a.x), floorf(a.y), floorf(a.z), floorf(a.w));
#  endif
}

ccl_device_inline float4 mix(const float4 &a, const float4 &b, const float t)
{
  return a + t * (b - a);
}

#endif /* !__KERNEL_COMPUTE__*/

#ifdef __KERNEL_SSE__
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &b)
{
  return float4(_mm_castsi128_ps(
      _mm_shuffle_epi32(_mm_castps_si128(b), _MM_SHUFFLE(index_3, index_2, index_1, index_0))));
}

template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &a, const float4 &b)
{
  return float4(_mm_shuffle_ps(a.m128, b.m128, _MM_SHUFFLE(index_3, index_2, index_1, index_0)));
}

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &b)
{
  return float4(_mm_castpd_ps(_mm_movedup_pd(_mm_castps_pd(b))));
}

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &a, const float4 &b)
{
  return float4(_mm_movelh_ps(a.m128, b.m128));
}

template<> __forceinline const float4 shuffle<2, 3, 2, 3>(const float4 &a, const float4 &b)
{
  return float4(_mm_movehl_ps(b.m128, a.m128));
}

#  ifdef __KERNEL_SSE3__
template<> __forceinline const float4 shuffle<0, 0, 2, 2>(const float4 &b)
{
  return float4(_mm_moveldup_ps(b));
}

template<> __forceinline const float4 shuffle<1, 1, 3, 3>(const float4 &b)
{
  return float4(_mm_movehdup_ps(b));
}
#  endif /* __KERNEL_SSE3__ */
#endif   /* __KERNEL_SSE__ */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline float4 select(const float4 &b_false, const float4 &a_true, const int4 &mask)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_blendv_ps(b_false.m128, a_true.m128, _mm_castsi128_ps(mask.m128)));
#  else
  return make_float4((mask.x) ? a_true.x : b_false.x,
                     (mask.y) ? a_true.y : b_false.y,
                     (mask.z) ? a_true.z : b_false.z,
                     (mask.w) ? a_true.w : b_false.w);
#  endif
}

ccl_device_inline float4 reduce_min(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  float4 h = min(shuffle<1, 0, 3, 2>(a), a);
  return min(shuffle<2, 3, 0, 1>(h), h);
#  else
  return make_float4(min(min(a.x, a.y), min(a.z, a.w)));
#  endif
}

ccl_device_inline float4 reduce_max(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  float4 h = max(shuffle<1, 0, 3, 2>(a), a);
  return max(shuffle<2, 3, 0, 1>(h), h);
#  else
  return make_float4(max(max(a.x, a.y), max(a.z, a.w)));
#  endif
}

#endif /* !__KERNEL_COMPUTE__ */

ccl_device_inline float4 safe_divide_float4_float(const float4 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float4(0.0f, 0.0f, 0.0f, 0.0f);
}

ccl_device_inline float4 clamp_to_normal_f4(const float4 a)
{
  return min(max(a, 0.0f), 1.0f);
}

CCL_NAMESPACE_END

#endif

#line 426 ".kernel_util/COM_kernel_math.h"

CCL_NAMESPACE_BEGIN

#ifndef __KERNEL_OPENCL__
/* Interpolation */

template<class A, class B> A lerp(const A &a, const A &b, const B &t)
{
  return (A)(a * ((B)1 - t) + b * t);
}

#endif /* __KERNEL_OPENCL__ */

/* Triangle */
#ifndef __KERNEL_OPENCL__
ccl_device_inline float triangle_area(const float3 &v1, const float3 &v2, const float3 &v3)
#else
ccl_device_inline float triangle_area(const float3 v1, const float3 v2, const float3 v3)
#endif
{
  return len(cross(v3 - v2, v1 - v2)) * 0.5f;
}

/* Orthonormal vectors */

ccl_device_inline void make_orthonormals(const float3 N, float3 *a, float3 *b)
{
#if 0
  if (fabsf(N.y) >= 0.999f) {
    *a = make_float3(1, 0, 0);
    *b = make_float3(0, 0, 1);
    return;
  }
  if (fabsf(N.z) >= 0.999f) {
    *a = make_float3(1, 0, 0);
    *b = make_float3(0, 1, 0);
    return;
  }
#endif

  if (N.x != N.y || N.x != N.z)
    *a = make_float3(N.z - N.y, N.x - N.z, N.y - N.x);  //(1,1,1)x N
  else
    *a = make_float3(N.z - N.y, N.x + N.z, -N.y - N.x);  //(-1,1,1)x N

  *a = normalize(*a);
  *b = cross(N, *a);
}

/* Color division */

ccl_device_inline float3 safe_invert_color(const float3 a)
{
  float x, y, z;

  x = (a.x != 0.0f) ? 1.0f / a.x : 0.0f;
  y = (a.y != 0.0f) ? 1.0f / a.y : 0.0f;
  z = (a.z != 0.0f) ? 1.0f / a.z : 0.0f;

  return make_float3(x, y, z);
}

ccl_device_inline float3 safe_divide_color(const float3 a, const float3 b)
{
  float x, y, z;

  x = (b.x != 0.0f) ? a.x / b.x : 0.0f;
  y = (b.y != 0.0f) ? a.y / b.y : 0.0f;
  z = (b.z != 0.0f) ? a.z / b.z : 0.0f;

  return make_float3(x, y, z);
}

ccl_device_inline float3 safe_divide_even_color(const float3 a, const float3 b)
{
  float x, y, z;

  x = (b.x != 0.0f) ? a.x / b.x : 0.0f;
  y = (b.y != 0.0f) ? a.y / b.y : 0.0f;
  z = (b.z != 0.0f) ? a.z / b.z : 0.0f;

  /* try to get gray even if b is zero */
  if (b.x == 0.0f) {
    if (b.y == 0.0f) {
      x = z;
      y = z;
    }
    else if (b.z == 0.0f) {
      x = y;
      z = y;
    }
    else
      x = 0.5f * (y + z);
  }
  else if (b.y == 0.0f) {
    if (b.z == 0.0f) {
      y = x;
      z = x;
    }
    else
      y = 0.5f * (x + z);
  }
  else if (b.z == 0.0f) {
    z = 0.5f * (x + y);
  }

  return make_float3(x, y, z);
}

/* Rotation of point around axis and angle */

ccl_device_inline float3 rotate_around_axis(const float3 p, const float3 axis, const float angle)
{
  float costheta = cosf(angle);
  float sintheta = sinf(angle);
  float3 r;

  r.x = ((costheta + (1 - costheta) * axis.x * axis.x) * p.x) +
        (((1 - costheta) * axis.x * axis.y - axis.z * sintheta) * p.y) +
        (((1 - costheta) * axis.x * axis.z + axis.y * sintheta) * p.z);

  r.y = (((1 - costheta) * axis.x * axis.y + axis.z * sintheta) * p.x) +
        ((costheta + (1 - costheta) * axis.y * axis.y) * p.y) +
        (((1 - costheta) * axis.y * axis.z - axis.x * sintheta) * p.z);

  r.z = (((1 - costheta) * axis.x * axis.z - axis.y * sintheta) * p.x) +
        (((1 - costheta) * axis.y * axis.z + axis.x * sintheta) * p.y) +
        ((costheta + (1 - costheta) * axis.z * axis.z) * p.z);

  return r;
}

/* NaN-safe math ops */

ccl_device_inline float safe_sqrtf(const float f)
{
  return sqrtf(max(f, 0.0f));
}

ccl_device_inline float inversesqrtf(const float f)
{
  return (f > 0.0f) ? 1.0f / sqrtf(f) : 0.0f;
}

ccl_device float safe_asinf(const float a)
{
  return asinf(clamp(a, -1.0f, 1.0f));
}

ccl_device float safe_acosf(const float a)
{
  return acosf(clamp(a, -1.0f, 1.0f));
}

ccl_device float compatible_powf(const float x, const float y)
{
#ifdef __KERNEL_COMPUTE__
  if (y == 0.0f) /* x^0 -> 1, including 0^0 */
    return 1.0f;

  /* GPU pow doesn't accept negative x, do manual checks here */
  if (x < 0.0f) {
    if (fmodf(-y, 2.0f) == 0.0f)
      return powf(-x, y);
    else
      return -powf(-x, y);
  }
  else if (x == 0.0f)
    return 0.0f;
#endif
  return powf(x, y);
}

ccl_device float safe_powf(const float a, const float b)
{
  if (UNLIKELY(a < 0.0f && b != float_to_int(b)))
    return 0.0f;

  return compatible_powf(a, b);
}

ccl_device float safe_divide(const float a, const float b)
{
  return (b != 0.0f) ? a / b : 0.0f;
}

ccl_device float safe_logf(const float a, const float b)
{
  if (UNLIKELY(a <= 0.0f || b <= 0.0f))
    return 0.0f;

  return safe_divide(logf(a), logf(b));
}

ccl_device float safe_modulo(const float a, const float b)
{
  return (b != 0.0f) ? fmodf(a, b) : 0.0f;
}

ccl_device_inline float sqr(const float a)
{
  return a * a;
}

ccl_device_inline float pow20(const float a)
{
  return sqr(sqr(sqr(sqr(a)) * a));
}

ccl_device_inline float pow22(float a)
{
  return sqr(a * sqr(sqr(sqr(a)) * a));
}

ccl_device_inline float beta(float x, float y)
{
#ifndef __KERNEL_OPENCL__
  return expf(lgammaf(x) + lgammaf(y) - lgammaf(x + y));
#else
  return expf(lgamma(x) + lgamma(y) - lgamma(x + y));
#endif
}

ccl_device_inline float xor_signmask(const float x, const int y)
{
  return __int_as_float(__float_as_int(x) ^ y);
}

ccl_device float bits_to_01(const uint bits)
{
  return bits * (1.0f / (float)0xFFFFFFFF);
}

ccl_device_inline uint count_leading_zeros(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return __clz(x);
#elif defined(__KERNEL_OPENCL__)
  return clz(x);
#else
  assert(x != 0);
#  ifdef _MSC_VER
  unsigned long leading_zero = 0;
  _BitScanReverse(&leading_zero, x);
  return (31 - leading_zero);
#  else
  return __builtin_clz(x);
#  endif
#endif
}

ccl_device_inline uint count_trailing_zeros(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return (__ffs(x) - 1);
#elif defined(__KERNEL_OPENCL__)
  return (31 - count_leading_zeros(x & -x));
#else
  assert(x != 0);
#  ifdef _MSC_VER
  unsigned long ctz = 0;
  _BitScanForward(&ctz, x);
  return ctz;
#  else
  return __builtin_ctz(x);
#  endif
#endif
}

ccl_device_inline uint find_first_set(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return __ffs(x);
#elif defined(__KERNEL_OPENCL__)
  return (x != 0) ? (32 - count_leading_zeros(x & (-x))) : 0;
#else
#  ifdef _MSC_VER
  return (x != 0) ? (32 - count_leading_zeros(x & (-x))) : 0;
#  else
  return __builtin_ffs(x);
#  endif
#endif
}

/* projections */
ccl_device_inline float2 map_to_tube(const float3 co)
{
  float len, u, v;
  len = sqrtf(co.x * co.x + co.y * co.y);
  if (len > 0.0f) {
    u = (1.0f - (atan2f(co.x / len, co.y / len) / M_PI_F)) * 0.5f;
    v = (co.z + 1.0f) * 0.5f;
  }
  else {
    u = v = 0.0f;
  }
  return make_float2(u, v);
}

ccl_device_inline float2 map_to_sphere(const float3 co)
{
  float l = len(co);
  float u, v;
  if (l > 0.0f) {
    if (UNLIKELY(co.x == 0.0f && co.y == 0.0f)) {
      u = 0.0f; /* othwise domain error */
    }
    else {
      u = (1.0f - atan2f(co.x, co.y) / M_PI_F) / 2.0f;
    }
    v = 1.0f - safe_acosf(co.z / l) / M_PI_F;
  }
  else {
    u = v = 0.0f;
  }
  return make_float2(u, v);
}

/* Compares two floats.
 * Returns true if their absolute difference is smaller than abs_diff (for numbers near zero)
 * or their relative difference is less than ulp_diff ULPs.
 * Based on
 * https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
 */

ccl_device_inline float compare_floats(const float a,
                                       const float b,
                                       const float abs_diff,
                                       const int ulp_diff)
{
  if (fabsf(a - b) < abs_diff) {
    return true;
  }

  if ((a < 0.0f) != (b < 0.0f)) {
    return false;
  }

  return (abs(__float_as_int(a) - __float_as_int(b)) < ulp_diff);
}

ccl_device_inline float clamp_to_normal(const float a)
{
  return min(max(a, 0.0f), 1.0f);
}

ccl_device_inline float4 interp_f4f4(const float4 a, const float4 b, const float t)
{
  const float s = 1.0f - t;

  return s * a + t * b;
}

CCL_NAMESPACE_END

#endif

#line 4 ".kernel_util/COM_kernel_geom.h"

/* All this methods has been taken from blendlib math_geom.c file.
 * They are adapted for vectors and kernel compatibility */
CCL_NAMESPACE_BEGIN

#define KEY_LINEAR 0
#define KEY_CARDINAL 1
#define KEY_BSPLINE 2
#define KEY_CATMULL_ROM 3

ccl_device_inline float2 closest_to_line_v2(const float2 p, const float2 l1, const float2 l2)
{
  float2 u = l2 - l1;
  float2 h = p - l1;
  float lambda = dot(u, h) / dot(u, u);
  return l1 + u * lambda;
}

ccl_device_inline void key_curve_position_weights(const float t, float data[4], const int type)
{
  float t2, t3, fc;

  if (type == KEY_LINEAR) {
    data[0] = 0.0f;
    data[1] = -t + 1.0f;
    data[2] = t;
    data[3] = 0.0f;
  }
  else if (type == KEY_CARDINAL) {
    t2 = t * t;
    t3 = t2 * t;
    fc = 0.71f;

    data[0] = -fc * t3 + 2.0f * fc * t2 - fc * t;
    data[1] = (2.0f - fc) * t3 + (fc - 3.0f) * t2 + 1.0f;
    data[2] = (fc - 2.0f) * t3 + (3.0f - 2.0f * fc) * t2 + fc * t;
    data[3] = fc * t3 - fc * t2;
  }
  else if (type == KEY_BSPLINE) {
    t2 = t * t;
    t3 = t2 * t;

    data[0] = -0.16666666f * t3 + 0.5f * t2 - 0.5f * t + 0.16666666f;
    data[1] = 0.5f * t3 - t2 + 0.66666666f;
    data[2] = -0.5f * t3 + 0.5f * t2 + 0.5f * t + 0.16666666f;
    data[3] = 0.16666666f * t3;
  }
  else if (type == KEY_CATMULL_ROM) {
    t2 = t * t;
    t3 = t2 * t;
    fc = 0.5f;

    data[0] = -fc * t3 + 2.0f * fc * t2 - fc * t;
    data[1] = (2.0f - fc) * t3 + (fc - 3.0f) * t2 + 1.0f;
    data[2] = (fc - 2.0f) * t3 + (3.0f - 2.0f * fc) * t2 + fc * t;
    data[3] = fc * t3 - fc * t2;
  }
}

CCL_NAMESPACE_END

#endif

#line 5 ".kernel_util/COM_kernel_algo.h"
#line 1 ".kernel_util/COM_kernel_math.h"
#ifndef __COM_KERNEL_MATH_H__
#define __COM_KERNEL_MATH_H__

/* Math
 *
 * Basic math functions on scalar and vector types. This header is used by
 * both the kernel code when compiled as C++, and other C++ non-kernel code. */

#ifndef __KERNEL_COMPUTE__
#  include <cmath>
#endif

#ifndef __KERNEL_OPENCL__
#  include <float.h>
#  include <math.h>
#  include <stdio.h>
#endif /* __KERNEL_OPENCL__ */

#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 19 ".kernel_util/COM_kernel_math.h"

CCL_NAMESPACE_BEGIN

/* Float Pi variations */

/* Division */
#ifndef M_PI_F
#  define M_PI_F (3.1415926535897932f) /* pi */
#endif
#ifndef M_PI_2_F
#  define M_PI_2_F (1.5707963267948966f) /* pi/2 */
#endif
#ifndef M_PI_4_F
#  define M_PI_4_F (0.7853981633974830f) /* pi/4 */
#endif
#ifndef M_1_PI_F
#  define M_1_PI_F (0.3183098861837067f) /* 1/pi */
#endif
#ifndef M_2_PI_F
#  define M_2_PI_F (0.6366197723675813f) /* 2/pi */
#endif
#ifndef M_1_2PI_F
#  define M_1_2PI_F (0.1591549430918953f) /* 1/(2*pi) */
#endif
#ifndef M_SQRT_PI_8_F
#  define M_SQRT_PI_8_F (0.6266570686577501f) /* sqrt(pi/8) */
#endif
#ifndef M_LN_2PI_F
#  define M_LN_2PI_F (1.8378770664093454f) /* ln(2*pi) */
#endif

/* Multiplication */
#ifndef M_2PI_F
#  define M_2PI_F (6.2831853071795864f) /* 2*pi */
#endif
#ifndef M_4PI_F
#  define M_4PI_F (12.566370614359172f) /* 4*pi */
#endif

/* Float sqrt variations */
#ifndef M_SQRT2_F
#  define M_SQRT2_F (1.4142135623730950f) /* sqrt(2) */
#endif
#ifndef M_LN2_F
#  define M_LN2_F (0.6931471805599453f) /* ln(2) */
#endif
#ifndef M_LN10_F
#  define M_LN10_F (2.3025850929940457f) /* ln(10) */
#endif

#ifndef RAD2DEGF
#  define RAD2DEGF(_rad) ((_rad) * (float)(180.0f / M_PI_F))
#endif
#ifndef DEG2RADF
#  define DEG2RADF(_deg) ((_deg) * (float)(M_PI_F / 180.0f))
#endif

/* Scalar */

#ifdef _WIN32
#  ifndef __KERNEL_OPENCL__
ccl_device_inline float fmaxf(float a, float b)
{
  return (a > b) ? a : b;
}

ccl_device_inline float fminf(float a, float b)
{
  return (a < b) ? a : b;
}
#  endif /* !__KERNEL_OPENCL__ */
#endif   /* _WIN32 */

#ifndef __KERNEL_COMPUTE__
using std::isfinite;
using std::isnan;
using std::sqrt;

ccl_device_inline int abs(const int x)
{
  return (x > 0) ? x : -x;
}

ccl_device_inline int max(const int a, const int b)
{
  return (a > b) ? a : b;
}

ccl_device_inline int min(const int a, const int b)
{
  return (a < b) ? a : b;
}

ccl_device_inline float max(const float a, const float b)
{
  return (a > b) ? a : b;
}

ccl_device_inline float min(const float a, const float b)
{
  return (a < b) ? a : b;
}
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline float fminf3(const float a, const float b, const float c)
{
  return fminf(fminf(a, b), c);
}

ccl_device_inline float fmaxf3(const float a, const float b, const float c)
{
  return fmaxf(fmaxf(a, b), c);
}

ccl_device_inline float fminf4(const float a, const float b, const float c, const float d)
{
  return fminf(fminf(a, b), fminf(c, d));
}

ccl_device_inline float fmaxf4(const float a, const float b, const float c, const float d)
{
  return fmaxf(fmaxf(a, b), fmaxf(c, d));
}

#ifndef __KERNEL_OPENCL__
/* Int/Float conversion */

ccl_device_inline int as_int(uint i)
{
  union {
    uint ui;
    int i;
  } u;
  u.ui = i;
  return u.i;
}

ccl_device_inline uint as_uint(int i)
{
  union {
    uint ui;
    int i;
  } u;
  u.i = i;
  return u.ui;
}

ccl_device_inline uint as_uint(float f)
{
  union {
    uint i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline int __float_as_int(float f)
{
  union {
    int i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline float __int_as_float(int i)
{
  union {
    int i;
    float f;
  } u;
  u.i = i;
  return u.f;
}

ccl_device_inline uint __float_as_uint(float f)
{
  union {
    uint i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline float __uint_as_float(uint i)
{
  union {
    uint i;
    float f;
  } u;
  u.i = i;
  return u.f;
}

ccl_device_inline int4 __float4_as_int4(float4 f)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(f.m128));
#  else
  return make_int4(
      __float_as_int(f.x), __float_as_int(f.y), __float_as_int(f.z), __float_as_int(f.w));
#  endif
}

ccl_device_inline float4 __int4_as_float4(int4 i)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_castsi128_ps(i.m128));
#  else
  return make_float4(
      __int_as_float(i.x), __int_as_float(i.y), __int_as_float(i.z), __int_as_float(i.w));
#  endif
}
#endif /* __KERNEL_OPENCL__ */

/* Versions of functions which are safe for fast math. */
ccl_device_inline bool isnan_safe(const float f)
{
  unsigned int x = __float_as_uint(f);
  return (x << 1) > 0xff000000u;
}

ccl_device_inline bool isfinite_safe(const float f)
{
  /* By IEEE 754 rule, 2*Inf equals Inf */
  unsigned int x = __float_as_uint(f);
  return (f == f) && (x == 0 || x == (1u << 31) || (f != 2.0f * f)) && !((x << 1) > 0xff000000u);
}

ccl_device_inline float ensure_finite(const float v)
{
  return isfinite_safe(v) ? v : 0.0f;
}

#ifndef __KERNEL_OPENCL__
ccl_device_inline int clamp(const int a, const int mn, const int mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float clamp(const float a, const float mn, const float mx)
{
  return fminf(fmaxf(a, mn), mx);
}

ccl_device_inline float mix(const float a, const float b, const float t)
{
  return a + t * (b - a);
}

ccl_device_inline float smoothstep(const float edge0, const float edge1, const float x)
{
  float result;
  if (x < edge0)
    result = 0.0f;
  else if (x >= edge1)
    result = 1.0f;
  else {
    float t = (x - edge0) / (edge1 - edge0);
    result = (3.0f - 2.0f * t) * (t * t);
  }
  return result;
}

#endif /* __KERNEL_OPENCL__ */

#ifndef __KERNEL_CUDA__
ccl_device_inline float saturate(const float a)
{
  return clamp(a, 0.0f, 1.0f);
}
#endif /* __KERNEL_CUDA__ */

ccl_device_inline int float_to_int(const float f)
{
  return (int)f;
}

ccl_device_inline int floor_to_int(const float f)
{
  return float_to_int(floorf(f));
}

ccl_device_inline int quick_floor_to_int(const float x)
{
  return float_to_int(x) - ((x < 0) ? 1 : 0);
}

ccl_device_inline float floorfrac(const float x, int *i)
{
  *i = quick_floor_to_int(x);
  return x - *i;
}

ccl_device_inline int ceil_to_int(const float f)
{
  return float_to_int(ceilf(f));
}

ccl_device_inline float fractf(const float x)
{
  return x - floorf(x);
}

/* Adapted from godotengine math_funcs.h. */
ccl_device_inline float wrapf(const float value, const float max, const float min)
{
  float range = max - min;
  return (range != 0.0f) ? value - (range * floorf((value - min) / range)) : min;
}

ccl_device_inline float pingpongf(const float a, const float b)
{
  return (b != 0.0f) ? fabsf(fractf((a - b) / (b * 2.0f)) * b * 2.0f - b) : 0.0f;
}

ccl_device_inline float smoothminf(const float a, const float b, const float k)
{
  if (k != 0.0f) {
    float h = fmaxf(k - fabsf(a - b), 0.0f) / k;
    return fminf(a, b) - h * h * h * k * (1.0f / 6.0f);
  }
  else {
    return fminf(a, b);
  }
}

ccl_device_inline float signf(const float f)
{
  return (f < 0.0f) ? -1.0f : 1.0f;
}

ccl_device_inline float nonzerof(const float f, const float eps)
{
  if (fabsf(f) < eps)
    return signf(f) * eps;
  else
    return f;
}

/* Signum function testing for zero. Matches GLSL and OSL functions. */
ccl_device_inline float compatible_signf(const float f)
{
  if (f == 0.0f) {
    return 0.0f;
  }
  else {
    return signf(f);
  }
}

ccl_device_inline float smoothstepf(const float f)
{
  float ff = f * f;
  return (3.0f * ff - 2.0f * ff * f);
}

ccl_device_inline int mod(const int x, const int m)
{
  return (x % m + m) % m;
}

ccl_device_inline float3 float2_to_float3(const float2 a)
{
  return make_float3(a.x, a.y, 0.0f);
}

ccl_device_inline float3 float4_to_float3(const float4 a)
{
  return make_float3(a.x, a.y, a.z);
}

ccl_device_inline float4 float3_to_float4(const float3 a)
{
  return make_float4(a.x, a.y, a.z, 1.0f);
}

ccl_device_inline float inverse_lerp(const float a, const float b, const float x)
{
  return (x - a) / (b - a);
}

/* Cubic interpolation between b and c, a and d are the previous and next point. */
ccl_device_inline float cubic_interp(
    const float a, const float b, const float c, const float d, const float x)
{
  return 0.5f *
             (((d + 3.0f * (b - c) - a) * x + (2.0f * a - 5.0f * b + 4.0f * c - d)) * x +
              (c - a)) *
             x +
         b;
}

CCL_NAMESPACE_END

#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 418 ".kernel_util/COM_kernel_math.h"

#line 1 ".kernel_util/COM_kernel_math_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT2_H__
#define __COM_KERNEL_MATH_INT2_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline bool operator==(const int2 a, const int2 b);
ccl_device_inline int2 operator+(const int2 &a, const int2 &b);
ccl_device_inline int2 operator+=(int2 &a, const int2 &b);
ccl_device_inline int2 operator-(const int2 &a, const int2 &b);
ccl_device_inline int2 operator*(const int2 &a, const int2 &b);
ccl_device_inline int2 operator/(const int2 &a, const int2 &b);
#endif /* !__KERNEL_OPENCL__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline bool operator==(const int2 a, const int2 b)
{
  return (a.x == b.x && a.y == b.y);
}

ccl_device_inline int2 operator+(const int2 &a, const int2 &b)
{
  return make_int2(a.x + b.x, a.y + b.y);
}

ccl_device_inline int2 operator+=(int2 &a, const int2 &b)
{
  return a = a + b;
}

ccl_device_inline int2 operator-(const int2 &a, const int2 &b)
{
  return make_int2(a.x - b.x, a.y - b.y);
}

ccl_device_inline int2 operator*(const int2 &a, const int2 &b)
{
  return make_int2(a.x * b.x, a.y * b.y);
}

ccl_device_inline int2 operator/(const int2 &a, const int2 &b)
{
  return make_int2(a.x / b.x, a.y / b.y);
}
#endif /* !__KERNEL_OPENCL__ */

CCL_NAMESPACE_END

#endif

#line 420 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT3_H__
#define __COM_KERNEL_MATH_INT3_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline int3 min(int3 a, int3 b);
ccl_device_inline int3 max(int3 a, int3 b);
ccl_device_inline int3 clamp(const int3 &a, int mn, int mx);
ccl_device_inline int3 clamp(const int3 &a, int3 &mn, int mx);
#endif /* !__KERNEL_OPENCL__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline int3 min(int3 a, int3 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int3(_mm_min_epi32(a.m128, b.m128));
#  else
  return make_int3(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));
#  endif
}

ccl_device_inline int3 max(int3 a, int3 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int3(_mm_max_epi32(a.m128, b.m128));
#  else
  return make_int3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));
#  endif
}

ccl_device_inline int3 clamp(const int3 &a, int mn, int mx)
{
#  ifdef __KERNEL_SSE__
  return min(max(a, make_int3_1(mn)), make_int3_1(mx));
#  else
  return make_int3(clamp(a.x, mn, mx), clamp(a.y, mn, mx), clamp(a.z, mn, mx));
#  endif
}

ccl_device_inline int3 clamp(const int3 &a, int3 &mn, int mx)
{
#  ifdef __KERNEL_SSE__
  return min(max(a, mn), make_int3_1(mx));
#  else
  return make_int3(clamp(a.x, mn.x, mx), clamp(a.y, mn.y, mx), clamp(a.z, mn.z, mx));
#  endif
}

ccl_device_inline bool operator==(const int3 &a, const int3 &b)
{
  return a.x == b.x && a.y == b.y && a.z == b.z;
}

ccl_device_inline bool operator!=(const int3 &a, const int3 &b)
{
  return !(a == b);
}

ccl_device_inline bool operator<(const int3 &a, const int3 &b)
{
  return a.x < b.x && a.y < b.y && a.z < b.z;
}

ccl_device_inline int3 operator+(const int3 &a, const int3 &b)
{
#  ifdef __KERNEL_SSE__
  return int3(_mm_add_epi32(a.m128, b.m128));
#  else
  return make_int3(a.x + b.x, a.y + b.y, a.z + b.z);
#  endif
}

ccl_device_inline int3 operator-(const int3 &a, const int3 &b)
{
#  ifdef __KERNEL_SSE__
  return int3(_mm_sub_epi32(a.m128, b.m128));
#  else
  return make_int3(a.x - b.x, a.y - b.y, a.z - b.z);
#  endif
}
#endif /* !__KERNEL_OPENCL__ */

CCL_NAMESPACE_END

#endif /* __COM_kernel_MATH_INT3_H__ */

#line 421 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT4_H__
#define __COM_KERNEL_MATH_INT4_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline int4 operator+(const int4 &a, const int4 &b);
ccl_device_inline int4 operator+=(int4 &a, const int4 &b);
ccl_device_inline int4 operator>>(const int4 &a, int i);
ccl_device_inline int4 operator<<(const int4 &a, int i);
ccl_device_inline int4 operator<(const int4 &a, const int4 &b);
ccl_device_inline int4 operator>=(const int4 &a, const int4 &b);
ccl_device_inline int4 operator&(const int4 &a, const int4 &b);
ccl_device_inline int4 min(int4 a, int4 b);
ccl_device_inline int4 max(int4 a, int4 b);
ccl_device_inline int4 clamp(const int4 &a, const int4 &mn, const int4 &mx);
ccl_device_inline int4 select(const int4 &mask, const int4 &a, const int4 &b);
#endif /* __KERNEL_COMPUTE__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline int4 operator+(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_add_epi32(a.m128, b.m128));
#  else
  return make_int4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
#  endif
}

ccl_device_inline int4 operator+=(int4 &a, const int4 &b)
{
  return a = a + b;
}

ccl_device_inline int4 operator>>(const int4 &a, int i)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_srai_epi32(a.m128, i));
#  else
  return make_int4(a.x >> i, a.y >> i, a.z >> i, a.w >> i);
#  endif
}

ccl_device_inline int4 operator<<(const int4 &a, int i)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_slli_epi32(a.m128, i));
#  else
  return make_int4(a.x << i, a.y << i, a.z << i, a.w << i);
#  endif
}

ccl_device_inline int4 operator<(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_cmplt_epi32(a.m128, b.m128));
#  else
  return make_int4(a.x < b.x, a.y < b.y, a.z < b.z, a.w < b.w);
#  endif
}

ccl_device_inline int4 operator>=(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_xor_si128(_mm_set1_epi32(0xffffffff), _mm_cmplt_epi32(a.m128, b.m128)));
#  else
  return make_int4(a.x >= b.x, a.y >= b.y, a.z >= b.z, a.w >= b.w);
#  endif
}

ccl_device_inline int4 operator&(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_and_si128(a.m128, b.m128));
#  else
  return make_int4(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
#  endif
}

ccl_device_inline int4 min(int4 a, int4 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int4(_mm_min_epi32(a.m128, b.m128));
#  else
  return make_int4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));
#  endif
}

ccl_device_inline int4 max(int4 a, int4 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int4(_mm_max_epi32(a.m128, b.m128));
#  else
  return make_int4(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z), max(a.w, b.w));
#  endif
}

ccl_device_inline int4 clamp(const int4 &a, const int4 &mn, const int4 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline int4 select(const int4 &mask, const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  const __m128 m = _mm_cvtepi32_ps(mask);
  /* TODO(sergey): avoid cvt. */
  return int4(_mm_castps_si128(
      _mm_or_ps(_mm_and_ps(m, _mm_castsi128_ps(a)), _mm_andnot_ps(m, _mm_castsi128_ps(b)))));
#  else
  return make_int4(
      (mask.x) ? a.x : b.x, (mask.y) ? a.y : b.y, (mask.z) ? a.z : b.z, (mask.w) ? a.w : b.w);
#  endif
}

ccl_device_inline int4 load_int4(const int *v)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_loadu_si128((__m128i *)v));
#  else
  return make_int4(v[0], v[1], v[2], v[3]);
#  endif
}
#endif /* __KERNEL_COMPUTE__ */

CCL_NAMESPACE_END

#endif

#line 422 ".kernel_util/COM_kernel_math.h"

#line 1 ".kernel_util/COM_kernel_math_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT2_H__
#define __COM_KERNEL_MATH_FLOAT2_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float2 operator-(const float2 &a);
ccl_device_inline float2 operator*(const float2 &a, const float2 &b);
ccl_device_inline float2 operator*(const float2 &a, float f);
ccl_device_inline float2 operator*(float f, const float2 &a);
ccl_device_inline float2 operator/(float f, const float2 &a);
ccl_device_inline float2 operator/(const float2 &a, float f);
ccl_device_inline float2 operator/(const float2 &a, const float2 &b);
ccl_device_inline float2 operator+(const float2 &a, const float f);
ccl_device_inline float2 operator+(const float2 &a, const float2 &b);
ccl_device_inline float2 operator-(const float2 &a, const float f);
ccl_device_inline float2 operator-(const float2 &a, const float2 &b);
ccl_device_inline float2 operator+=(float2 &a, const float2 &b);
ccl_device_inline float2 operator*=(float2 &a, const float2 &b);
ccl_device_inline float2 operator*=(float2 &a, float f);
ccl_device_inline float2 operator/=(float2 &a, const float2 &b);
ccl_device_inline float2 operator/=(float2 &a, float f);

ccl_device_inline bool operator==(const float2 &a, const float2 &b);
ccl_device_inline bool operator!=(const float2 &a, const float2 &b);

ccl_device_inline float average(const float2 &a);
ccl_device_inline float distance(const float2 &a, const float2 &b);
ccl_device_inline float dot(const float2 &a, const float2 &b);
ccl_device_inline float cross(const float2 &a, const float2 &b);
ccl_device_inline float len(const float2 &a);
ccl_device_inline float2 normalize(const float2 &a);
ccl_device_inline float2 normalize_len(const float2 &a, float *t);
ccl_device_inline float2 safe_normalize(const float2 &a);
ccl_device_inline float2 min(const float2 &a, const float2 &b);
ccl_device_inline float2 max(const float2 &a, const float2 &b);
ccl_device_inline float2 clamp(const float2 &a, const float2 &mn, const float2 &mx);
ccl_device_inline float2 fabs(const float2 &a);
ccl_device_inline float2 as_float2(const float4 &a);
ccl_device_inline float2 interp(const float2 &a, const float2 &b, float t);
ccl_device_inline float2 floor(const float2 &a);
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float2 safe_divide_float2_float(const float2 a, const float b);

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float2 operator-(const float2 &a)
{
  return make_float2(-a.x, -a.y);
}

ccl_device_inline float2 operator*(const float2 &a, const float2 &b)
{
  return make_float2(a.x * b.x, a.y * b.y);
}

ccl_device_inline float2 operator*(const float2 &a, float f)
{
  return make_float2(a.x * f, a.y * f);
}

ccl_device_inline float2 operator*(float f, const float2 &a)
{
  return make_float2(a.x * f, a.y * f);
}

ccl_device_inline float2 operator/(float f, const float2 &a)
{
  return make_float2(f / a.x, f / a.y);
}

ccl_device_inline float2 operator/(const float2 &a, float f)
{
  float invf = 1.0f / f;
  return make_float2(a.x * invf, a.y * invf);
}

ccl_device_inline float2 operator/(const float2 &a, const float2 &b)
{
  return make_float2(a.x / b.x, a.y / b.y);
}

ccl_device_inline float2 operator+(const float2 &a, const float f)
{
  return a + make_float2(f, f);
}

ccl_device_inline float2 operator+(const float2 &a, const float2 &b)
{
  return make_float2(a.x + b.x, a.y + b.y);
}

ccl_device_inline float2 operator-(const float2 &a, const float f)
{
  return a - make_float2(f, f);
}

ccl_device_inline float2 operator-(const float2 &a, const float2 &b)
{
  return make_float2(a.x - b.x, a.y - b.y);
}

ccl_device_inline float2 operator+=(float2 &a, const float2 &b)
{
  return a = a + b;
}

ccl_device_inline float2 operator*=(float2 &a, const float2 &b)
{
  return a = a * b;
}

ccl_device_inline float2 operator*=(float2 &a, float f)
{
  return a = a * f;
}

ccl_device_inline float2 operator/=(float2 &a, const float2 &b)
{
  return a = a / b;
}

ccl_device_inline float2 operator/=(float2 &a, float f)
{
  float invf = 1.0f / f;
  return a = a * invf;
}

ccl_device_inline bool operator==(const float2 &a, const float2 &b)
{
  return (a.x == b.x && a.y == b.y);
}

ccl_device_inline bool operator!=(const float2 &a, const float2 &b)
{
  return !(a == b);
}

ccl_device_inline float average(const float2 &a)
{
  return (a.x + a.y) * (1.0f / 2.0f);
}

ccl_device_inline float distance(const float2 &a, const float2 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float2 &a, const float2 &b)
{
  return a.x * b.x + a.y * b.y;
}

ccl_device_inline float cross(const float2 &a, const float2 &b)
{
  return (a.x * b.y - a.y * b.x);
}

ccl_device_inline float len(const float2 &a)
{
  return sqrtf(dot(a, a));
}

ccl_device_inline float2 normalize(const float2 &a)
{
  return a / len(a);
}

ccl_device_inline float2 normalize_len(const float2 &a, float *t)
{
  *t = len(a);
  return a / (*t);
}

ccl_device_inline float2 safe_normalize(const float2 &a)
{
  float t = len(a);
  return (t != 0.0f) ? a / t : a;
}

ccl_device_inline float2 min(const float2 &a, const float2 &b)
{
  return make_float2(fminf(a.x, b.x), fminf(a.y, b.y));
}

ccl_device_inline float2 max(const float2 &a, const float2 &b)
{
  return make_float2(fmaxf(a.x, b.x), fmaxf(a.y, b.y));
}

ccl_device_inline float2 clamp(const float2 &a, const float2 &mn, const float2 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float2 fabs(const float2 &a)
{
  return make_float2(fabsf(a.x), fabsf(a.y));
}

ccl_device_inline float2 as_float2(const float4 &a)
{
  return make_float2(a.x, a.y);
}

ccl_device_inline float2 interp(const float2 &a, const float2 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float2 mix(const float2 &a, const float2 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float2 floor(const float2 &a)
{
  return make_float2(floorf(a.x), floorf(a.y));
}

#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float2 safe_divide_float2_float(const float2 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float2(0.0f, 0.0f);
}

CCL_NAMESPACE_END

#endif

#line 424 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT3_H__
#define __COM_KERNEL_MATH_FLOAT3_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float3 operator-(const float3 &a);
ccl_device_inline float3 operator*(const float3 &a, const float3 &b);
ccl_device_inline float3 operator*(const float3 &a, const float f);
ccl_device_inline float3 operator*(const float f, const float3 &a);
ccl_device_inline float3 operator/(const float f, const float3 &a);
ccl_device_inline float3 operator/(const float3 &a, const float f);
ccl_device_inline float3 operator/(const float3 &a, const float3 &b);
ccl_device_inline float3 operator+(const float3 &a, const float f);
ccl_device_inline float3 operator+(const float3 &a, const float3 &b);
ccl_device_inline float3 operator-(const float3 &a, const float f);
ccl_device_inline float3 operator-(const float3 &a, const float3 &b);
ccl_device_inline float3 operator+=(float3 &a, const float3 &b);
ccl_device_inline float3 operator-=(float3 &a, const float3 &b);
ccl_device_inline float3 operator*=(float3 &a, const float3 &b);
ccl_device_inline float3 operator*=(float3 &a, float f);
ccl_device_inline float3 operator/=(float3 &a, const float3 &b);
ccl_device_inline float3 operator/=(float3 &a, float f);

ccl_device_inline bool operator==(const float3 &a, const float3 &b);
ccl_device_inline bool operator!=(const float3 &a, const float3 &b);

ccl_device_inline float distance(const float3 &a, const float3 &b);
ccl_device_inline float dot(const float3 &a, const float3 &b);
ccl_device_inline float dot_xy(const float3 &a, const float3 &b);
ccl_device_inline float3 cross(const float3 &a, const float3 &b);
ccl_device_inline float3 normalize(const float3 &a);
ccl_device_inline float3 min(const float3 &a, const float3 &b);
ccl_device_inline float3 max(const float3 &a, const float3 &b);
ccl_device_inline float3 clamp(const float3 &a, const float3 &mn, const float3 &mx);
ccl_device_inline float3 fabs(const float3 &a);
ccl_device_inline float3 mix(const float3 &a, const float3 &b, float t);
ccl_device_inline float3 rcp(const float3 &a);
ccl_device_inline float3 sqrt(const float3 &a);
ccl_device_inline float3 floor(const float3 &a);
ccl_device_inline float3 ceil(const float3 &a);
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float min3(float3 a);
ccl_device_inline float max3(float3 a);
ccl_device_inline float len(const float3 a);
ccl_device_inline float len_squared(const float3 a);

ccl_device_inline float3 reflect(const float3 incident, const float3 normal);
ccl_device_inline float3 project(const float3 v, const float3 v_proj);

ccl_device_inline float3 saturate3(float3 a);
ccl_device_inline float3 safe_normalize(const float3 a);
ccl_device_inline float3 normalize_len(const float3 a, float *t);
ccl_device_inline float3 safe_normalize_len(const float3 a, float *t);
ccl_device_inline float3 safe_divide_float3_float3(const float3 a, const float3 b);
ccl_device_inline float3 safe_divide_float3_float(const float3 a, const float b);
ccl_device_inline float3 interp(float3 a, float3 b, float t);
ccl_device_inline float3 sqr3(float3 a);
ccl_device_inline float reduce_add(const float3 a);
ccl_device_inline float average(const float3 a);
ccl_device_inline bool isequal_float3(const float3 a, const float3 b);

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float3 operator-(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_xor_ps(a.m128, _mm_castsi128_ps(_mm_set1_epi32(0x80000000))));
#  else
  return make_float3(-a.x, -a.y, -a.z);
#  endif
}

ccl_device_inline float3 operator*(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_mul_ps(a.m128, b.m128));
#  else
  return make_float3(a.x * b.x, a.y * b.y, a.z * b.z);
#  endif
}

ccl_device_inline float3 operator*(const float3 &a, const float f)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_mul_ps(a.m128, _mm_set1_ps(f)));
#  else
  return make_float3(a.x * f, a.y * f, a.z * f);
#  endif
}

ccl_device_inline float3 operator*(const float f, const float3 &a)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_mul_ps(_mm_set1_ps(f), a.m128));
#  else
  return make_float3(a.x * f, a.y * f, a.z * f);
#  endif
}

ccl_device_inline float3 operator/(const float f, const float3 &a)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_div_ps(_mm_set1_ps(f), a.m128));
#  else
  return make_float3(f / a.x, f / a.y, f / a.z);
#  endif
}

ccl_device_inline float3 operator/(const float3 &a, const float f)
{
  float invf = 1.0f / f;
  return a * invf;
}

ccl_device_inline float3 operator/(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_div_ps(a.m128, b.m128));
#  else
  return make_float3(a.x / b.x, a.y / b.y, a.z / b.z);
#  endif
}

ccl_device_inline float3 operator+(const float3 &a, const float f)
{
  return a + make_float3(f, f, f);
}

ccl_device_inline float3 operator+(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_add_ps(a.m128, b.m128));
#  else
  return make_float3(a.x + b.x, a.y + b.y, a.z + b.z);
#  endif
}

ccl_device_inline float3 operator-(const float3 &a, const float f)
{
  return a - make_float3(f, f, f);
}

ccl_device_inline float3 operator-(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_sub_ps(a.m128, b.m128));
#  else
  return make_float3(a.x - b.x, a.y - b.y, a.z - b.z);
#  endif
}

ccl_device_inline float3 operator+=(float3 &a, const float3 &b)
{
  return a = a + b;
}

ccl_device_inline float3 operator-=(float3 &a, const float3 &b)
{
  return a = a - b;
}

ccl_device_inline float3 operator*=(float3 &a, const float3 &b)
{
  return a = a * b;
}

ccl_device_inline float3 operator*=(float3 &a, float f)
{
  return a = a * f;
}

ccl_device_inline float3 operator/=(float3 &a, const float3 &b)
{
  return a = a / b;
}

ccl_device_inline float3 operator/=(float3 &a, float f)
{
  float invf = 1.0f / f;
  return a = a * invf;
}

ccl_device_inline bool operator==(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return (_mm_movemask_ps(_mm_cmpeq_ps(a.m128, b.m128)) & 7) == 7;
#  else
  return (a.x == b.x && a.y == b.y && a.z == b.z);
#  endif
}

ccl_device_inline bool operator!=(const float3 &a, const float3 &b)
{
  return !(a == b);
}

ccl_device_inline float distance(const float3 &a, const float3 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_dp_ps(a, b, 0x7F));
#  else
  return a.x * b.x + a.y * b.y + a.z * b.z;
#  endif
}

ccl_device_inline float dot_xy(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_hadd_ps(_mm_mul_ps(a, b), b));
#  else
  return a.x * b.x + a.y * b.y;
#  endif
}

ccl_device_inline float3 cross(const float3 &a, const float3 &b)
{
  float3 r = make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
  return r;
}

ccl_device_inline float3 normalize(const float3 &a)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  __m128 norm = _mm_sqrt_ps(_mm_dp_ps(a.m128, a.m128, 0x7F));
  return float3(_mm_div_ps(a.m128, norm));
#  else
  return a / len(a);
#  endif
}

ccl_device_inline float3 min(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_min_ps(a.m128, b.m128));
#  else
  return make_float3(fminf(a.x, b.x), fminf(a.y, b.y), fminf(a.z, b.z));
#  endif
}

ccl_device_inline float3 max(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_max_ps(a.m128, b.m128));
#  else
  return make_float3(fmaxf(a.x, b.x), fmaxf(a.y, b.y), fmaxf(a.z, b.z));
#  endif
}

ccl_device_inline float3 clamp(const float3 &a, const float3 &mn, const float3 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float3 fabs(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  __m128 mask = _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff));
  return float3(_mm_and_ps(a.m128, mask));
#  else
  return make_float3(fabsf(a.x), fabsf(a.y), fabsf(a.z));
#  endif
}

ccl_device_inline float3 sqrt(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_sqrt_ps(a));
#  else
  return make_float3(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z));
#  endif
}

ccl_device_inline float3 floor(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_floor_ps(a));
#  else
  return make_float3(floorf(a.x), floorf(a.y), floorf(a.z));
#  endif
}

ccl_device_inline float3 ceil(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_ceil_ps(a));
#  else
  return make_float3(ceilf(a.x), ceilf(a.y), ceilf(a.z));
#  endif
}

ccl_device_inline float3 mix(const float3 &a, const float3 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float3 rcp(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  /* Don't use _mm_rcp_ps due to poor precision. */
  return float3(_mm_div_ps(_mm_set_ps1(1.0f), a.m128));
#  else
  return make_float3(1.0f / a.x, 1.0f / a.y, 1.0f / a.z);
#  endif
}
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float min3(const float3 a)
{
  return min(min(a.x, a.y), a.z);
}

ccl_device_inline float max3(const float3 a)
{
  return max(max(a.x, a.y), a.z);
}

ccl_device_inline float len(const float3 a)
{
#if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_sqrt_ss(_mm_dp_ps(a.m128, a.m128, 0x7F)));
#else
  return sqrtf(dot(a, a));
#endif
}

ccl_device_inline float len_squared(const float3 a)
{
  return dot(a, a);
}

ccl_device_inline float3 reflect(const float3 incident, const float3 normal)
{
  float3 unit_normal = normalize(normal);
  return incident - 2.0f * unit_normal * dot(incident, unit_normal);
}

ccl_device_inline float3 project(const float3 v, const float3 v_proj)
{
  float len_squared = dot(v_proj, v_proj);
  return (len_squared != 0.0f) ? (dot(v, v_proj) / len_squared) * v_proj :
                                 make_float3(0.0f, 0.0f, 0.0f);
}

ccl_device_inline float3 saturate3(const float3 a)
{
  return make_float3(saturate(a.x), saturate(a.y), saturate(a.z));
}

ccl_device_inline float3 normalize_len(const float3 a, float *t)
{
  *t = len(a);
  float x = 1.0f / *t;
  return a * x;
}

ccl_device_inline float3 safe_normalize(const float3 a)
{
  float t = len(a);
  return (t != 0.0f) ? a * (1.0f / t) : a;
}

ccl_device_inline float3 safe_normalize_len(const float3 a, float *t)
{
  *t = len(a);
  return (*t != 0.0f) ? a / (*t) : a;
}

ccl_device_inline float3 safe_divide_float3_float3(const float3 a, const float3 b)
{
  return make_float3((b.x != 0.0f) ? a.x / b.x : 0.0f,
                     (b.y != 0.0f) ? a.y / b.y : 0.0f,
                     (b.z != 0.0f) ? a.z / b.z : 0.0f);
}

ccl_device_inline float3 safe_divide_float3_float(const float3 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float3(0.0f, 0.0f, 0.0f);
}

ccl_device_inline float3 interp(const float3 a, const float3 b, const float t)
{
  return a + t * (b - a);
}

ccl_device_inline float3 sqr3(const float3 a)
{
  return a * a;
}

ccl_device_inline float reduce_add(const float3 a)
{
  return (a.x + a.y + a.z);
}

ccl_device_inline float average(const float3 a)
{
  return reduce_add(a) * (1.0f / 3.0f);
}

ccl_device_inline bool isequal_float3(const float3 a, const float3 b)
{
#ifdef __KERNEL_OPENCL__
  return all(a == b);
#else
  return a == b;
#endif
}

ccl_device_inline float3 pow3(const float3 v, const float e)
{
  return make_float3(powf(v.x, e), powf(v.y, e), powf(v.z, e));
}

ccl_device_inline float3 exp3(const float3 v)
{
  return make_float3(expf(v.x), expf(v.y), expf(v.z));
}

ccl_device_inline float3 log3(const float3 v)
{
  return make_float3(logf(v.x), logf(v.y), logf(v.z));
}

ccl_device_inline int3 quick_floor_to_int3(const float3 a)
{
#ifdef __KERNEL_SSE__
  int3 b = int3(_mm_cvttps_epi32(a.m128));
  int3 isneg = int3(_mm_castps_si128(_mm_cmplt_ps(a.m128, _mm_set_ps1(0.0f))));
  /* Unsaturated add 0xffffffff is the same as subtract -1. */
  return b + isneg;
#else
  return make_int3(quick_floor_to_int(a.x), quick_floor_to_int(a.y), quick_floor_to_int(a.z));
#endif
}

ccl_device_inline bool isfinite3_safe(const float3 v)
{
  return isfinite_safe(v.x) && isfinite_safe(v.y) && isfinite_safe(v.z);
}

ccl_device_inline float3 ensure_finite3(float3 v)
{
  if (!isfinite_safe(v.x))
    v.x = 0.0f;
  if (!isfinite_safe(v.y))
    v.y = 0.0f;
  if (!isfinite_safe(v.z))
    v.z = 0.0f;
  return v;
}

CCL_NAMESPACE_END

#endif

#line 425 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT4_H__
#define __COM_KERNEL_MATH_FLOAT4_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float4 operator-(const float4 &a);
ccl_device_inline float4 operator*(const float4 &a, const float4 &b);
ccl_device_inline float4 operator*(const float4 &a, const float f);
ccl_device_inline float4 operator*(const float f, const float4 &a);
ccl_device_inline float4 operator/(const float4 &a, float f);
ccl_device_inline float4 operator/(const float f, const float4 &a);
ccl_device_inline float4 operator/(const float4 &a, const float4 &b);
ccl_device_inline float4 operator+(const float4 &a, const float f);
ccl_device_inline float4 operator+(const float f, const float4 &a);
ccl_device_inline float4 operator+(const float4 &a, const float4 &b);
ccl_device_inline float4 operator-(const float4 &a, const float f);
ccl_device_inline float4 operator-(const float f, const float4 &a);
ccl_device_inline float4 operator-(const float4 &a, const float4 &b);
ccl_device_inline float4 operator+=(float4 &a, const float4 &b);
ccl_device_inline float4 operator*=(float4 &a, const float4 &b);
ccl_device_inline float4 operator*=(float4 &a, const float f);
ccl_device_inline float4 operator/=(float4 &a, const float f);

ccl_device_inline int4 operator<(const float4 &a, const float4 &b);
ccl_device_inline int4 operator>(const float4 &a, const float4 &b);
ccl_device_inline int4 operator>=(const float4 &a, const float4 &b);
ccl_device_inline int4 operator<=(const float4 &a, const float4 &b);
ccl_device_inline int4 operator==(const float4 &a, const float4 &b);
ccl_device_inline int4 operator!=(const float4 &a, const float4 &b);

ccl_device_inline float distance(const float4 &a, const float4 &b);
ccl_device_inline float dot(const float4 &a, const float4 &b);
ccl_device_inline float len_squared(const float4 &a);
ccl_device_inline float4 rcp(const float4 &a);
ccl_device_inline float4 sqrt(const float4 &a);
ccl_device_inline float4 sqr(const float4 &a);
ccl_device_inline float4 cross(const float4 &a, const float4 &b);
ccl_device_inline float average(const float4 &a);
ccl_device_inline float len(const float4 &a);
ccl_device_inline float4 normalize(const float4 &a);
ccl_device_inline float4 safe_normalize(const float4 &a);
ccl_device_inline float4 min(const float4 &a, const float4 &b);
ccl_device_inline float4 min(const float4 &a, const float b);
ccl_device_inline float4 max(const float4 &a, const float4 &b);
ccl_device_inline float4 max(const float4 &a, const float b);
ccl_device_inline float4 clamp(const float4 &a, const float4 &mn, const float4 &mx);
ccl_device_inline float4 clamp(const float4 &a, const float mn, const float mx);
ccl_device_inline float4 fabs(const float4 &a);
ccl_device_inline float4 floor(const float4 &a);
ccl_device_inline float4 mix(const float4 &a, const float4 &b, const float t);
#endif /* !__KERNEL_OPENCL__*/

ccl_device_inline float4 safe_divide_float4_float(const float4 a, const float b);
ccl_device_inline float4 clamp_to_normal_f4(const float4 a);

#ifdef __KERNEL_SSE__
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &b);
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &a, const float4 &b);

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &b);

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &a, const float4 &b);
template<> __forceinline const float4 shuffle<2, 3, 2, 3>(const float4 &a, const float4 &b);

#  ifdef __KERNEL_SSE3__
template<> __forceinline const float4 shuffle<0, 0, 2, 2>(const float4 &b);
template<> __forceinline const float4 shuffle<1, 1, 3, 3>(const float4 &b);
#  endif
#endif /* __KERNEL_SSE__ */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline float4 select(const float4 &b_false, const float4 &a_true, const int4 &mask);
ccl_device_inline float4 reduce_min(const float4 &a);
ccl_device_inline float4 reduce_max(const float4 &a);
ccl_device_inline float4 reduce_add(const float4 &a);
#endif /* !__KERNEL_COMPUTE__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float4 operator-(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  __m128 mask = _mm_castsi128_ps(_mm_set1_epi32(0x80000000));
  return float4(_mm_xor_ps(a.m128, mask));
#  else
  return make_float4(-a.x, -a.y, -a.z, -a.w);
#  endif
}

ccl_device_inline float4 operator*(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_mul_ps(a.m128, b.m128));
#  else
  return make_float4(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
#  endif
}

ccl_device_inline float4 operator*(const float4 &a, const float f)
{
#  if defined(__KERNEL_SSE__)
  return a * make_float4_1(f);
#  else
  return make_float4(a.x * f, a.y * f, a.z * f, a.w * f);
#  endif
}

ccl_device_inline float4 operator*(const float f, const float4 &a)
{
  return a * f;
}

ccl_device_inline float4 operator/(const float4 &a, const float f)
{
  return a * (1.0f / f);
}

ccl_device_inline float4 operator/(const float f, const float4 &a)
{
  return make_float4_1(f) / a;
}
ccl_device_inline float4 operator/(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_div_ps(a.m128, b.m128));
#  else
  return make_float4(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
#  endif
}

ccl_device_inline float4 operator+(const float4 &a, const float f)
{
  return a + make_float4(f, f, f, f);
}

ccl_device_inline float4 operator+(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_add_ps(a.m128, b.m128));
#  else
  return make_float4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
#  endif
}

ccl_device_inline float4 operator+(const float f, const float4 &a)
{
  return make_float4(f, f, f, f) + a;
}

ccl_device_inline float4 operator-(const float4 &a, const float f)
{
  return a - make_float4(f, f, f, f);
}

ccl_device_inline float4 operator-(const float f, const float4 &a)
{
  return make_float4(f, f, f, f) - a;
}

ccl_device_inline float4 operator-(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_sub_ps(a.m128, b.m128));
#  else
  return make_float4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
#  endif
}

ccl_device_inline float4 operator+=(float4 &a, const float4 &b)
{
  return a = a + b;
}

ccl_device_inline float4 operator-=(float4 &a, const float4 &b)
{
  return a = a - b;
}

ccl_device_inline float4 operator*=(float4 &a, const float4 &b)
{
  return a = a * b;
}

ccl_device_inline float4 operator*=(float4 &a, const float f)
{
  return a = a * f;
}

ccl_device_inline float4 operator/=(float4 &a, const float f)
{
  return a = a / f;
}

ccl_device_inline int4 operator<(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmplt_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x < b.x, a.y < b.y, a.z < b.z, a.w < b.w);
#  endif
}

ccl_device_inline int4 operator>(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpgt_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x > b.x, a.y > b.y, a.z > b.z, a.w > b.w);
#  endif
}

ccl_device_inline int4 operator>=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpge_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x >= b.x, a.y >= b.y, a.z >= b.z, a.w >= b.w);
#  endif
}

ccl_device_inline int4 operator<=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmple_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x <= b.x, a.y <= b.y, a.z <= b.z, a.w <= b.w);
#  endif
}

ccl_device_inline int4 operator==(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpeq_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w);
#  endif
}

ccl_device_inline int4 operator!=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpneq_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x != b.x, a.y != b.y, a.z != b.z, a.w != b.w);
#  endif
}

ccl_device_inline float distance(const float4 &a, const float4 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float4 &a, const float4 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_dp_ps(a, b, 0xFF));
#  else
  return (a.x * b.x + a.y * b.y) + (a.z * b.z + a.w * b.w);
#  endif
}

ccl_device_inline float len_squared(const float4 &a)
{
  return dot(a, a);
}

ccl_device_inline float4 rcp(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  /* Don't use _mm_rcp_ps due to poor precision. */
  return float4(_mm_div_ps(_mm_set_ps1(1.0f), a.m128));
#  else
  return make_float4(1.0f / a.x, 1.0f / a.y, 1.0f / a.z, 1.0f / a.w);
#  endif
}

ccl_device_inline float4 sqrt(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_sqrt_ps(a.m128));
#  else
  return make_float4(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z), sqrtf(a.w));
#  endif
}

ccl_device_inline float4 sqr(const float4 &a)
{
  return a * a;
}

ccl_device_inline float4 cross(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return (shuffle<1, 2, 0, 0>(a) * shuffle<2, 0, 1, 0>(b)) -
         (shuffle<2, 0, 1, 0>(a) * shuffle<1, 2, 0, 0>(b));
#  else
  return make_float4(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x, 0.0f);
#  endif
}

ccl_device_inline float4 reduce_add(const float4 &a)
{
#  ifdef __KERNEL_SSE__
#    ifdef __KERNEL_SSE3__
  float4 h(_mm_hadd_ps(a.m128, a.m128));
  return float4(_mm_hadd_ps(h.m128, h.m128));
#    else
  float4 h(shuffle<1, 0, 3, 2>(a) + a);
  return shuffle<2, 3, 0, 1>(h) + h;
#    endif
#  else
  float sum = (a.x + a.y) + (a.z + a.w);
  return make_float4(sum, sum, sum, sum);
#  endif
}

ccl_device_inline float average(const float4 &a)
{
  return reduce_add(a).x * 0.25f;
}

ccl_device_inline float len(const float4 &a)
{
  return sqrtf(dot(a, a));
}

ccl_device_inline float4 normalize(const float4 &a)
{
  return a / len(a);
}

ccl_device_inline float4 safe_normalize(const float4 &a)
{
  float t = len(a);
  return (t != 0.0f) ? a / t : a;
}

ccl_device_inline float4 min(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_min_ps(a.m128, b.m128));
#  else
  return make_float4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));
#  endif
}

ccl_device_inline float4 min(const float4 &a, const float b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_min_ps(a.m128, _mm_set1_ps(b)));
#  else
  return make_float4(fminf(a.x, b), fminf(a.y, b), fminf(a.z, b), fminf(a.w, b));
#  endif
}

ccl_device_inline float4 max(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_max_ps(a.m128, b.m128));
#  else
  return make_float4(fmaxf(a.x, b.x), fmaxf(a.y, b.y), fmaxf(a.z, b.z), fmaxf(a.w, b.w));
#  endif
}

ccl_device_inline float4 max(const float4 &a, const float b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_max_ps(a.m128, _mm_set1_ps(b)));
#  else
  return make_float4(fminf(a.x, b), fminf(a.y, b), fminf(a.z, b), fminf(a.w, b));
#  endif
}

ccl_device_inline float4 clamp(const float4 &a, const float4 &mn, const float4 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float4 clamp(const float4 &a, const float mn, const float mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float4 fabs(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_and_ps(a.m128, _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff))));
#  else
  return make_float4(fabsf(a.x), fabsf(a.y), fabsf(a.z), fabsf(a.w));
#  endif
}

ccl_device_inline float4 floor(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_floor_ps(a));
#  else
  return make_float4(floorf(a.x), floorf(a.y), floorf(a.z), floorf(a.w));
#  endif
}

ccl_device_inline float4 mix(const float4 &a, const float4 &b, const float t)
{
  return a + t * (b - a);
}

#endif /* !__KERNEL_COMPUTE__*/

#ifdef __KERNEL_SSE__
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &b)
{
  return float4(_mm_castsi128_ps(
      _mm_shuffle_epi32(_mm_castps_si128(b), _MM_SHUFFLE(index_3, index_2, index_1, index_0))));
}

template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &a, const float4 &b)
{
  return float4(_mm_shuffle_ps(a.m128, b.m128, _MM_SHUFFLE(index_3, index_2, index_1, index_0)));
}

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &b)
{
  return float4(_mm_castpd_ps(_mm_movedup_pd(_mm_castps_pd(b))));
}

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &a, const float4 &b)
{
  return float4(_mm_movelh_ps(a.m128, b.m128));
}

template<> __forceinline const float4 shuffle<2, 3, 2, 3>(const float4 &a, const float4 &b)
{
  return float4(_mm_movehl_ps(b.m128, a.m128));
}

#  ifdef __KERNEL_SSE3__
template<> __forceinline const float4 shuffle<0, 0, 2, 2>(const float4 &b)
{
  return float4(_mm_moveldup_ps(b));
}

template<> __forceinline const float4 shuffle<1, 1, 3, 3>(const float4 &b)
{
  return float4(_mm_movehdup_ps(b));
}
#  endif /* __KERNEL_SSE3__ */
#endif   /* __KERNEL_SSE__ */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline float4 select(const float4 &b_false, const float4 &a_true, const int4 &mask)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_blendv_ps(b_false.m128, a_true.m128, _mm_castsi128_ps(mask.m128)));
#  else
  return make_float4((mask.x) ? a_true.x : b_false.x,
                     (mask.y) ? a_true.y : b_false.y,
                     (mask.z) ? a_true.z : b_false.z,
                     (mask.w) ? a_true.w : b_false.w);
#  endif
}

ccl_device_inline float4 reduce_min(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  float4 h = min(shuffle<1, 0, 3, 2>(a), a);
  return min(shuffle<2, 3, 0, 1>(h), h);
#  else
  return make_float4(min(min(a.x, a.y), min(a.z, a.w)));
#  endif
}

ccl_device_inline float4 reduce_max(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  float4 h = max(shuffle<1, 0, 3, 2>(a), a);
  return max(shuffle<2, 3, 0, 1>(h), h);
#  else
  return make_float4(max(max(a.x, a.y), max(a.z, a.w)));
#  endif
}

#endif /* !__KERNEL_COMPUTE__ */

ccl_device_inline float4 safe_divide_float4_float(const float4 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float4(0.0f, 0.0f, 0.0f, 0.0f);
}

ccl_device_inline float4 clamp_to_normal_f4(const float4 a)
{
  return min(max(a, 0.0f), 1.0f);
}

CCL_NAMESPACE_END

#endif

#line 426 ".kernel_util/COM_kernel_math.h"

CCL_NAMESPACE_BEGIN

#ifndef __KERNEL_OPENCL__
/* Interpolation */

template<class A, class B> A lerp(const A &a, const A &b, const B &t)
{
  return (A)(a * ((B)1 - t) + b * t);
}

#endif /* __KERNEL_OPENCL__ */

/* Triangle */
#ifndef __KERNEL_OPENCL__
ccl_device_inline float triangle_area(const float3 &v1, const float3 &v2, const float3 &v3)
#else
ccl_device_inline float triangle_area(const float3 v1, const float3 v2, const float3 v3)
#endif
{
  return len(cross(v3 - v2, v1 - v2)) * 0.5f;
}

/* Orthonormal vectors */

ccl_device_inline void make_orthonormals(const float3 N, float3 *a, float3 *b)
{
#if 0
  if (fabsf(N.y) >= 0.999f) {
    *a = make_float3(1, 0, 0);
    *b = make_float3(0, 0, 1);
    return;
  }
  if (fabsf(N.z) >= 0.999f) {
    *a = make_float3(1, 0, 0);
    *b = make_float3(0, 1, 0);
    return;
  }
#endif

  if (N.x != N.y || N.x != N.z)
    *a = make_float3(N.z - N.y, N.x - N.z, N.y - N.x);  //(1,1,1)x N
  else
    *a = make_float3(N.z - N.y, N.x + N.z, -N.y - N.x);  //(-1,1,1)x N

  *a = normalize(*a);
  *b = cross(N, *a);
}

/* Color division */

ccl_device_inline float3 safe_invert_color(const float3 a)
{
  float x, y, z;

  x = (a.x != 0.0f) ? 1.0f / a.x : 0.0f;
  y = (a.y != 0.0f) ? 1.0f / a.y : 0.0f;
  z = (a.z != 0.0f) ? 1.0f / a.z : 0.0f;

  return make_float3(x, y, z);
}

ccl_device_inline float3 safe_divide_color(const float3 a, const float3 b)
{
  float x, y, z;

  x = (b.x != 0.0f) ? a.x / b.x : 0.0f;
  y = (b.y != 0.0f) ? a.y / b.y : 0.0f;
  z = (b.z != 0.0f) ? a.z / b.z : 0.0f;

  return make_float3(x, y, z);
}

ccl_device_inline float3 safe_divide_even_color(const float3 a, const float3 b)
{
  float x, y, z;

  x = (b.x != 0.0f) ? a.x / b.x : 0.0f;
  y = (b.y != 0.0f) ? a.y / b.y : 0.0f;
  z = (b.z != 0.0f) ? a.z / b.z : 0.0f;

  /* try to get gray even if b is zero */
  if (b.x == 0.0f) {
    if (b.y == 0.0f) {
      x = z;
      y = z;
    }
    else if (b.z == 0.0f) {
      x = y;
      z = y;
    }
    else
      x = 0.5f * (y + z);
  }
  else if (b.y == 0.0f) {
    if (b.z == 0.0f) {
      y = x;
      z = x;
    }
    else
      y = 0.5f * (x + z);
  }
  else if (b.z == 0.0f) {
    z = 0.5f * (x + y);
  }

  return make_float3(x, y, z);
}

/* Rotation of point around axis and angle */

ccl_device_inline float3 rotate_around_axis(const float3 p, const float3 axis, const float angle)
{
  float costheta = cosf(angle);
  float sintheta = sinf(angle);
  float3 r;

  r.x = ((costheta + (1 - costheta) * axis.x * axis.x) * p.x) +
        (((1 - costheta) * axis.x * axis.y - axis.z * sintheta) * p.y) +
        (((1 - costheta) * axis.x * axis.z + axis.y * sintheta) * p.z);

  r.y = (((1 - costheta) * axis.x * axis.y + axis.z * sintheta) * p.x) +
        ((costheta + (1 - costheta) * axis.y * axis.y) * p.y) +
        (((1 - costheta) * axis.y * axis.z - axis.x * sintheta) * p.z);

  r.z = (((1 - costheta) * axis.x * axis.z - axis.y * sintheta) * p.x) +
        (((1 - costheta) * axis.y * axis.z + axis.x * sintheta) * p.y) +
        ((costheta + (1 - costheta) * axis.z * axis.z) * p.z);

  return r;
}

/* NaN-safe math ops */

ccl_device_inline float safe_sqrtf(const float f)
{
  return sqrtf(max(f, 0.0f));
}

ccl_device_inline float inversesqrtf(const float f)
{
  return (f > 0.0f) ? 1.0f / sqrtf(f) : 0.0f;
}

ccl_device float safe_asinf(const float a)
{
  return asinf(clamp(a, -1.0f, 1.0f));
}

ccl_device float safe_acosf(const float a)
{
  return acosf(clamp(a, -1.0f, 1.0f));
}

ccl_device float compatible_powf(const float x, const float y)
{
#ifdef __KERNEL_COMPUTE__
  if (y == 0.0f) /* x^0 -> 1, including 0^0 */
    return 1.0f;

  /* GPU pow doesn't accept negative x, do manual checks here */
  if (x < 0.0f) {
    if (fmodf(-y, 2.0f) == 0.0f)
      return powf(-x, y);
    else
      return -powf(-x, y);
  }
  else if (x == 0.0f)
    return 0.0f;
#endif
  return powf(x, y);
}

ccl_device float safe_powf(const float a, const float b)
{
  if (UNLIKELY(a < 0.0f && b != float_to_int(b)))
    return 0.0f;

  return compatible_powf(a, b);
}

ccl_device float safe_divide(const float a, const float b)
{
  return (b != 0.0f) ? a / b : 0.0f;
}

ccl_device float safe_logf(const float a, const float b)
{
  if (UNLIKELY(a <= 0.0f || b <= 0.0f))
    return 0.0f;

  return safe_divide(logf(a), logf(b));
}

ccl_device float safe_modulo(const float a, const float b)
{
  return (b != 0.0f) ? fmodf(a, b) : 0.0f;
}

ccl_device_inline float sqr(const float a)
{
  return a * a;
}

ccl_device_inline float pow20(const float a)
{
  return sqr(sqr(sqr(sqr(a)) * a));
}

ccl_device_inline float pow22(float a)
{
  return sqr(a * sqr(sqr(sqr(a)) * a));
}

ccl_device_inline float beta(float x, float y)
{
#ifndef __KERNEL_OPENCL__
  return expf(lgammaf(x) + lgammaf(y) - lgammaf(x + y));
#else
  return expf(lgamma(x) + lgamma(y) - lgamma(x + y));
#endif
}

ccl_device_inline float xor_signmask(const float x, const int y)
{
  return __int_as_float(__float_as_int(x) ^ y);
}

ccl_device float bits_to_01(const uint bits)
{
  return bits * (1.0f / (float)0xFFFFFFFF);
}

ccl_device_inline uint count_leading_zeros(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return __clz(x);
#elif defined(__KERNEL_OPENCL__)
  return clz(x);
#else
  assert(x != 0);
#  ifdef _MSC_VER
  unsigned long leading_zero = 0;
  _BitScanReverse(&leading_zero, x);
  return (31 - leading_zero);
#  else
  return __builtin_clz(x);
#  endif
#endif
}

ccl_device_inline uint count_trailing_zeros(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return (__ffs(x) - 1);
#elif defined(__KERNEL_OPENCL__)
  return (31 - count_leading_zeros(x & -x));
#else
  assert(x != 0);
#  ifdef _MSC_VER
  unsigned long ctz = 0;
  _BitScanForward(&ctz, x);
  return ctz;
#  else
  return __builtin_ctz(x);
#  endif
#endif
}

ccl_device_inline uint find_first_set(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return __ffs(x);
#elif defined(__KERNEL_OPENCL__)
  return (x != 0) ? (32 - count_leading_zeros(x & (-x))) : 0;
#else
#  ifdef _MSC_VER
  return (x != 0) ? (32 - count_leading_zeros(x & (-x))) : 0;
#  else
  return __builtin_ffs(x);
#  endif
#endif
}

/* projections */
ccl_device_inline float2 map_to_tube(const float3 co)
{
  float len, u, v;
  len = sqrtf(co.x * co.x + co.y * co.y);
  if (len > 0.0f) {
    u = (1.0f - (atan2f(co.x / len, co.y / len) / M_PI_F)) * 0.5f;
    v = (co.z + 1.0f) * 0.5f;
  }
  else {
    u = v = 0.0f;
  }
  return make_float2(u, v);
}

ccl_device_inline float2 map_to_sphere(const float3 co)
{
  float l = len(co);
  float u, v;
  if (l > 0.0f) {
    if (UNLIKELY(co.x == 0.0f && co.y == 0.0f)) {
      u = 0.0f; /* othwise domain error */
    }
    else {
      u = (1.0f - atan2f(co.x, co.y) / M_PI_F) / 2.0f;
    }
    v = 1.0f - safe_acosf(co.z / l) / M_PI_F;
  }
  else {
    u = v = 0.0f;
  }
  return make_float2(u, v);
}

/* Compares two floats.
 * Returns true if their absolute difference is smaller than abs_diff (for numbers near zero)
 * or their relative difference is less than ulp_diff ULPs.
 * Based on
 * https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
 */

ccl_device_inline float compare_floats(const float a,
                                       const float b,
                                       const float abs_diff,
                                       const int ulp_diff)
{
  if (fabsf(a - b) < abs_diff) {
    return true;
  }

  if ((a < 0.0f) != (b < 0.0f)) {
    return false;
  }

  return (abs(__float_as_int(a) - __float_as_int(b)) < ulp_diff);
}

ccl_device_inline float clamp_to_normal(const float a)
{
  return min(max(a, 0.0f), 1.0f);
}

ccl_device_inline float4 interp_f4f4(const float4 a, const float4 b, const float t)
{
  const float s = 1.0f - t;

  return s * a + t * b;
}

CCL_NAMESPACE_END

#endif

#line 6 ".kernel_util/COM_kernel_algo.h"

CCL_NAMESPACE_BEGIN

/* BokehImageOperation */

/**
 * \brief determine the coordinate of a flap corner.
 *
 * \param r: result in bokehimage space are stored [x,y]
 * \param flapNumber: the flap number to calculate
 * \param distance: the lens distance is used to simulate lens shifts
 */
ccl_device_inline float2 bokehStartPointOfFlap(
    int flapNumber, float distance, float2 center, float flap_rad, float flap_rad_add)
{
  return make_float2(sinf(flap_rad * flapNumber + flap_rad_add) * distance + center.x,
                     cosf(flap_rad * flapNumber + flap_rad_add) * distance + center.y);
}

/**
 * \brief Determine if a coordinate is inside the bokeh image
 *
 * \param distance: the distance that will be used.
 * This parameter is modified a bit to mimic lens shifts.
 * \param x: the x coordinate of the pixel to evaluate
 * \param y: the y coordinate of the pixel to evaluate
 * \return float range 0..1 0 is completely outside
 */
ccl_device_inline float bokehIsInside(const float c_distance,
                                      const float2 coord,
                                      const float2 center,
                                      const float flap_rad,
                                      const float flap_rad_add,
                                      const float rounding,
                                      const float catadioptric)
{
  float insideBokeh = 0.0f;
  float2 delta = coord - center;

  const float distanceToCenter = distance(coord, center);
  const float bearing = (atan2f(delta.x, delta.y) + (M_PI_F * 2.0f));
  int flapNumber = (int)((bearing - flap_rad_add) / flap_rad);

  float2 lineP1 = bokehStartPointOfFlap(flapNumber, c_distance, center, flap_rad, flap_rad_add);
  float2 lineP2 = bokehStartPointOfFlap(
      flapNumber + 1, c_distance, center, flap_rad, flap_rad_add);
  float2 closestPoint = closest_to_line_v2(coord, lineP1, lineP2);

  const float distanceLineToCenter = distance(center, closestPoint);
  const float distanceRoundingToCenter = (1.0f - rounding) * distanceLineToCenter +
                                         rounding * c_distance;

  const float catadioptricDistanceToCenter = distanceRoundingToCenter * catadioptric;
  if (distanceRoundingToCenter >= distanceToCenter &&
      catadioptricDistanceToCenter <= distanceToCenter) {
    if (distanceRoundingToCenter - distanceToCenter < 1.0f) {
      insideBokeh = (distanceRoundingToCenter - distanceToCenter);
    }
    else if (catadioptric != 0.0f && distanceToCenter - catadioptricDistanceToCenter < 1.0f) {
      insideBokeh = (distanceToCenter - catadioptricDistanceToCenter);
    }
    else {
      insideBokeh = 1.0f;
    }
  }
  return insideBokeh;
}

/* END of BokehImageOperation */

/* ColorBalanceASCCDLOperation */

ccl_device_inline float4 colorbalance_cdl(const float4 in,
                                          const float4 offset,
                                          const float4 power,
                                          const float4 slope)
{
  float4 res = in * slope + offset;

  /* prevent NaN */
  float4 zero4 = make_float4_1(0.0f);
  res = select(res, zero4, res < zero4);

  res.x = powf(res.x, power.x);
  res.y = powf(res.y, power.y);
  res.z = powf(res.z, power.z);
  res.w = in.w;

  return res;
}

/* END of ColorBalanceASCCDLOperation */

/* ColorBalanceLGGOperation */

ccl_device_inline float4 colorbalance_lgg(float4 in,
                                          float4 lift_lgg,
                                          float4 gamma_inv,
                                          float4 gain)
{
  /* 1:1 match with the sequencer with linear/srgb conversions, the conversion isnt pretty
   * but best keep it this way, since testing for durian shows a similar calculation
   * without lin/srgb conversions gives bad results (over-saturated shadows) with colors
   * slightly below 1.0. some correction can be done but it ends up looking bad for shadows or
   * lighter tones - campbell */
  float4 res;
  res.x = linearrgb_to_srgb(in.x);
  res.y = linearrgb_to_srgb(in.y);
  res.z = linearrgb_to_srgb(in.z);
  res = (((res - 1.0f) * lift_lgg) + 1.0f) * gain;
  if (res.x < 0.0f) {
    res.x = 0.0f;
  }
  if (res.y < 0.0f) {
    res.y = 0.0f;
  }
  if (res.z < 0.0f) {
    res.z = 0.0f;
  }
  res.x = powf(srgb_to_linearrgb(res.x), gamma_inv.x);
  res.y = powf(srgb_to_linearrgb(res.y), gamma_inv.y);
  res.z = powf(srgb_to_linearrgb(res.z), gamma_inv.z);
  res.w = in.w;

  return res;
}
/* END of ColorBalanceLGGOperation */

CCL_NAMESPACE_END

#endif

#line 151 ".COM_kernel_opencl.h"
#line 1 ".kernel_util/COM_kernel_color.h"
#ifndef __COM_KERNEL_COLOR_H__
#define __COM_KERNEL_COLOR_H__

/* All this methods has been taken from blendlib math_color.c file.
 * They are adapted for kernel compatibility with float4 vectors and normalized colors */
#line 1 ".kernel_util/COM_kernel_geom.h"
#ifndef __COM_KERNEL_GEOM_H__
#define __COM_KERNEL_GEOM_H__

#line 1 ".kernel_util/COM_kernel_math.h"
#ifndef __COM_KERNEL_MATH_H__
#define __COM_KERNEL_MATH_H__

/* Math
 *
 * Basic math functions on scalar and vector types. This header is used by
 * both the kernel code when compiled as C++, and other C++ non-kernel code. */

#ifndef __KERNEL_COMPUTE__
#  include <cmath>
#endif

#ifndef __KERNEL_OPENCL__
#  include <float.h>
#  include <math.h>
#  include <stdio.h>
#endif /* __KERNEL_OPENCL__ */

#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 19 ".kernel_util/COM_kernel_math.h"

CCL_NAMESPACE_BEGIN

/* Float Pi variations */

/* Division */
#ifndef M_PI_F
#  define M_PI_F (3.1415926535897932f) /* pi */
#endif
#ifndef M_PI_2_F
#  define M_PI_2_F (1.5707963267948966f) /* pi/2 */
#endif
#ifndef M_PI_4_F
#  define M_PI_4_F (0.7853981633974830f) /* pi/4 */
#endif
#ifndef M_1_PI_F
#  define M_1_PI_F (0.3183098861837067f) /* 1/pi */
#endif
#ifndef M_2_PI_F
#  define M_2_PI_F (0.6366197723675813f) /* 2/pi */
#endif
#ifndef M_1_2PI_F
#  define M_1_2PI_F (0.1591549430918953f) /* 1/(2*pi) */
#endif
#ifndef M_SQRT_PI_8_F
#  define M_SQRT_PI_8_F (0.6266570686577501f) /* sqrt(pi/8) */
#endif
#ifndef M_LN_2PI_F
#  define M_LN_2PI_F (1.8378770664093454f) /* ln(2*pi) */
#endif

/* Multiplication */
#ifndef M_2PI_F
#  define M_2PI_F (6.2831853071795864f) /* 2*pi */
#endif
#ifndef M_4PI_F
#  define M_4PI_F (12.566370614359172f) /* 4*pi */
#endif

/* Float sqrt variations */
#ifndef M_SQRT2_F
#  define M_SQRT2_F (1.4142135623730950f) /* sqrt(2) */
#endif
#ifndef M_LN2_F
#  define M_LN2_F (0.6931471805599453f) /* ln(2) */
#endif
#ifndef M_LN10_F
#  define M_LN10_F (2.3025850929940457f) /* ln(10) */
#endif

#ifndef RAD2DEGF
#  define RAD2DEGF(_rad) ((_rad) * (float)(180.0f / M_PI_F))
#endif
#ifndef DEG2RADF
#  define DEG2RADF(_deg) ((_deg) * (float)(M_PI_F / 180.0f))
#endif

/* Scalar */

#ifdef _WIN32
#  ifndef __KERNEL_OPENCL__
ccl_device_inline float fmaxf(float a, float b)
{
  return (a > b) ? a : b;
}

ccl_device_inline float fminf(float a, float b)
{
  return (a < b) ? a : b;
}
#  endif /* !__KERNEL_OPENCL__ */
#endif   /* _WIN32 */

#ifndef __KERNEL_COMPUTE__
using std::isfinite;
using std::isnan;
using std::sqrt;

ccl_device_inline int abs(const int x)
{
  return (x > 0) ? x : -x;
}

ccl_device_inline int max(const int a, const int b)
{
  return (a > b) ? a : b;
}

ccl_device_inline int min(const int a, const int b)
{
  return (a < b) ? a : b;
}

ccl_device_inline float max(const float a, const float b)
{
  return (a > b) ? a : b;
}

ccl_device_inline float min(const float a, const float b)
{
  return (a < b) ? a : b;
}
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline float fminf3(const float a, const float b, const float c)
{
  return fminf(fminf(a, b), c);
}

ccl_device_inline float fmaxf3(const float a, const float b, const float c)
{
  return fmaxf(fmaxf(a, b), c);
}

ccl_device_inline float fminf4(const float a, const float b, const float c, const float d)
{
  return fminf(fminf(a, b), fminf(c, d));
}

ccl_device_inline float fmaxf4(const float a, const float b, const float c, const float d)
{
  return fmaxf(fmaxf(a, b), fmaxf(c, d));
}

#ifndef __KERNEL_OPENCL__
/* Int/Float conversion */

ccl_device_inline int as_int(uint i)
{
  union {
    uint ui;
    int i;
  } u;
  u.ui = i;
  return u.i;
}

ccl_device_inline uint as_uint(int i)
{
  union {
    uint ui;
    int i;
  } u;
  u.i = i;
  return u.ui;
}

ccl_device_inline uint as_uint(float f)
{
  union {
    uint i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline int __float_as_int(float f)
{
  union {
    int i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline float __int_as_float(int i)
{
  union {
    int i;
    float f;
  } u;
  u.i = i;
  return u.f;
}

ccl_device_inline uint __float_as_uint(float f)
{
  union {
    uint i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline float __uint_as_float(uint i)
{
  union {
    uint i;
    float f;
  } u;
  u.i = i;
  return u.f;
}

ccl_device_inline int4 __float4_as_int4(float4 f)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(f.m128));
#  else
  return make_int4(
      __float_as_int(f.x), __float_as_int(f.y), __float_as_int(f.z), __float_as_int(f.w));
#  endif
}

ccl_device_inline float4 __int4_as_float4(int4 i)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_castsi128_ps(i.m128));
#  else
  return make_float4(
      __int_as_float(i.x), __int_as_float(i.y), __int_as_float(i.z), __int_as_float(i.w));
#  endif
}
#endif /* __KERNEL_OPENCL__ */

/* Versions of functions which are safe for fast math. */
ccl_device_inline bool isnan_safe(const float f)
{
  unsigned int x = __float_as_uint(f);
  return (x << 1) > 0xff000000u;
}

ccl_device_inline bool isfinite_safe(const float f)
{
  /* By IEEE 754 rule, 2*Inf equals Inf */
  unsigned int x = __float_as_uint(f);
  return (f == f) && (x == 0 || x == (1u << 31) || (f != 2.0f * f)) && !((x << 1) > 0xff000000u);
}

ccl_device_inline float ensure_finite(const float v)
{
  return isfinite_safe(v) ? v : 0.0f;
}

#ifndef __KERNEL_OPENCL__
ccl_device_inline int clamp(const int a, const int mn, const int mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float clamp(const float a, const float mn, const float mx)
{
  return fminf(fmaxf(a, mn), mx);
}

ccl_device_inline float mix(const float a, const float b, const float t)
{
  return a + t * (b - a);
}

ccl_device_inline float smoothstep(const float edge0, const float edge1, const float x)
{
  float result;
  if (x < edge0)
    result = 0.0f;
  else if (x >= edge1)
    result = 1.0f;
  else {
    float t = (x - edge0) / (edge1 - edge0);
    result = (3.0f - 2.0f * t) * (t * t);
  }
  return result;
}

#endif /* __KERNEL_OPENCL__ */

#ifndef __KERNEL_CUDA__
ccl_device_inline float saturate(const float a)
{
  return clamp(a, 0.0f, 1.0f);
}
#endif /* __KERNEL_CUDA__ */

ccl_device_inline int float_to_int(const float f)
{
  return (int)f;
}

ccl_device_inline int floor_to_int(const float f)
{
  return float_to_int(floorf(f));
}

ccl_device_inline int quick_floor_to_int(const float x)
{
  return float_to_int(x) - ((x < 0) ? 1 : 0);
}

ccl_device_inline float floorfrac(const float x, int *i)
{
  *i = quick_floor_to_int(x);
  return x - *i;
}

ccl_device_inline int ceil_to_int(const float f)
{
  return float_to_int(ceilf(f));
}

ccl_device_inline float fractf(const float x)
{
  return x - floorf(x);
}

/* Adapted from godotengine math_funcs.h. */
ccl_device_inline float wrapf(const float value, const float max, const float min)
{
  float range = max - min;
  return (range != 0.0f) ? value - (range * floorf((value - min) / range)) : min;
}

ccl_device_inline float pingpongf(const float a, const float b)
{
  return (b != 0.0f) ? fabsf(fractf((a - b) / (b * 2.0f)) * b * 2.0f - b) : 0.0f;
}

ccl_device_inline float smoothminf(const float a, const float b, const float k)
{
  if (k != 0.0f) {
    float h = fmaxf(k - fabsf(a - b), 0.0f) / k;
    return fminf(a, b) - h * h * h * k * (1.0f / 6.0f);
  }
  else {
    return fminf(a, b);
  }
}

ccl_device_inline float signf(const float f)
{
  return (f < 0.0f) ? -1.0f : 1.0f;
}

ccl_device_inline float nonzerof(const float f, const float eps)
{
  if (fabsf(f) < eps)
    return signf(f) * eps;
  else
    return f;
}

/* Signum function testing for zero. Matches GLSL and OSL functions. */
ccl_device_inline float compatible_signf(const float f)
{
  if (f == 0.0f) {
    return 0.0f;
  }
  else {
    return signf(f);
  }
}

ccl_device_inline float smoothstepf(const float f)
{
  float ff = f * f;
  return (3.0f * ff - 2.0f * ff * f);
}

ccl_device_inline int mod(const int x, const int m)
{
  return (x % m + m) % m;
}

ccl_device_inline float3 float2_to_float3(const float2 a)
{
  return make_float3(a.x, a.y, 0.0f);
}

ccl_device_inline float3 float4_to_float3(const float4 a)
{
  return make_float3(a.x, a.y, a.z);
}

ccl_device_inline float4 float3_to_float4(const float3 a)
{
  return make_float4(a.x, a.y, a.z, 1.0f);
}

ccl_device_inline float inverse_lerp(const float a, const float b, const float x)
{
  return (x - a) / (b - a);
}

/* Cubic interpolation between b and c, a and d are the previous and next point. */
ccl_device_inline float cubic_interp(
    const float a, const float b, const float c, const float d, const float x)
{
  return 0.5f *
             (((d + 3.0f * (b - c) - a) * x + (2.0f * a - 5.0f * b + 4.0f * c - d)) * x +
              (c - a)) *
             x +
         b;
}

CCL_NAMESPACE_END

#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 418 ".kernel_util/COM_kernel_math.h"

#line 1 ".kernel_util/COM_kernel_math_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT2_H__
#define __COM_KERNEL_MATH_INT2_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline bool operator==(const int2 a, const int2 b);
ccl_device_inline int2 operator+(const int2 &a, const int2 &b);
ccl_device_inline int2 operator+=(int2 &a, const int2 &b);
ccl_device_inline int2 operator-(const int2 &a, const int2 &b);
ccl_device_inline int2 operator*(const int2 &a, const int2 &b);
ccl_device_inline int2 operator/(const int2 &a, const int2 &b);
#endif /* !__KERNEL_OPENCL__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline bool operator==(const int2 a, const int2 b)
{
  return (a.x == b.x && a.y == b.y);
}

ccl_device_inline int2 operator+(const int2 &a, const int2 &b)
{
  return make_int2(a.x + b.x, a.y + b.y);
}

ccl_device_inline int2 operator+=(int2 &a, const int2 &b)
{
  return a = a + b;
}

ccl_device_inline int2 operator-(const int2 &a, const int2 &b)
{
  return make_int2(a.x - b.x, a.y - b.y);
}

ccl_device_inline int2 operator*(const int2 &a, const int2 &b)
{
  return make_int2(a.x * b.x, a.y * b.y);
}

ccl_device_inline int2 operator/(const int2 &a, const int2 &b)
{
  return make_int2(a.x / b.x, a.y / b.y);
}
#endif /* !__KERNEL_OPENCL__ */

CCL_NAMESPACE_END

#endif

#line 420 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT3_H__
#define __COM_KERNEL_MATH_INT3_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline int3 min(int3 a, int3 b);
ccl_device_inline int3 max(int3 a, int3 b);
ccl_device_inline int3 clamp(const int3 &a, int mn, int mx);
ccl_device_inline int3 clamp(const int3 &a, int3 &mn, int mx);
#endif /* !__KERNEL_OPENCL__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline int3 min(int3 a, int3 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int3(_mm_min_epi32(a.m128, b.m128));
#  else
  return make_int3(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));
#  endif
}

ccl_device_inline int3 max(int3 a, int3 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int3(_mm_max_epi32(a.m128, b.m128));
#  else
  return make_int3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));
#  endif
}

ccl_device_inline int3 clamp(const int3 &a, int mn, int mx)
{
#  ifdef __KERNEL_SSE__
  return min(max(a, make_int3_1(mn)), make_int3_1(mx));
#  else
  return make_int3(clamp(a.x, mn, mx), clamp(a.y, mn, mx), clamp(a.z, mn, mx));
#  endif
}

ccl_device_inline int3 clamp(const int3 &a, int3 &mn, int mx)
{
#  ifdef __KERNEL_SSE__
  return min(max(a, mn), make_int3_1(mx));
#  else
  return make_int3(clamp(a.x, mn.x, mx), clamp(a.y, mn.y, mx), clamp(a.z, mn.z, mx));
#  endif
}

ccl_device_inline bool operator==(const int3 &a, const int3 &b)
{
  return a.x == b.x && a.y == b.y && a.z == b.z;
}

ccl_device_inline bool operator!=(const int3 &a, const int3 &b)
{
  return !(a == b);
}

ccl_device_inline bool operator<(const int3 &a, const int3 &b)
{
  return a.x < b.x && a.y < b.y && a.z < b.z;
}

ccl_device_inline int3 operator+(const int3 &a, const int3 &b)
{
#  ifdef __KERNEL_SSE__
  return int3(_mm_add_epi32(a.m128, b.m128));
#  else
  return make_int3(a.x + b.x, a.y + b.y, a.z + b.z);
#  endif
}

ccl_device_inline int3 operator-(const int3 &a, const int3 &b)
{
#  ifdef __KERNEL_SSE__
  return int3(_mm_sub_epi32(a.m128, b.m128));
#  else
  return make_int3(a.x - b.x, a.y - b.y, a.z - b.z);
#  endif
}
#endif /* !__KERNEL_OPENCL__ */

CCL_NAMESPACE_END

#endif /* __COM_kernel_MATH_INT3_H__ */

#line 421 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT4_H__
#define __COM_KERNEL_MATH_INT4_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline int4 operator+(const int4 &a, const int4 &b);
ccl_device_inline int4 operator+=(int4 &a, const int4 &b);
ccl_device_inline int4 operator>>(const int4 &a, int i);
ccl_device_inline int4 operator<<(const int4 &a, int i);
ccl_device_inline int4 operator<(const int4 &a, const int4 &b);
ccl_device_inline int4 operator>=(const int4 &a, const int4 &b);
ccl_device_inline int4 operator&(const int4 &a, const int4 &b);
ccl_device_inline int4 min(int4 a, int4 b);
ccl_device_inline int4 max(int4 a, int4 b);
ccl_device_inline int4 clamp(const int4 &a, const int4 &mn, const int4 &mx);
ccl_device_inline int4 select(const int4 &mask, const int4 &a, const int4 &b);
#endif /* __KERNEL_COMPUTE__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline int4 operator+(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_add_epi32(a.m128, b.m128));
#  else
  return make_int4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
#  endif
}

ccl_device_inline int4 operator+=(int4 &a, const int4 &b)
{
  return a = a + b;
}

ccl_device_inline int4 operator>>(const int4 &a, int i)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_srai_epi32(a.m128, i));
#  else
  return make_int4(a.x >> i, a.y >> i, a.z >> i, a.w >> i);
#  endif
}

ccl_device_inline int4 operator<<(const int4 &a, int i)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_slli_epi32(a.m128, i));
#  else
  return make_int4(a.x << i, a.y << i, a.z << i, a.w << i);
#  endif
}

ccl_device_inline int4 operator<(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_cmplt_epi32(a.m128, b.m128));
#  else
  return make_int4(a.x < b.x, a.y < b.y, a.z < b.z, a.w < b.w);
#  endif
}

ccl_device_inline int4 operator>=(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_xor_si128(_mm_set1_epi32(0xffffffff), _mm_cmplt_epi32(a.m128, b.m128)));
#  else
  return make_int4(a.x >= b.x, a.y >= b.y, a.z >= b.z, a.w >= b.w);
#  endif
}

ccl_device_inline int4 operator&(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_and_si128(a.m128, b.m128));
#  else
  return make_int4(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
#  endif
}

ccl_device_inline int4 min(int4 a, int4 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int4(_mm_min_epi32(a.m128, b.m128));
#  else
  return make_int4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));
#  endif
}

ccl_device_inline int4 max(int4 a, int4 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int4(_mm_max_epi32(a.m128, b.m128));
#  else
  return make_int4(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z), max(a.w, b.w));
#  endif
}

ccl_device_inline int4 clamp(const int4 &a, const int4 &mn, const int4 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline int4 select(const int4 &mask, const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  const __m128 m = _mm_cvtepi32_ps(mask);
  /* TODO(sergey): avoid cvt. */
  return int4(_mm_castps_si128(
      _mm_or_ps(_mm_and_ps(m, _mm_castsi128_ps(a)), _mm_andnot_ps(m, _mm_castsi128_ps(b)))));
#  else
  return make_int4(
      (mask.x) ? a.x : b.x, (mask.y) ? a.y : b.y, (mask.z) ? a.z : b.z, (mask.w) ? a.w : b.w);
#  endif
}

ccl_device_inline int4 load_int4(const int *v)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_loadu_si128((__m128i *)v));
#  else
  return make_int4(v[0], v[1], v[2], v[3]);
#  endif
}
#endif /* __KERNEL_COMPUTE__ */

CCL_NAMESPACE_END

#endif

#line 422 ".kernel_util/COM_kernel_math.h"

#line 1 ".kernel_util/COM_kernel_math_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT2_H__
#define __COM_KERNEL_MATH_FLOAT2_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float2 operator-(const float2 &a);
ccl_device_inline float2 operator*(const float2 &a, const float2 &b);
ccl_device_inline float2 operator*(const float2 &a, float f);
ccl_device_inline float2 operator*(float f, const float2 &a);
ccl_device_inline float2 operator/(float f, const float2 &a);
ccl_device_inline float2 operator/(const float2 &a, float f);
ccl_device_inline float2 operator/(const float2 &a, const float2 &b);
ccl_device_inline float2 operator+(const float2 &a, const float f);
ccl_device_inline float2 operator+(const float2 &a, const float2 &b);
ccl_device_inline float2 operator-(const float2 &a, const float f);
ccl_device_inline float2 operator-(const float2 &a, const float2 &b);
ccl_device_inline float2 operator+=(float2 &a, const float2 &b);
ccl_device_inline float2 operator*=(float2 &a, const float2 &b);
ccl_device_inline float2 operator*=(float2 &a, float f);
ccl_device_inline float2 operator/=(float2 &a, const float2 &b);
ccl_device_inline float2 operator/=(float2 &a, float f);

ccl_device_inline bool operator==(const float2 &a, const float2 &b);
ccl_device_inline bool operator!=(const float2 &a, const float2 &b);

ccl_device_inline float average(const float2 &a);
ccl_device_inline float distance(const float2 &a, const float2 &b);
ccl_device_inline float dot(const float2 &a, const float2 &b);
ccl_device_inline float cross(const float2 &a, const float2 &b);
ccl_device_inline float len(const float2 &a);
ccl_device_inline float2 normalize(const float2 &a);
ccl_device_inline float2 normalize_len(const float2 &a, float *t);
ccl_device_inline float2 safe_normalize(const float2 &a);
ccl_device_inline float2 min(const float2 &a, const float2 &b);
ccl_device_inline float2 max(const float2 &a, const float2 &b);
ccl_device_inline float2 clamp(const float2 &a, const float2 &mn, const float2 &mx);
ccl_device_inline float2 fabs(const float2 &a);
ccl_device_inline float2 as_float2(const float4 &a);
ccl_device_inline float2 interp(const float2 &a, const float2 &b, float t);
ccl_device_inline float2 floor(const float2 &a);
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float2 safe_divide_float2_float(const float2 a, const float b);

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float2 operator-(const float2 &a)
{
  return make_float2(-a.x, -a.y);
}

ccl_device_inline float2 operator*(const float2 &a, const float2 &b)
{
  return make_float2(a.x * b.x, a.y * b.y);
}

ccl_device_inline float2 operator*(const float2 &a, float f)
{
  return make_float2(a.x * f, a.y * f);
}

ccl_device_inline float2 operator*(float f, const float2 &a)
{
  return make_float2(a.x * f, a.y * f);
}

ccl_device_inline float2 operator/(float f, const float2 &a)
{
  return make_float2(f / a.x, f / a.y);
}

ccl_device_inline float2 operator/(const float2 &a, float f)
{
  float invf = 1.0f / f;
  return make_float2(a.x * invf, a.y * invf);
}

ccl_device_inline float2 operator/(const float2 &a, const float2 &b)
{
  return make_float2(a.x / b.x, a.y / b.y);
}

ccl_device_inline float2 operator+(const float2 &a, const float f)
{
  return a + make_float2(f, f);
}

ccl_device_inline float2 operator+(const float2 &a, const float2 &b)
{
  return make_float2(a.x + b.x, a.y + b.y);
}

ccl_device_inline float2 operator-(const float2 &a, const float f)
{
  return a - make_float2(f, f);
}

ccl_device_inline float2 operator-(const float2 &a, const float2 &b)
{
  return make_float2(a.x - b.x, a.y - b.y);
}

ccl_device_inline float2 operator+=(float2 &a, const float2 &b)
{
  return a = a + b;
}

ccl_device_inline float2 operator*=(float2 &a, const float2 &b)
{
  return a = a * b;
}

ccl_device_inline float2 operator*=(float2 &a, float f)
{
  return a = a * f;
}

ccl_device_inline float2 operator/=(float2 &a, const float2 &b)
{
  return a = a / b;
}

ccl_device_inline float2 operator/=(float2 &a, float f)
{
  float invf = 1.0f / f;
  return a = a * invf;
}

ccl_device_inline bool operator==(const float2 &a, const float2 &b)
{
  return (a.x == b.x && a.y == b.y);
}

ccl_device_inline bool operator!=(const float2 &a, const float2 &b)
{
  return !(a == b);
}

ccl_device_inline float average(const float2 &a)
{
  return (a.x + a.y) * (1.0f / 2.0f);
}

ccl_device_inline float distance(const float2 &a, const float2 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float2 &a, const float2 &b)
{
  return a.x * b.x + a.y * b.y;
}

ccl_device_inline float cross(const float2 &a, const float2 &b)
{
  return (a.x * b.y - a.y * b.x);
}

ccl_device_inline float len(const float2 &a)
{
  return sqrtf(dot(a, a));
}

ccl_device_inline float2 normalize(const float2 &a)
{
  return a / len(a);
}

ccl_device_inline float2 normalize_len(const float2 &a, float *t)
{
  *t = len(a);
  return a / (*t);
}

ccl_device_inline float2 safe_normalize(const float2 &a)
{
  float t = len(a);
  return (t != 0.0f) ? a / t : a;
}

ccl_device_inline float2 min(const float2 &a, const float2 &b)
{
  return make_float2(fminf(a.x, b.x), fminf(a.y, b.y));
}

ccl_device_inline float2 max(const float2 &a, const float2 &b)
{
  return make_float2(fmaxf(a.x, b.x), fmaxf(a.y, b.y));
}

ccl_device_inline float2 clamp(const float2 &a, const float2 &mn, const float2 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float2 fabs(const float2 &a)
{
  return make_float2(fabsf(a.x), fabsf(a.y));
}

ccl_device_inline float2 as_float2(const float4 &a)
{
  return make_float2(a.x, a.y);
}

ccl_device_inline float2 interp(const float2 &a, const float2 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float2 mix(const float2 &a, const float2 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float2 floor(const float2 &a)
{
  return make_float2(floorf(a.x), floorf(a.y));
}

#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float2 safe_divide_float2_float(const float2 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float2(0.0f, 0.0f);
}

CCL_NAMESPACE_END

#endif

#line 424 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT3_H__
#define __COM_KERNEL_MATH_FLOAT3_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float3 operator-(const float3 &a);
ccl_device_inline float3 operator*(const float3 &a, const float3 &b);
ccl_device_inline float3 operator*(const float3 &a, const float f);
ccl_device_inline float3 operator*(const float f, const float3 &a);
ccl_device_inline float3 operator/(const float f, const float3 &a);
ccl_device_inline float3 operator/(const float3 &a, const float f);
ccl_device_inline float3 operator/(const float3 &a, const float3 &b);
ccl_device_inline float3 operator+(const float3 &a, const float f);
ccl_device_inline float3 operator+(const float3 &a, const float3 &b);
ccl_device_inline float3 operator-(const float3 &a, const float f);
ccl_device_inline float3 operator-(const float3 &a, const float3 &b);
ccl_device_inline float3 operator+=(float3 &a, const float3 &b);
ccl_device_inline float3 operator-=(float3 &a, const float3 &b);
ccl_device_inline float3 operator*=(float3 &a, const float3 &b);
ccl_device_inline float3 operator*=(float3 &a, float f);
ccl_device_inline float3 operator/=(float3 &a, const float3 &b);
ccl_device_inline float3 operator/=(float3 &a, float f);

ccl_device_inline bool operator==(const float3 &a, const float3 &b);
ccl_device_inline bool operator!=(const float3 &a, const float3 &b);

ccl_device_inline float distance(const float3 &a, const float3 &b);
ccl_device_inline float dot(const float3 &a, const float3 &b);
ccl_device_inline float dot_xy(const float3 &a, const float3 &b);
ccl_device_inline float3 cross(const float3 &a, const float3 &b);
ccl_device_inline float3 normalize(const float3 &a);
ccl_device_inline float3 min(const float3 &a, const float3 &b);
ccl_device_inline float3 max(const float3 &a, const float3 &b);
ccl_device_inline float3 clamp(const float3 &a, const float3 &mn, const float3 &mx);
ccl_device_inline float3 fabs(const float3 &a);
ccl_device_inline float3 mix(const float3 &a, const float3 &b, float t);
ccl_device_inline float3 rcp(const float3 &a);
ccl_device_inline float3 sqrt(const float3 &a);
ccl_device_inline float3 floor(const float3 &a);
ccl_device_inline float3 ceil(const float3 &a);
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float min3(float3 a);
ccl_device_inline float max3(float3 a);
ccl_device_inline float len(const float3 a);
ccl_device_inline float len_squared(const float3 a);

ccl_device_inline float3 reflect(const float3 incident, const float3 normal);
ccl_device_inline float3 project(const float3 v, const float3 v_proj);

ccl_device_inline float3 saturate3(float3 a);
ccl_device_inline float3 safe_normalize(const float3 a);
ccl_device_inline float3 normalize_len(const float3 a, float *t);
ccl_device_inline float3 safe_normalize_len(const float3 a, float *t);
ccl_device_inline float3 safe_divide_float3_float3(const float3 a, const float3 b);
ccl_device_inline float3 safe_divide_float3_float(const float3 a, const float b);
ccl_device_inline float3 interp(float3 a, float3 b, float t);
ccl_device_inline float3 sqr3(float3 a);
ccl_device_inline float reduce_add(const float3 a);
ccl_device_inline float average(const float3 a);
ccl_device_inline bool isequal_float3(const float3 a, const float3 b);

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float3 operator-(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_xor_ps(a.m128, _mm_castsi128_ps(_mm_set1_epi32(0x80000000))));
#  else
  return make_float3(-a.x, -a.y, -a.z);
#  endif
}

ccl_device_inline float3 operator*(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_mul_ps(a.m128, b.m128));
#  else
  return make_float3(a.x * b.x, a.y * b.y, a.z * b.z);
#  endif
}

ccl_device_inline float3 operator*(const float3 &a, const float f)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_mul_ps(a.m128, _mm_set1_ps(f)));
#  else
  return make_float3(a.x * f, a.y * f, a.z * f);
#  endif
}

ccl_device_inline float3 operator*(const float f, const float3 &a)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_mul_ps(_mm_set1_ps(f), a.m128));
#  else
  return make_float3(a.x * f, a.y * f, a.z * f);
#  endif
}

ccl_device_inline float3 operator/(const float f, const float3 &a)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_div_ps(_mm_set1_ps(f), a.m128));
#  else
  return make_float3(f / a.x, f / a.y, f / a.z);
#  endif
}

ccl_device_inline float3 operator/(const float3 &a, const float f)
{
  float invf = 1.0f / f;
  return a * invf;
}

ccl_device_inline float3 operator/(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_div_ps(a.m128, b.m128));
#  else
  return make_float3(a.x / b.x, a.y / b.y, a.z / b.z);
#  endif
}

ccl_device_inline float3 operator+(const float3 &a, const float f)
{
  return a + make_float3(f, f, f);
}

ccl_device_inline float3 operator+(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_add_ps(a.m128, b.m128));
#  else
  return make_float3(a.x + b.x, a.y + b.y, a.z + b.z);
#  endif
}

ccl_device_inline float3 operator-(const float3 &a, const float f)
{
  return a - make_float3(f, f, f);
}

ccl_device_inline float3 operator-(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_sub_ps(a.m128, b.m128));
#  else
  return make_float3(a.x - b.x, a.y - b.y, a.z - b.z);
#  endif
}

ccl_device_inline float3 operator+=(float3 &a, const float3 &b)
{
  return a = a + b;
}

ccl_device_inline float3 operator-=(float3 &a, const float3 &b)
{
  return a = a - b;
}

ccl_device_inline float3 operator*=(float3 &a, const float3 &b)
{
  return a = a * b;
}

ccl_device_inline float3 operator*=(float3 &a, float f)
{
  return a = a * f;
}

ccl_device_inline float3 operator/=(float3 &a, const float3 &b)
{
  return a = a / b;
}

ccl_device_inline float3 operator/=(float3 &a, float f)
{
  float invf = 1.0f / f;
  return a = a * invf;
}

ccl_device_inline bool operator==(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return (_mm_movemask_ps(_mm_cmpeq_ps(a.m128, b.m128)) & 7) == 7;
#  else
  return (a.x == b.x && a.y == b.y && a.z == b.z);
#  endif
}

ccl_device_inline bool operator!=(const float3 &a, const float3 &b)
{
  return !(a == b);
}

ccl_device_inline float distance(const float3 &a, const float3 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_dp_ps(a, b, 0x7F));
#  else
  return a.x * b.x + a.y * b.y + a.z * b.z;
#  endif
}

ccl_device_inline float dot_xy(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_hadd_ps(_mm_mul_ps(a, b), b));
#  else
  return a.x * b.x + a.y * b.y;
#  endif
}

ccl_device_inline float3 cross(const float3 &a, const float3 &b)
{
  float3 r = make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
  return r;
}

ccl_device_inline float3 normalize(const float3 &a)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  __m128 norm = _mm_sqrt_ps(_mm_dp_ps(a.m128, a.m128, 0x7F));
  return float3(_mm_div_ps(a.m128, norm));
#  else
  return a / len(a);
#  endif
}

ccl_device_inline float3 min(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_min_ps(a.m128, b.m128));
#  else
  return make_float3(fminf(a.x, b.x), fminf(a.y, b.y), fminf(a.z, b.z));
#  endif
}

ccl_device_inline float3 max(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_max_ps(a.m128, b.m128));
#  else
  return make_float3(fmaxf(a.x, b.x), fmaxf(a.y, b.y), fmaxf(a.z, b.z));
#  endif
}

ccl_device_inline float3 clamp(const float3 &a, const float3 &mn, const float3 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float3 fabs(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  __m128 mask = _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff));
  return float3(_mm_and_ps(a.m128, mask));
#  else
  return make_float3(fabsf(a.x), fabsf(a.y), fabsf(a.z));
#  endif
}

ccl_device_inline float3 sqrt(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_sqrt_ps(a));
#  else
  return make_float3(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z));
#  endif
}

ccl_device_inline float3 floor(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_floor_ps(a));
#  else
  return make_float3(floorf(a.x), floorf(a.y), floorf(a.z));
#  endif
}

ccl_device_inline float3 ceil(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_ceil_ps(a));
#  else
  return make_float3(ceilf(a.x), ceilf(a.y), ceilf(a.z));
#  endif
}

ccl_device_inline float3 mix(const float3 &a, const float3 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float3 rcp(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  /* Don't use _mm_rcp_ps due to poor precision. */
  return float3(_mm_div_ps(_mm_set_ps1(1.0f), a.m128));
#  else
  return make_float3(1.0f / a.x, 1.0f / a.y, 1.0f / a.z);
#  endif
}
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float min3(const float3 a)
{
  return min(min(a.x, a.y), a.z);
}

ccl_device_inline float max3(const float3 a)
{
  return max(max(a.x, a.y), a.z);
}

ccl_device_inline float len(const float3 a)
{
#if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_sqrt_ss(_mm_dp_ps(a.m128, a.m128, 0x7F)));
#else
  return sqrtf(dot(a, a));
#endif
}

ccl_device_inline float len_squared(const float3 a)
{
  return dot(a, a);
}

ccl_device_inline float3 reflect(const float3 incident, const float3 normal)
{
  float3 unit_normal = normalize(normal);
  return incident - 2.0f * unit_normal * dot(incident, unit_normal);
}

ccl_device_inline float3 project(const float3 v, const float3 v_proj)
{
  float len_squared = dot(v_proj, v_proj);
  return (len_squared != 0.0f) ? (dot(v, v_proj) / len_squared) * v_proj :
                                 make_float3(0.0f, 0.0f, 0.0f);
}

ccl_device_inline float3 saturate3(const float3 a)
{
  return make_float3(saturate(a.x), saturate(a.y), saturate(a.z));
}

ccl_device_inline float3 normalize_len(const float3 a, float *t)
{
  *t = len(a);
  float x = 1.0f / *t;
  return a * x;
}

ccl_device_inline float3 safe_normalize(const float3 a)
{
  float t = len(a);
  return (t != 0.0f) ? a * (1.0f / t) : a;
}

ccl_device_inline float3 safe_normalize_len(const float3 a, float *t)
{
  *t = len(a);
  return (*t != 0.0f) ? a / (*t) : a;
}

ccl_device_inline float3 safe_divide_float3_float3(const float3 a, const float3 b)
{
  return make_float3((b.x != 0.0f) ? a.x / b.x : 0.0f,
                     (b.y != 0.0f) ? a.y / b.y : 0.0f,
                     (b.z != 0.0f) ? a.z / b.z : 0.0f);
}

ccl_device_inline float3 safe_divide_float3_float(const float3 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float3(0.0f, 0.0f, 0.0f);
}

ccl_device_inline float3 interp(const float3 a, const float3 b, const float t)
{
  return a + t * (b - a);
}

ccl_device_inline float3 sqr3(const float3 a)
{
  return a * a;
}

ccl_device_inline float reduce_add(const float3 a)
{
  return (a.x + a.y + a.z);
}

ccl_device_inline float average(const float3 a)
{
  return reduce_add(a) * (1.0f / 3.0f);
}

ccl_device_inline bool isequal_float3(const float3 a, const float3 b)
{
#ifdef __KERNEL_OPENCL__
  return all(a == b);
#else
  return a == b;
#endif
}

ccl_device_inline float3 pow3(const float3 v, const float e)
{
  return make_float3(powf(v.x, e), powf(v.y, e), powf(v.z, e));
}

ccl_device_inline float3 exp3(const float3 v)
{
  return make_float3(expf(v.x), expf(v.y), expf(v.z));
}

ccl_device_inline float3 log3(const float3 v)
{
  return make_float3(logf(v.x), logf(v.y), logf(v.z));
}

ccl_device_inline int3 quick_floor_to_int3(const float3 a)
{
#ifdef __KERNEL_SSE__
  int3 b = int3(_mm_cvttps_epi32(a.m128));
  int3 isneg = int3(_mm_castps_si128(_mm_cmplt_ps(a.m128, _mm_set_ps1(0.0f))));
  /* Unsaturated add 0xffffffff is the same as subtract -1. */
  return b + isneg;
#else
  return make_int3(quick_floor_to_int(a.x), quick_floor_to_int(a.y), quick_floor_to_int(a.z));
#endif
}

ccl_device_inline bool isfinite3_safe(const float3 v)
{
  return isfinite_safe(v.x) && isfinite_safe(v.y) && isfinite_safe(v.z);
}

ccl_device_inline float3 ensure_finite3(float3 v)
{
  if (!isfinite_safe(v.x))
    v.x = 0.0f;
  if (!isfinite_safe(v.y))
    v.y = 0.0f;
  if (!isfinite_safe(v.z))
    v.z = 0.0f;
  return v;
}

CCL_NAMESPACE_END

#endif

#line 425 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT4_H__
#define __COM_KERNEL_MATH_FLOAT4_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float4 operator-(const float4 &a);
ccl_device_inline float4 operator*(const float4 &a, const float4 &b);
ccl_device_inline float4 operator*(const float4 &a, const float f);
ccl_device_inline float4 operator*(const float f, const float4 &a);
ccl_device_inline float4 operator/(const float4 &a, float f);
ccl_device_inline float4 operator/(const float f, const float4 &a);
ccl_device_inline float4 operator/(const float4 &a, const float4 &b);
ccl_device_inline float4 operator+(const float4 &a, const float f);
ccl_device_inline float4 operator+(const float f, const float4 &a);
ccl_device_inline float4 operator+(const float4 &a, const float4 &b);
ccl_device_inline float4 operator-(const float4 &a, const float f);
ccl_device_inline float4 operator-(const float f, const float4 &a);
ccl_device_inline float4 operator-(const float4 &a, const float4 &b);
ccl_device_inline float4 operator+=(float4 &a, const float4 &b);
ccl_device_inline float4 operator*=(float4 &a, const float4 &b);
ccl_device_inline float4 operator*=(float4 &a, const float f);
ccl_device_inline float4 operator/=(float4 &a, const float f);

ccl_device_inline int4 operator<(const float4 &a, const float4 &b);
ccl_device_inline int4 operator>(const float4 &a, const float4 &b);
ccl_device_inline int4 operator>=(const float4 &a, const float4 &b);
ccl_device_inline int4 operator<=(const float4 &a, const float4 &b);
ccl_device_inline int4 operator==(const float4 &a, const float4 &b);
ccl_device_inline int4 operator!=(const float4 &a, const float4 &b);

ccl_device_inline float distance(const float4 &a, const float4 &b);
ccl_device_inline float dot(const float4 &a, const float4 &b);
ccl_device_inline float len_squared(const float4 &a);
ccl_device_inline float4 rcp(const float4 &a);
ccl_device_inline float4 sqrt(const float4 &a);
ccl_device_inline float4 sqr(const float4 &a);
ccl_device_inline float4 cross(const float4 &a, const float4 &b);
ccl_device_inline float average(const float4 &a);
ccl_device_inline float len(const float4 &a);
ccl_device_inline float4 normalize(const float4 &a);
ccl_device_inline float4 safe_normalize(const float4 &a);
ccl_device_inline float4 min(const float4 &a, const float4 &b);
ccl_device_inline float4 min(const float4 &a, const float b);
ccl_device_inline float4 max(const float4 &a, const float4 &b);
ccl_device_inline float4 max(const float4 &a, const float b);
ccl_device_inline float4 clamp(const float4 &a, const float4 &mn, const float4 &mx);
ccl_device_inline float4 clamp(const float4 &a, const float mn, const float mx);
ccl_device_inline float4 fabs(const float4 &a);
ccl_device_inline float4 floor(const float4 &a);
ccl_device_inline float4 mix(const float4 &a, const float4 &b, const float t);
#endif /* !__KERNEL_OPENCL__*/

ccl_device_inline float4 safe_divide_float4_float(const float4 a, const float b);
ccl_device_inline float4 clamp_to_normal_f4(const float4 a);

#ifdef __KERNEL_SSE__
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &b);
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &a, const float4 &b);

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &b);

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &a, const float4 &b);
template<> __forceinline const float4 shuffle<2, 3, 2, 3>(const float4 &a, const float4 &b);

#  ifdef __KERNEL_SSE3__
template<> __forceinline const float4 shuffle<0, 0, 2, 2>(const float4 &b);
template<> __forceinline const float4 shuffle<1, 1, 3, 3>(const float4 &b);
#  endif
#endif /* __KERNEL_SSE__ */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline float4 select(const float4 &b_false, const float4 &a_true, const int4 &mask);
ccl_device_inline float4 reduce_min(const float4 &a);
ccl_device_inline float4 reduce_max(const float4 &a);
ccl_device_inline float4 reduce_add(const float4 &a);
#endif /* !__KERNEL_COMPUTE__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float4 operator-(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  __m128 mask = _mm_castsi128_ps(_mm_set1_epi32(0x80000000));
  return float4(_mm_xor_ps(a.m128, mask));
#  else
  return make_float4(-a.x, -a.y, -a.z, -a.w);
#  endif
}

ccl_device_inline float4 operator*(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_mul_ps(a.m128, b.m128));
#  else
  return make_float4(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
#  endif
}

ccl_device_inline float4 operator*(const float4 &a, const float f)
{
#  if defined(__KERNEL_SSE__)
  return a * make_float4_1(f);
#  else
  return make_float4(a.x * f, a.y * f, a.z * f, a.w * f);
#  endif
}

ccl_device_inline float4 operator*(const float f, const float4 &a)
{
  return a * f;
}

ccl_device_inline float4 operator/(const float4 &a, const float f)
{
  return a * (1.0f / f);
}

ccl_device_inline float4 operator/(const float f, const float4 &a)
{
  return make_float4_1(f) / a;
}
ccl_device_inline float4 operator/(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_div_ps(a.m128, b.m128));
#  else
  return make_float4(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
#  endif
}

ccl_device_inline float4 operator+(const float4 &a, const float f)
{
  return a + make_float4(f, f, f, f);
}

ccl_device_inline float4 operator+(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_add_ps(a.m128, b.m128));
#  else
  return make_float4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
#  endif
}

ccl_device_inline float4 operator+(const float f, const float4 &a)
{
  return make_float4(f, f, f, f) + a;
}

ccl_device_inline float4 operator-(const float4 &a, const float f)
{
  return a - make_float4(f, f, f, f);
}

ccl_device_inline float4 operator-(const float f, const float4 &a)
{
  return make_float4(f, f, f, f) - a;
}

ccl_device_inline float4 operator-(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_sub_ps(a.m128, b.m128));
#  else
  return make_float4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
#  endif
}

ccl_device_inline float4 operator+=(float4 &a, const float4 &b)
{
  return a = a + b;
}

ccl_device_inline float4 operator-=(float4 &a, const float4 &b)
{
  return a = a - b;
}

ccl_device_inline float4 operator*=(float4 &a, const float4 &b)
{
  return a = a * b;
}

ccl_device_inline float4 operator*=(float4 &a, const float f)
{
  return a = a * f;
}

ccl_device_inline float4 operator/=(float4 &a, const float f)
{
  return a = a / f;
}

ccl_device_inline int4 operator<(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmplt_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x < b.x, a.y < b.y, a.z < b.z, a.w < b.w);
#  endif
}

ccl_device_inline int4 operator>(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpgt_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x > b.x, a.y > b.y, a.z > b.z, a.w > b.w);
#  endif
}

ccl_device_inline int4 operator>=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpge_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x >= b.x, a.y >= b.y, a.z >= b.z, a.w >= b.w);
#  endif
}

ccl_device_inline int4 operator<=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmple_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x <= b.x, a.y <= b.y, a.z <= b.z, a.w <= b.w);
#  endif
}

ccl_device_inline int4 operator==(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpeq_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w);
#  endif
}

ccl_device_inline int4 operator!=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpneq_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x != b.x, a.y != b.y, a.z != b.z, a.w != b.w);
#  endif
}

ccl_device_inline float distance(const float4 &a, const float4 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float4 &a, const float4 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_dp_ps(a, b, 0xFF));
#  else
  return (a.x * b.x + a.y * b.y) + (a.z * b.z + a.w * b.w);
#  endif
}

ccl_device_inline float len_squared(const float4 &a)
{
  return dot(a, a);
}

ccl_device_inline float4 rcp(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  /* Don't use _mm_rcp_ps due to poor precision. */
  return float4(_mm_div_ps(_mm_set_ps1(1.0f), a.m128));
#  else
  return make_float4(1.0f / a.x, 1.0f / a.y, 1.0f / a.z, 1.0f / a.w);
#  endif
}

ccl_device_inline float4 sqrt(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_sqrt_ps(a.m128));
#  else
  return make_float4(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z), sqrtf(a.w));
#  endif
}

ccl_device_inline float4 sqr(const float4 &a)
{
  return a * a;
}

ccl_device_inline float4 cross(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return (shuffle<1, 2, 0, 0>(a) * shuffle<2, 0, 1, 0>(b)) -
         (shuffle<2, 0, 1, 0>(a) * shuffle<1, 2, 0, 0>(b));
#  else
  return make_float4(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x, 0.0f);
#  endif
}

ccl_device_inline float4 reduce_add(const float4 &a)
{
#  ifdef __KERNEL_SSE__
#    ifdef __KERNEL_SSE3__
  float4 h(_mm_hadd_ps(a.m128, a.m128));
  return float4(_mm_hadd_ps(h.m128, h.m128));
#    else
  float4 h(shuffle<1, 0, 3, 2>(a) + a);
  return shuffle<2, 3, 0, 1>(h) + h;
#    endif
#  else
  float sum = (a.x + a.y) + (a.z + a.w);
  return make_float4(sum, sum, sum, sum);
#  endif
}

ccl_device_inline float average(const float4 &a)
{
  return reduce_add(a).x * 0.25f;
}

ccl_device_inline float len(const float4 &a)
{
  return sqrtf(dot(a, a));
}

ccl_device_inline float4 normalize(const float4 &a)
{
  return a / len(a);
}

ccl_device_inline float4 safe_normalize(const float4 &a)
{
  float t = len(a);
  return (t != 0.0f) ? a / t : a;
}

ccl_device_inline float4 min(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_min_ps(a.m128, b.m128));
#  else
  return make_float4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));
#  endif
}

ccl_device_inline float4 min(const float4 &a, const float b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_min_ps(a.m128, _mm_set1_ps(b)));
#  else
  return make_float4(fminf(a.x, b), fminf(a.y, b), fminf(a.z, b), fminf(a.w, b));
#  endif
}

ccl_device_inline float4 max(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_max_ps(a.m128, b.m128));
#  else
  return make_float4(fmaxf(a.x, b.x), fmaxf(a.y, b.y), fmaxf(a.z, b.z), fmaxf(a.w, b.w));
#  endif
}

ccl_device_inline float4 max(const float4 &a, const float b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_max_ps(a.m128, _mm_set1_ps(b)));
#  else
  return make_float4(fminf(a.x, b), fminf(a.y, b), fminf(a.z, b), fminf(a.w, b));
#  endif
}

ccl_device_inline float4 clamp(const float4 &a, const float4 &mn, const float4 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float4 clamp(const float4 &a, const float mn, const float mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float4 fabs(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_and_ps(a.m128, _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff))));
#  else
  return make_float4(fabsf(a.x), fabsf(a.y), fabsf(a.z), fabsf(a.w));
#  endif
}

ccl_device_inline float4 floor(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_floor_ps(a));
#  else
  return make_float4(floorf(a.x), floorf(a.y), floorf(a.z), floorf(a.w));
#  endif
}

ccl_device_inline float4 mix(const float4 &a, const float4 &b, const float t)
{
  return a + t * (b - a);
}

#endif /* !__KERNEL_COMPUTE__*/

#ifdef __KERNEL_SSE__
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &b)
{
  return float4(_mm_castsi128_ps(
      _mm_shuffle_epi32(_mm_castps_si128(b), _MM_SHUFFLE(index_3, index_2, index_1, index_0))));
}

template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &a, const float4 &b)
{
  return float4(_mm_shuffle_ps(a.m128, b.m128, _MM_SHUFFLE(index_3, index_2, index_1, index_0)));
}

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &b)
{
  return float4(_mm_castpd_ps(_mm_movedup_pd(_mm_castps_pd(b))));
}

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &a, const float4 &b)
{
  return float4(_mm_movelh_ps(a.m128, b.m128));
}

template<> __forceinline const float4 shuffle<2, 3, 2, 3>(const float4 &a, const float4 &b)
{
  return float4(_mm_movehl_ps(b.m128, a.m128));
}

#  ifdef __KERNEL_SSE3__
template<> __forceinline const float4 shuffle<0, 0, 2, 2>(const float4 &b)
{
  return float4(_mm_moveldup_ps(b));
}

template<> __forceinline const float4 shuffle<1, 1, 3, 3>(const float4 &b)
{
  return float4(_mm_movehdup_ps(b));
}
#  endif /* __KERNEL_SSE3__ */
#endif   /* __KERNEL_SSE__ */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline float4 select(const float4 &b_false, const float4 &a_true, const int4 &mask)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_blendv_ps(b_false.m128, a_true.m128, _mm_castsi128_ps(mask.m128)));
#  else
  return make_float4((mask.x) ? a_true.x : b_false.x,
                     (mask.y) ? a_true.y : b_false.y,
                     (mask.z) ? a_true.z : b_false.z,
                     (mask.w) ? a_true.w : b_false.w);
#  endif
}

ccl_device_inline float4 reduce_min(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  float4 h = min(shuffle<1, 0, 3, 2>(a), a);
  return min(shuffle<2, 3, 0, 1>(h), h);
#  else
  return make_float4(min(min(a.x, a.y), min(a.z, a.w)));
#  endif
}

ccl_device_inline float4 reduce_max(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  float4 h = max(shuffle<1, 0, 3, 2>(a), a);
  return max(shuffle<2, 3, 0, 1>(h), h);
#  else
  return make_float4(max(max(a.x, a.y), max(a.z, a.w)));
#  endif
}

#endif /* !__KERNEL_COMPUTE__ */

ccl_device_inline float4 safe_divide_float4_float(const float4 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float4(0.0f, 0.0f, 0.0f, 0.0f);
}

ccl_device_inline float4 clamp_to_normal_f4(const float4 a)
{
  return min(max(a, 0.0f), 1.0f);
}

CCL_NAMESPACE_END

#endif

#line 426 ".kernel_util/COM_kernel_math.h"

CCL_NAMESPACE_BEGIN

#ifndef __KERNEL_OPENCL__
/* Interpolation */

template<class A, class B> A lerp(const A &a, const A &b, const B &t)
{
  return (A)(a * ((B)1 - t) + b * t);
}

#endif /* __KERNEL_OPENCL__ */

/* Triangle */
#ifndef __KERNEL_OPENCL__
ccl_device_inline float triangle_area(const float3 &v1, const float3 &v2, const float3 &v3)
#else
ccl_device_inline float triangle_area(const float3 v1, const float3 v2, const float3 v3)
#endif
{
  return len(cross(v3 - v2, v1 - v2)) * 0.5f;
}

/* Orthonormal vectors */

ccl_device_inline void make_orthonormals(const float3 N, float3 *a, float3 *b)
{
#if 0
  if (fabsf(N.y) >= 0.999f) {
    *a = make_float3(1, 0, 0);
    *b = make_float3(0, 0, 1);
    return;
  }
  if (fabsf(N.z) >= 0.999f) {
    *a = make_float3(1, 0, 0);
    *b = make_float3(0, 1, 0);
    return;
  }
#endif

  if (N.x != N.y || N.x != N.z)
    *a = make_float3(N.z - N.y, N.x - N.z, N.y - N.x);  //(1,1,1)x N
  else
    *a = make_float3(N.z - N.y, N.x + N.z, -N.y - N.x);  //(-1,1,1)x N

  *a = normalize(*a);
  *b = cross(N, *a);
}

/* Color division */

ccl_device_inline float3 safe_invert_color(const float3 a)
{
  float x, y, z;

  x = (a.x != 0.0f) ? 1.0f / a.x : 0.0f;
  y = (a.y != 0.0f) ? 1.0f / a.y : 0.0f;
  z = (a.z != 0.0f) ? 1.0f / a.z : 0.0f;

  return make_float3(x, y, z);
}

ccl_device_inline float3 safe_divide_color(const float3 a, const float3 b)
{
  float x, y, z;

  x = (b.x != 0.0f) ? a.x / b.x : 0.0f;
  y = (b.y != 0.0f) ? a.y / b.y : 0.0f;
  z = (b.z != 0.0f) ? a.z / b.z : 0.0f;

  return make_float3(x, y, z);
}

ccl_device_inline float3 safe_divide_even_color(const float3 a, const float3 b)
{
  float x, y, z;

  x = (b.x != 0.0f) ? a.x / b.x : 0.0f;
  y = (b.y != 0.0f) ? a.y / b.y : 0.0f;
  z = (b.z != 0.0f) ? a.z / b.z : 0.0f;

  /* try to get gray even if b is zero */
  if (b.x == 0.0f) {
    if (b.y == 0.0f) {
      x = z;
      y = z;
    }
    else if (b.z == 0.0f) {
      x = y;
      z = y;
    }
    else
      x = 0.5f * (y + z);
  }
  else if (b.y == 0.0f) {
    if (b.z == 0.0f) {
      y = x;
      z = x;
    }
    else
      y = 0.5f * (x + z);
  }
  else if (b.z == 0.0f) {
    z = 0.5f * (x + y);
  }

  return make_float3(x, y, z);
}

/* Rotation of point around axis and angle */

ccl_device_inline float3 rotate_around_axis(const float3 p, const float3 axis, const float angle)
{
  float costheta = cosf(angle);
  float sintheta = sinf(angle);
  float3 r;

  r.x = ((costheta + (1 - costheta) * axis.x * axis.x) * p.x) +
        (((1 - costheta) * axis.x * axis.y - axis.z * sintheta) * p.y) +
        (((1 - costheta) * axis.x * axis.z + axis.y * sintheta) * p.z);

  r.y = (((1 - costheta) * axis.x * axis.y + axis.z * sintheta) * p.x) +
        ((costheta + (1 - costheta) * axis.y * axis.y) * p.y) +
        (((1 - costheta) * axis.y * axis.z - axis.x * sintheta) * p.z);

  r.z = (((1 - costheta) * axis.x * axis.z - axis.y * sintheta) * p.x) +
        (((1 - costheta) * axis.y * axis.z + axis.x * sintheta) * p.y) +
        ((costheta + (1 - costheta) * axis.z * axis.z) * p.z);

  return r;
}

/* NaN-safe math ops */

ccl_device_inline float safe_sqrtf(const float f)
{
  return sqrtf(max(f, 0.0f));
}

ccl_device_inline float inversesqrtf(const float f)
{
  return (f > 0.0f) ? 1.0f / sqrtf(f) : 0.0f;
}

ccl_device float safe_asinf(const float a)
{
  return asinf(clamp(a, -1.0f, 1.0f));
}

ccl_device float safe_acosf(const float a)
{
  return acosf(clamp(a, -1.0f, 1.0f));
}

ccl_device float compatible_powf(const float x, const float y)
{
#ifdef __KERNEL_COMPUTE__
  if (y == 0.0f) /* x^0 -> 1, including 0^0 */
    return 1.0f;

  /* GPU pow doesn't accept negative x, do manual checks here */
  if (x < 0.0f) {
    if (fmodf(-y, 2.0f) == 0.0f)
      return powf(-x, y);
    else
      return -powf(-x, y);
  }
  else if (x == 0.0f)
    return 0.0f;
#endif
  return powf(x, y);
}

ccl_device float safe_powf(const float a, const float b)
{
  if (UNLIKELY(a < 0.0f && b != float_to_int(b)))
    return 0.0f;

  return compatible_powf(a, b);
}

ccl_device float safe_divide(const float a, const float b)
{
  return (b != 0.0f) ? a / b : 0.0f;
}

ccl_device float safe_logf(const float a, const float b)
{
  if (UNLIKELY(a <= 0.0f || b <= 0.0f))
    return 0.0f;

  return safe_divide(logf(a), logf(b));
}

ccl_device float safe_modulo(const float a, const float b)
{
  return (b != 0.0f) ? fmodf(a, b) : 0.0f;
}

ccl_device_inline float sqr(const float a)
{
  return a * a;
}

ccl_device_inline float pow20(const float a)
{
  return sqr(sqr(sqr(sqr(a)) * a));
}

ccl_device_inline float pow22(float a)
{
  return sqr(a * sqr(sqr(sqr(a)) * a));
}

ccl_device_inline float beta(float x, float y)
{
#ifndef __KERNEL_OPENCL__
  return expf(lgammaf(x) + lgammaf(y) - lgammaf(x + y));
#else
  return expf(lgamma(x) + lgamma(y) - lgamma(x + y));
#endif
}

ccl_device_inline float xor_signmask(const float x, const int y)
{
  return __int_as_float(__float_as_int(x) ^ y);
}

ccl_device float bits_to_01(const uint bits)
{
  return bits * (1.0f / (float)0xFFFFFFFF);
}

ccl_device_inline uint count_leading_zeros(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return __clz(x);
#elif defined(__KERNEL_OPENCL__)
  return clz(x);
#else
  assert(x != 0);
#  ifdef _MSC_VER
  unsigned long leading_zero = 0;
  _BitScanReverse(&leading_zero, x);
  return (31 - leading_zero);
#  else
  return __builtin_clz(x);
#  endif
#endif
}

ccl_device_inline uint count_trailing_zeros(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return (__ffs(x) - 1);
#elif defined(__KERNEL_OPENCL__)
  return (31 - count_leading_zeros(x & -x));
#else
  assert(x != 0);
#  ifdef _MSC_VER
  unsigned long ctz = 0;
  _BitScanForward(&ctz, x);
  return ctz;
#  else
  return __builtin_ctz(x);
#  endif
#endif
}

ccl_device_inline uint find_first_set(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return __ffs(x);
#elif defined(__KERNEL_OPENCL__)
  return (x != 0) ? (32 - count_leading_zeros(x & (-x))) : 0;
#else
#  ifdef _MSC_VER
  return (x != 0) ? (32 - count_leading_zeros(x & (-x))) : 0;
#  else
  return __builtin_ffs(x);
#  endif
#endif
}

/* projections */
ccl_device_inline float2 map_to_tube(const float3 co)
{
  float len, u, v;
  len = sqrtf(co.x * co.x + co.y * co.y);
  if (len > 0.0f) {
    u = (1.0f - (atan2f(co.x / len, co.y / len) / M_PI_F)) * 0.5f;
    v = (co.z + 1.0f) * 0.5f;
  }
  else {
    u = v = 0.0f;
  }
  return make_float2(u, v);
}

ccl_device_inline float2 map_to_sphere(const float3 co)
{
  float l = len(co);
  float u, v;
  if (l > 0.0f) {
    if (UNLIKELY(co.x == 0.0f && co.y == 0.0f)) {
      u = 0.0f; /* othwise domain error */
    }
    else {
      u = (1.0f - atan2f(co.x, co.y) / M_PI_F) / 2.0f;
    }
    v = 1.0f - safe_acosf(co.z / l) / M_PI_F;
  }
  else {
    u = v = 0.0f;
  }
  return make_float2(u, v);
}

/* Compares two floats.
 * Returns true if their absolute difference is smaller than abs_diff (for numbers near zero)
 * or their relative difference is less than ulp_diff ULPs.
 * Based on
 * https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
 */

ccl_device_inline float compare_floats(const float a,
                                       const float b,
                                       const float abs_diff,
                                       const int ulp_diff)
{
  if (fabsf(a - b) < abs_diff) {
    return true;
  }

  if ((a < 0.0f) != (b < 0.0f)) {
    return false;
  }

  return (abs(__float_as_int(a) - __float_as_int(b)) < ulp_diff);
}

ccl_device_inline float clamp_to_normal(const float a)
{
  return min(max(a, 0.0f), 1.0f);
}

ccl_device_inline float4 interp_f4f4(const float4 a, const float4 b, const float t)
{
  const float s = 1.0f - t;

  return s * a + t * b;
}

CCL_NAMESPACE_END

#endif

#line 4 ".kernel_util/COM_kernel_geom.h"

/* All this methods has been taken from blendlib math_geom.c file.
 * They are adapted for vectors and kernel compatibility */
CCL_NAMESPACE_BEGIN

#define KEY_LINEAR 0
#define KEY_CARDINAL 1
#define KEY_BSPLINE 2
#define KEY_CATMULL_ROM 3

ccl_device_inline float2 closest_to_line_v2(const float2 p, const float2 l1, const float2 l2)
{
  float2 u = l2 - l1;
  float2 h = p - l1;
  float lambda = dot(u, h) / dot(u, u);
  return l1 + u * lambda;
}

ccl_device_inline void key_curve_position_weights(const float t, float data[4], const int type)
{
  float t2, t3, fc;

  if (type == KEY_LINEAR) {
    data[0] = 0.0f;
    data[1] = -t + 1.0f;
    data[2] = t;
    data[3] = 0.0f;
  }
  else if (type == KEY_CARDINAL) {
    t2 = t * t;
    t3 = t2 * t;
    fc = 0.71f;

    data[0] = -fc * t3 + 2.0f * fc * t2 - fc * t;
    data[1] = (2.0f - fc) * t3 + (fc - 3.0f) * t2 + 1.0f;
    data[2] = (fc - 2.0f) * t3 + (3.0f - 2.0f * fc) * t2 + fc * t;
    data[3] = fc * t3 - fc * t2;
  }
  else if (type == KEY_BSPLINE) {
    t2 = t * t;
    t3 = t2 * t;

    data[0] = -0.16666666f * t3 + 0.5f * t2 - 0.5f * t + 0.16666666f;
    data[1] = 0.5f * t3 - t2 + 0.66666666f;
    data[2] = -0.5f * t3 + 0.5f * t2 + 0.5f * t + 0.16666666f;
    data[3] = 0.16666666f * t3;
  }
  else if (type == KEY_CATMULL_ROM) {
    t2 = t * t;
    t3 = t2 * t;
    fc = 0.5f;

    data[0] = -fc * t3 + 2.0f * fc * t2 - fc * t;
    data[1] = (2.0f - fc) * t3 + (fc - 3.0f) * t2 + 1.0f;
    data[2] = (fc - 2.0f) * t3 + (3.0f - 2.0f * fc) * t2 + fc * t;
    data[3] = fc * t3 - fc * t2;
  }
}

CCL_NAMESPACE_END

#endif

#line 6 ".kernel_util/COM_kernel_color.h"
#line 1 ".kernel_util/COM_kernel_math.h"
#ifndef __COM_KERNEL_MATH_H__
#define __COM_KERNEL_MATH_H__

/* Math
 *
 * Basic math functions on scalar and vector types. This header is used by
 * both the kernel code when compiled as C++, and other C++ non-kernel code. */

#ifndef __KERNEL_COMPUTE__
#  include <cmath>
#endif

#ifndef __KERNEL_OPENCL__
#  include <float.h>
#  include <math.h>
#  include <stdio.h>
#endif /* __KERNEL_OPENCL__ */

#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 19 ".kernel_util/COM_kernel_math.h"

CCL_NAMESPACE_BEGIN

/* Float Pi variations */

/* Division */
#ifndef M_PI_F
#  define M_PI_F (3.1415926535897932f) /* pi */
#endif
#ifndef M_PI_2_F
#  define M_PI_2_F (1.5707963267948966f) /* pi/2 */
#endif
#ifndef M_PI_4_F
#  define M_PI_4_F (0.7853981633974830f) /* pi/4 */
#endif
#ifndef M_1_PI_F
#  define M_1_PI_F (0.3183098861837067f) /* 1/pi */
#endif
#ifndef M_2_PI_F
#  define M_2_PI_F (0.6366197723675813f) /* 2/pi */
#endif
#ifndef M_1_2PI_F
#  define M_1_2PI_F (0.1591549430918953f) /* 1/(2*pi) */
#endif
#ifndef M_SQRT_PI_8_F
#  define M_SQRT_PI_8_F (0.6266570686577501f) /* sqrt(pi/8) */
#endif
#ifndef M_LN_2PI_F
#  define M_LN_2PI_F (1.8378770664093454f) /* ln(2*pi) */
#endif

/* Multiplication */
#ifndef M_2PI_F
#  define M_2PI_F (6.2831853071795864f) /* 2*pi */
#endif
#ifndef M_4PI_F
#  define M_4PI_F (12.566370614359172f) /* 4*pi */
#endif

/* Float sqrt variations */
#ifndef M_SQRT2_F
#  define M_SQRT2_F (1.4142135623730950f) /* sqrt(2) */
#endif
#ifndef M_LN2_F
#  define M_LN2_F (0.6931471805599453f) /* ln(2) */
#endif
#ifndef M_LN10_F
#  define M_LN10_F (2.3025850929940457f) /* ln(10) */
#endif

#ifndef RAD2DEGF
#  define RAD2DEGF(_rad) ((_rad) * (float)(180.0f / M_PI_F))
#endif
#ifndef DEG2RADF
#  define DEG2RADF(_deg) ((_deg) * (float)(M_PI_F / 180.0f))
#endif

/* Scalar */

#ifdef _WIN32
#  ifndef __KERNEL_OPENCL__
ccl_device_inline float fmaxf(float a, float b)
{
  return (a > b) ? a : b;
}

ccl_device_inline float fminf(float a, float b)
{
  return (a < b) ? a : b;
}
#  endif /* !__KERNEL_OPENCL__ */
#endif   /* _WIN32 */

#ifndef __KERNEL_COMPUTE__
using std::isfinite;
using std::isnan;
using std::sqrt;

ccl_device_inline int abs(const int x)
{
  return (x > 0) ? x : -x;
}

ccl_device_inline int max(const int a, const int b)
{
  return (a > b) ? a : b;
}

ccl_device_inline int min(const int a, const int b)
{
  return (a < b) ? a : b;
}

ccl_device_inline float max(const float a, const float b)
{
  return (a > b) ? a : b;
}

ccl_device_inline float min(const float a, const float b)
{
  return (a < b) ? a : b;
}
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline float fminf3(const float a, const float b, const float c)
{
  return fminf(fminf(a, b), c);
}

ccl_device_inline float fmaxf3(const float a, const float b, const float c)
{
  return fmaxf(fmaxf(a, b), c);
}

ccl_device_inline float fminf4(const float a, const float b, const float c, const float d)
{
  return fminf(fminf(a, b), fminf(c, d));
}

ccl_device_inline float fmaxf4(const float a, const float b, const float c, const float d)
{
  return fmaxf(fmaxf(a, b), fmaxf(c, d));
}

#ifndef __KERNEL_OPENCL__
/* Int/Float conversion */

ccl_device_inline int as_int(uint i)
{
  union {
    uint ui;
    int i;
  } u;
  u.ui = i;
  return u.i;
}

ccl_device_inline uint as_uint(int i)
{
  union {
    uint ui;
    int i;
  } u;
  u.i = i;
  return u.ui;
}

ccl_device_inline uint as_uint(float f)
{
  union {
    uint i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline int __float_as_int(float f)
{
  union {
    int i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline float __int_as_float(int i)
{
  union {
    int i;
    float f;
  } u;
  u.i = i;
  return u.f;
}

ccl_device_inline uint __float_as_uint(float f)
{
  union {
    uint i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline float __uint_as_float(uint i)
{
  union {
    uint i;
    float f;
  } u;
  u.i = i;
  return u.f;
}

ccl_device_inline int4 __float4_as_int4(float4 f)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(f.m128));
#  else
  return make_int4(
      __float_as_int(f.x), __float_as_int(f.y), __float_as_int(f.z), __float_as_int(f.w));
#  endif
}

ccl_device_inline float4 __int4_as_float4(int4 i)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_castsi128_ps(i.m128));
#  else
  return make_float4(
      __int_as_float(i.x), __int_as_float(i.y), __int_as_float(i.z), __int_as_float(i.w));
#  endif
}
#endif /* __KERNEL_OPENCL__ */

/* Versions of functions which are safe for fast math. */
ccl_device_inline bool isnan_safe(const float f)
{
  unsigned int x = __float_as_uint(f);
  return (x << 1) > 0xff000000u;
}

ccl_device_inline bool isfinite_safe(const float f)
{
  /* By IEEE 754 rule, 2*Inf equals Inf */
  unsigned int x = __float_as_uint(f);
  return (f == f) && (x == 0 || x == (1u << 31) || (f != 2.0f * f)) && !((x << 1) > 0xff000000u);
}

ccl_device_inline float ensure_finite(const float v)
{
  return isfinite_safe(v) ? v : 0.0f;
}

#ifndef __KERNEL_OPENCL__
ccl_device_inline int clamp(const int a, const int mn, const int mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float clamp(const float a, const float mn, const float mx)
{
  return fminf(fmaxf(a, mn), mx);
}

ccl_device_inline float mix(const float a, const float b, const float t)
{
  return a + t * (b - a);
}

ccl_device_inline float smoothstep(const float edge0, const float edge1, const float x)
{
  float result;
  if (x < edge0)
    result = 0.0f;
  else if (x >= edge1)
    result = 1.0f;
  else {
    float t = (x - edge0) / (edge1 - edge0);
    result = (3.0f - 2.0f * t) * (t * t);
  }
  return result;
}

#endif /* __KERNEL_OPENCL__ */

#ifndef __KERNEL_CUDA__
ccl_device_inline float saturate(const float a)
{
  return clamp(a, 0.0f, 1.0f);
}
#endif /* __KERNEL_CUDA__ */

ccl_device_inline int float_to_int(const float f)
{
  return (int)f;
}

ccl_device_inline int floor_to_int(const float f)
{
  return float_to_int(floorf(f));
}

ccl_device_inline int quick_floor_to_int(const float x)
{
  return float_to_int(x) - ((x < 0) ? 1 : 0);
}

ccl_device_inline float floorfrac(const float x, int *i)
{
  *i = quick_floor_to_int(x);
  return x - *i;
}

ccl_device_inline int ceil_to_int(const float f)
{
  return float_to_int(ceilf(f));
}

ccl_device_inline float fractf(const float x)
{
  return x - floorf(x);
}

/* Adapted from godotengine math_funcs.h. */
ccl_device_inline float wrapf(const float value, const float max, const float min)
{
  float range = max - min;
  return (range != 0.0f) ? value - (range * floorf((value - min) / range)) : min;
}

ccl_device_inline float pingpongf(const float a, const float b)
{
  return (b != 0.0f) ? fabsf(fractf((a - b) / (b * 2.0f)) * b * 2.0f - b) : 0.0f;
}

ccl_device_inline float smoothminf(const float a, const float b, const float k)
{
  if (k != 0.0f) {
    float h = fmaxf(k - fabsf(a - b), 0.0f) / k;
    return fminf(a, b) - h * h * h * k * (1.0f / 6.0f);
  }
  else {
    return fminf(a, b);
  }
}

ccl_device_inline float signf(const float f)
{
  return (f < 0.0f) ? -1.0f : 1.0f;
}

ccl_device_inline float nonzerof(const float f, const float eps)
{
  if (fabsf(f) < eps)
    return signf(f) * eps;
  else
    return f;
}

/* Signum function testing for zero. Matches GLSL and OSL functions. */
ccl_device_inline float compatible_signf(const float f)
{
  if (f == 0.0f) {
    return 0.0f;
  }
  else {
    return signf(f);
  }
}

ccl_device_inline float smoothstepf(const float f)
{
  float ff = f * f;
  return (3.0f * ff - 2.0f * ff * f);
}

ccl_device_inline int mod(const int x, const int m)
{
  return (x % m + m) % m;
}

ccl_device_inline float3 float2_to_float3(const float2 a)
{
  return make_float3(a.x, a.y, 0.0f);
}

ccl_device_inline float3 float4_to_float3(const float4 a)
{
  return make_float3(a.x, a.y, a.z);
}

ccl_device_inline float4 float3_to_float4(const float3 a)
{
  return make_float4(a.x, a.y, a.z, 1.0f);
}

ccl_device_inline float inverse_lerp(const float a, const float b, const float x)
{
  return (x - a) / (b - a);
}

/* Cubic interpolation between b and c, a and d are the previous and next point. */
ccl_device_inline float cubic_interp(
    const float a, const float b, const float c, const float d, const float x)
{
  return 0.5f *
             (((d + 3.0f * (b - c) - a) * x + (2.0f * a - 5.0f * b + 4.0f * c - d)) * x +
              (c - a)) *
             x +
         b;
}

CCL_NAMESPACE_END

#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 418 ".kernel_util/COM_kernel_math.h"

#line 1 ".kernel_util/COM_kernel_math_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT2_H__
#define __COM_KERNEL_MATH_INT2_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline bool operator==(const int2 a, const int2 b);
ccl_device_inline int2 operator+(const int2 &a, const int2 &b);
ccl_device_inline int2 operator+=(int2 &a, const int2 &b);
ccl_device_inline int2 operator-(const int2 &a, const int2 &b);
ccl_device_inline int2 operator*(const int2 &a, const int2 &b);
ccl_device_inline int2 operator/(const int2 &a, const int2 &b);
#endif /* !__KERNEL_OPENCL__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline bool operator==(const int2 a, const int2 b)
{
  return (a.x == b.x && a.y == b.y);
}

ccl_device_inline int2 operator+(const int2 &a, const int2 &b)
{
  return make_int2(a.x + b.x, a.y + b.y);
}

ccl_device_inline int2 operator+=(int2 &a, const int2 &b)
{
  return a = a + b;
}

ccl_device_inline int2 operator-(const int2 &a, const int2 &b)
{
  return make_int2(a.x - b.x, a.y - b.y);
}

ccl_device_inline int2 operator*(const int2 &a, const int2 &b)
{
  return make_int2(a.x * b.x, a.y * b.y);
}

ccl_device_inline int2 operator/(const int2 &a, const int2 &b)
{
  return make_int2(a.x / b.x, a.y / b.y);
}
#endif /* !__KERNEL_OPENCL__ */

CCL_NAMESPACE_END

#endif

#line 420 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT3_H__
#define __COM_KERNEL_MATH_INT3_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline int3 min(int3 a, int3 b);
ccl_device_inline int3 max(int3 a, int3 b);
ccl_device_inline int3 clamp(const int3 &a, int mn, int mx);
ccl_device_inline int3 clamp(const int3 &a, int3 &mn, int mx);
#endif /* !__KERNEL_OPENCL__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline int3 min(int3 a, int3 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int3(_mm_min_epi32(a.m128, b.m128));
#  else
  return make_int3(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));
#  endif
}

ccl_device_inline int3 max(int3 a, int3 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int3(_mm_max_epi32(a.m128, b.m128));
#  else
  return make_int3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));
#  endif
}

ccl_device_inline int3 clamp(const int3 &a, int mn, int mx)
{
#  ifdef __KERNEL_SSE__
  return min(max(a, make_int3_1(mn)), make_int3_1(mx));
#  else
  return make_int3(clamp(a.x, mn, mx), clamp(a.y, mn, mx), clamp(a.z, mn, mx));
#  endif
}

ccl_device_inline int3 clamp(const int3 &a, int3 &mn, int mx)
{
#  ifdef __KERNEL_SSE__
  return min(max(a, mn), make_int3_1(mx));
#  else
  return make_int3(clamp(a.x, mn.x, mx), clamp(a.y, mn.y, mx), clamp(a.z, mn.z, mx));
#  endif
}

ccl_device_inline bool operator==(const int3 &a, const int3 &b)
{
  return a.x == b.x && a.y == b.y && a.z == b.z;
}

ccl_device_inline bool operator!=(const int3 &a, const int3 &b)
{
  return !(a == b);
}

ccl_device_inline bool operator<(const int3 &a, const int3 &b)
{
  return a.x < b.x && a.y < b.y && a.z < b.z;
}

ccl_device_inline int3 operator+(const int3 &a, const int3 &b)
{
#  ifdef __KERNEL_SSE__
  return int3(_mm_add_epi32(a.m128, b.m128));
#  else
  return make_int3(a.x + b.x, a.y + b.y, a.z + b.z);
#  endif
}

ccl_device_inline int3 operator-(const int3 &a, const int3 &b)
{
#  ifdef __KERNEL_SSE__
  return int3(_mm_sub_epi32(a.m128, b.m128));
#  else
  return make_int3(a.x - b.x, a.y - b.y, a.z - b.z);
#  endif
}
#endif /* !__KERNEL_OPENCL__ */

CCL_NAMESPACE_END

#endif /* __COM_kernel_MATH_INT3_H__ */

#line 421 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT4_H__
#define __COM_KERNEL_MATH_INT4_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline int4 operator+(const int4 &a, const int4 &b);
ccl_device_inline int4 operator+=(int4 &a, const int4 &b);
ccl_device_inline int4 operator>>(const int4 &a, int i);
ccl_device_inline int4 operator<<(const int4 &a, int i);
ccl_device_inline int4 operator<(const int4 &a, const int4 &b);
ccl_device_inline int4 operator>=(const int4 &a, const int4 &b);
ccl_device_inline int4 operator&(const int4 &a, const int4 &b);
ccl_device_inline int4 min(int4 a, int4 b);
ccl_device_inline int4 max(int4 a, int4 b);
ccl_device_inline int4 clamp(const int4 &a, const int4 &mn, const int4 &mx);
ccl_device_inline int4 select(const int4 &mask, const int4 &a, const int4 &b);
#endif /* __KERNEL_COMPUTE__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline int4 operator+(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_add_epi32(a.m128, b.m128));
#  else
  return make_int4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
#  endif
}

ccl_device_inline int4 operator+=(int4 &a, const int4 &b)
{
  return a = a + b;
}

ccl_device_inline int4 operator>>(const int4 &a, int i)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_srai_epi32(a.m128, i));
#  else
  return make_int4(a.x >> i, a.y >> i, a.z >> i, a.w >> i);
#  endif
}

ccl_device_inline int4 operator<<(const int4 &a, int i)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_slli_epi32(a.m128, i));
#  else
  return make_int4(a.x << i, a.y << i, a.z << i, a.w << i);
#  endif
}

ccl_device_inline int4 operator<(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_cmplt_epi32(a.m128, b.m128));
#  else
  return make_int4(a.x < b.x, a.y < b.y, a.z < b.z, a.w < b.w);
#  endif
}

ccl_device_inline int4 operator>=(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_xor_si128(_mm_set1_epi32(0xffffffff), _mm_cmplt_epi32(a.m128, b.m128)));
#  else
  return make_int4(a.x >= b.x, a.y >= b.y, a.z >= b.z, a.w >= b.w);
#  endif
}

ccl_device_inline int4 operator&(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_and_si128(a.m128, b.m128));
#  else
  return make_int4(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
#  endif
}

ccl_device_inline int4 min(int4 a, int4 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int4(_mm_min_epi32(a.m128, b.m128));
#  else
  return make_int4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));
#  endif
}

ccl_device_inline int4 max(int4 a, int4 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int4(_mm_max_epi32(a.m128, b.m128));
#  else
  return make_int4(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z), max(a.w, b.w));
#  endif
}

ccl_device_inline int4 clamp(const int4 &a, const int4 &mn, const int4 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline int4 select(const int4 &mask, const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  const __m128 m = _mm_cvtepi32_ps(mask);
  /* TODO(sergey): avoid cvt. */
  return int4(_mm_castps_si128(
      _mm_or_ps(_mm_and_ps(m, _mm_castsi128_ps(a)), _mm_andnot_ps(m, _mm_castsi128_ps(b)))));
#  else
  return make_int4(
      (mask.x) ? a.x : b.x, (mask.y) ? a.y : b.y, (mask.z) ? a.z : b.z, (mask.w) ? a.w : b.w);
#  endif
}

ccl_device_inline int4 load_int4(const int *v)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_loadu_si128((__m128i *)v));
#  else
  return make_int4(v[0], v[1], v[2], v[3]);
#  endif
}
#endif /* __KERNEL_COMPUTE__ */

CCL_NAMESPACE_END

#endif

#line 422 ".kernel_util/COM_kernel_math.h"

#line 1 ".kernel_util/COM_kernel_math_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT2_H__
#define __COM_KERNEL_MATH_FLOAT2_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float2 operator-(const float2 &a);
ccl_device_inline float2 operator*(const float2 &a, const float2 &b);
ccl_device_inline float2 operator*(const float2 &a, float f);
ccl_device_inline float2 operator*(float f, const float2 &a);
ccl_device_inline float2 operator/(float f, const float2 &a);
ccl_device_inline float2 operator/(const float2 &a, float f);
ccl_device_inline float2 operator/(const float2 &a, const float2 &b);
ccl_device_inline float2 operator+(const float2 &a, const float f);
ccl_device_inline float2 operator+(const float2 &a, const float2 &b);
ccl_device_inline float2 operator-(const float2 &a, const float f);
ccl_device_inline float2 operator-(const float2 &a, const float2 &b);
ccl_device_inline float2 operator+=(float2 &a, const float2 &b);
ccl_device_inline float2 operator*=(float2 &a, const float2 &b);
ccl_device_inline float2 operator*=(float2 &a, float f);
ccl_device_inline float2 operator/=(float2 &a, const float2 &b);
ccl_device_inline float2 operator/=(float2 &a, float f);

ccl_device_inline bool operator==(const float2 &a, const float2 &b);
ccl_device_inline bool operator!=(const float2 &a, const float2 &b);

ccl_device_inline float average(const float2 &a);
ccl_device_inline float distance(const float2 &a, const float2 &b);
ccl_device_inline float dot(const float2 &a, const float2 &b);
ccl_device_inline float cross(const float2 &a, const float2 &b);
ccl_device_inline float len(const float2 &a);
ccl_device_inline float2 normalize(const float2 &a);
ccl_device_inline float2 normalize_len(const float2 &a, float *t);
ccl_device_inline float2 safe_normalize(const float2 &a);
ccl_device_inline float2 min(const float2 &a, const float2 &b);
ccl_device_inline float2 max(const float2 &a, const float2 &b);
ccl_device_inline float2 clamp(const float2 &a, const float2 &mn, const float2 &mx);
ccl_device_inline float2 fabs(const float2 &a);
ccl_device_inline float2 as_float2(const float4 &a);
ccl_device_inline float2 interp(const float2 &a, const float2 &b, float t);
ccl_device_inline float2 floor(const float2 &a);
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float2 safe_divide_float2_float(const float2 a, const float b);

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float2 operator-(const float2 &a)
{
  return make_float2(-a.x, -a.y);
}

ccl_device_inline float2 operator*(const float2 &a, const float2 &b)
{
  return make_float2(a.x * b.x, a.y * b.y);
}

ccl_device_inline float2 operator*(const float2 &a, float f)
{
  return make_float2(a.x * f, a.y * f);
}

ccl_device_inline float2 operator*(float f, const float2 &a)
{
  return make_float2(a.x * f, a.y * f);
}

ccl_device_inline float2 operator/(float f, const float2 &a)
{
  return make_float2(f / a.x, f / a.y);
}

ccl_device_inline float2 operator/(const float2 &a, float f)
{
  float invf = 1.0f / f;
  return make_float2(a.x * invf, a.y * invf);
}

ccl_device_inline float2 operator/(const float2 &a, const float2 &b)
{
  return make_float2(a.x / b.x, a.y / b.y);
}

ccl_device_inline float2 operator+(const float2 &a, const float f)
{
  return a + make_float2(f, f);
}

ccl_device_inline float2 operator+(const float2 &a, const float2 &b)
{
  return make_float2(a.x + b.x, a.y + b.y);
}

ccl_device_inline float2 operator-(const float2 &a, const float f)
{
  return a - make_float2(f, f);
}

ccl_device_inline float2 operator-(const float2 &a, const float2 &b)
{
  return make_float2(a.x - b.x, a.y - b.y);
}

ccl_device_inline float2 operator+=(float2 &a, const float2 &b)
{
  return a = a + b;
}

ccl_device_inline float2 operator*=(float2 &a, const float2 &b)
{
  return a = a * b;
}

ccl_device_inline float2 operator*=(float2 &a, float f)
{
  return a = a * f;
}

ccl_device_inline float2 operator/=(float2 &a, const float2 &b)
{
  return a = a / b;
}

ccl_device_inline float2 operator/=(float2 &a, float f)
{
  float invf = 1.0f / f;
  return a = a * invf;
}

ccl_device_inline bool operator==(const float2 &a, const float2 &b)
{
  return (a.x == b.x && a.y == b.y);
}

ccl_device_inline bool operator!=(const float2 &a, const float2 &b)
{
  return !(a == b);
}

ccl_device_inline float average(const float2 &a)
{
  return (a.x + a.y) * (1.0f / 2.0f);
}

ccl_device_inline float distance(const float2 &a, const float2 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float2 &a, const float2 &b)
{
  return a.x * b.x + a.y * b.y;
}

ccl_device_inline float cross(const float2 &a, const float2 &b)
{
  return (a.x * b.y - a.y * b.x);
}

ccl_device_inline float len(const float2 &a)
{
  return sqrtf(dot(a, a));
}

ccl_device_inline float2 normalize(const float2 &a)
{
  return a / len(a);
}

ccl_device_inline float2 normalize_len(const float2 &a, float *t)
{
  *t = len(a);
  return a / (*t);
}

ccl_device_inline float2 safe_normalize(const float2 &a)
{
  float t = len(a);
  return (t != 0.0f) ? a / t : a;
}

ccl_device_inline float2 min(const float2 &a, const float2 &b)
{
  return make_float2(fminf(a.x, b.x), fminf(a.y, b.y));
}

ccl_device_inline float2 max(const float2 &a, const float2 &b)
{
  return make_float2(fmaxf(a.x, b.x), fmaxf(a.y, b.y));
}

ccl_device_inline float2 clamp(const float2 &a, const float2 &mn, const float2 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float2 fabs(const float2 &a)
{
  return make_float2(fabsf(a.x), fabsf(a.y));
}

ccl_device_inline float2 as_float2(const float4 &a)
{
  return make_float2(a.x, a.y);
}

ccl_device_inline float2 interp(const float2 &a, const float2 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float2 mix(const float2 &a, const float2 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float2 floor(const float2 &a)
{
  return make_float2(floorf(a.x), floorf(a.y));
}

#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float2 safe_divide_float2_float(const float2 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float2(0.0f, 0.0f);
}

CCL_NAMESPACE_END

#endif

#line 424 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT3_H__
#define __COM_KERNEL_MATH_FLOAT3_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float3 operator-(const float3 &a);
ccl_device_inline float3 operator*(const float3 &a, const float3 &b);
ccl_device_inline float3 operator*(const float3 &a, const float f);
ccl_device_inline float3 operator*(const float f, const float3 &a);
ccl_device_inline float3 operator/(const float f, const float3 &a);
ccl_device_inline float3 operator/(const float3 &a, const float f);
ccl_device_inline float3 operator/(const float3 &a, const float3 &b);
ccl_device_inline float3 operator+(const float3 &a, const float f);
ccl_device_inline float3 operator+(const float3 &a, const float3 &b);
ccl_device_inline float3 operator-(const float3 &a, const float f);
ccl_device_inline float3 operator-(const float3 &a, const float3 &b);
ccl_device_inline float3 operator+=(float3 &a, const float3 &b);
ccl_device_inline float3 operator-=(float3 &a, const float3 &b);
ccl_device_inline float3 operator*=(float3 &a, const float3 &b);
ccl_device_inline float3 operator*=(float3 &a, float f);
ccl_device_inline float3 operator/=(float3 &a, const float3 &b);
ccl_device_inline float3 operator/=(float3 &a, float f);

ccl_device_inline bool operator==(const float3 &a, const float3 &b);
ccl_device_inline bool operator!=(const float3 &a, const float3 &b);

ccl_device_inline float distance(const float3 &a, const float3 &b);
ccl_device_inline float dot(const float3 &a, const float3 &b);
ccl_device_inline float dot_xy(const float3 &a, const float3 &b);
ccl_device_inline float3 cross(const float3 &a, const float3 &b);
ccl_device_inline float3 normalize(const float3 &a);
ccl_device_inline float3 min(const float3 &a, const float3 &b);
ccl_device_inline float3 max(const float3 &a, const float3 &b);
ccl_device_inline float3 clamp(const float3 &a, const float3 &mn, const float3 &mx);
ccl_device_inline float3 fabs(const float3 &a);
ccl_device_inline float3 mix(const float3 &a, const float3 &b, float t);
ccl_device_inline float3 rcp(const float3 &a);
ccl_device_inline float3 sqrt(const float3 &a);
ccl_device_inline float3 floor(const float3 &a);
ccl_device_inline float3 ceil(const float3 &a);
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float min3(float3 a);
ccl_device_inline float max3(float3 a);
ccl_device_inline float len(const float3 a);
ccl_device_inline float len_squared(const float3 a);

ccl_device_inline float3 reflect(const float3 incident, const float3 normal);
ccl_device_inline float3 project(const float3 v, const float3 v_proj);

ccl_device_inline float3 saturate3(float3 a);
ccl_device_inline float3 safe_normalize(const float3 a);
ccl_device_inline float3 normalize_len(const float3 a, float *t);
ccl_device_inline float3 safe_normalize_len(const float3 a, float *t);
ccl_device_inline float3 safe_divide_float3_float3(const float3 a, const float3 b);
ccl_device_inline float3 safe_divide_float3_float(const float3 a, const float b);
ccl_device_inline float3 interp(float3 a, float3 b, float t);
ccl_device_inline float3 sqr3(float3 a);
ccl_device_inline float reduce_add(const float3 a);
ccl_device_inline float average(const float3 a);
ccl_device_inline bool isequal_float3(const float3 a, const float3 b);

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float3 operator-(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_xor_ps(a.m128, _mm_castsi128_ps(_mm_set1_epi32(0x80000000))));
#  else
  return make_float3(-a.x, -a.y, -a.z);
#  endif
}

ccl_device_inline float3 operator*(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_mul_ps(a.m128, b.m128));
#  else
  return make_float3(a.x * b.x, a.y * b.y, a.z * b.z);
#  endif
}

ccl_device_inline float3 operator*(const float3 &a, const float f)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_mul_ps(a.m128, _mm_set1_ps(f)));
#  else
  return make_float3(a.x * f, a.y * f, a.z * f);
#  endif
}

ccl_device_inline float3 operator*(const float f, const float3 &a)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_mul_ps(_mm_set1_ps(f), a.m128));
#  else
  return make_float3(a.x * f, a.y * f, a.z * f);
#  endif
}

ccl_device_inline float3 operator/(const float f, const float3 &a)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_div_ps(_mm_set1_ps(f), a.m128));
#  else
  return make_float3(f / a.x, f / a.y, f / a.z);
#  endif
}

ccl_device_inline float3 operator/(const float3 &a, const float f)
{
  float invf = 1.0f / f;
  return a * invf;
}

ccl_device_inline float3 operator/(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_div_ps(a.m128, b.m128));
#  else
  return make_float3(a.x / b.x, a.y / b.y, a.z / b.z);
#  endif
}

ccl_device_inline float3 operator+(const float3 &a, const float f)
{
  return a + make_float3(f, f, f);
}

ccl_device_inline float3 operator+(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_add_ps(a.m128, b.m128));
#  else
  return make_float3(a.x + b.x, a.y + b.y, a.z + b.z);
#  endif
}

ccl_device_inline float3 operator-(const float3 &a, const float f)
{
  return a - make_float3(f, f, f);
}

ccl_device_inline float3 operator-(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_sub_ps(a.m128, b.m128));
#  else
  return make_float3(a.x - b.x, a.y - b.y, a.z - b.z);
#  endif
}

ccl_device_inline float3 operator+=(float3 &a, const float3 &b)
{
  return a = a + b;
}

ccl_device_inline float3 operator-=(float3 &a, const float3 &b)
{
  return a = a - b;
}

ccl_device_inline float3 operator*=(float3 &a, const float3 &b)
{
  return a = a * b;
}

ccl_device_inline float3 operator*=(float3 &a, float f)
{
  return a = a * f;
}

ccl_device_inline float3 operator/=(float3 &a, const float3 &b)
{
  return a = a / b;
}

ccl_device_inline float3 operator/=(float3 &a, float f)
{
  float invf = 1.0f / f;
  return a = a * invf;
}

ccl_device_inline bool operator==(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return (_mm_movemask_ps(_mm_cmpeq_ps(a.m128, b.m128)) & 7) == 7;
#  else
  return (a.x == b.x && a.y == b.y && a.z == b.z);
#  endif
}

ccl_device_inline bool operator!=(const float3 &a, const float3 &b)
{
  return !(a == b);
}

ccl_device_inline float distance(const float3 &a, const float3 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_dp_ps(a, b, 0x7F));
#  else
  return a.x * b.x + a.y * b.y + a.z * b.z;
#  endif
}

ccl_device_inline float dot_xy(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_hadd_ps(_mm_mul_ps(a, b), b));
#  else
  return a.x * b.x + a.y * b.y;
#  endif
}

ccl_device_inline float3 cross(const float3 &a, const float3 &b)
{
  float3 r = make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
  return r;
}

ccl_device_inline float3 normalize(const float3 &a)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  __m128 norm = _mm_sqrt_ps(_mm_dp_ps(a.m128, a.m128, 0x7F));
  return float3(_mm_div_ps(a.m128, norm));
#  else
  return a / len(a);
#  endif
}

ccl_device_inline float3 min(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_min_ps(a.m128, b.m128));
#  else
  return make_float3(fminf(a.x, b.x), fminf(a.y, b.y), fminf(a.z, b.z));
#  endif
}

ccl_device_inline float3 max(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_max_ps(a.m128, b.m128));
#  else
  return make_float3(fmaxf(a.x, b.x), fmaxf(a.y, b.y), fmaxf(a.z, b.z));
#  endif
}

ccl_device_inline float3 clamp(const float3 &a, const float3 &mn, const float3 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float3 fabs(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  __m128 mask = _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff));
  return float3(_mm_and_ps(a.m128, mask));
#  else
  return make_float3(fabsf(a.x), fabsf(a.y), fabsf(a.z));
#  endif
}

ccl_device_inline float3 sqrt(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_sqrt_ps(a));
#  else
  return make_float3(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z));
#  endif
}

ccl_device_inline float3 floor(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_floor_ps(a));
#  else
  return make_float3(floorf(a.x), floorf(a.y), floorf(a.z));
#  endif
}

ccl_device_inline float3 ceil(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_ceil_ps(a));
#  else
  return make_float3(ceilf(a.x), ceilf(a.y), ceilf(a.z));
#  endif
}

ccl_device_inline float3 mix(const float3 &a, const float3 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float3 rcp(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  /* Don't use _mm_rcp_ps due to poor precision. */
  return float3(_mm_div_ps(_mm_set_ps1(1.0f), a.m128));
#  else
  return make_float3(1.0f / a.x, 1.0f / a.y, 1.0f / a.z);
#  endif
}
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float min3(const float3 a)
{
  return min(min(a.x, a.y), a.z);
}

ccl_device_inline float max3(const float3 a)
{
  return max(max(a.x, a.y), a.z);
}

ccl_device_inline float len(const float3 a)
{
#if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_sqrt_ss(_mm_dp_ps(a.m128, a.m128, 0x7F)));
#else
  return sqrtf(dot(a, a));
#endif
}

ccl_device_inline float len_squared(const float3 a)
{
  return dot(a, a);
}

ccl_device_inline float3 reflect(const float3 incident, const float3 normal)
{
  float3 unit_normal = normalize(normal);
  return incident - 2.0f * unit_normal * dot(incident, unit_normal);
}

ccl_device_inline float3 project(const float3 v, const float3 v_proj)
{
  float len_squared = dot(v_proj, v_proj);
  return (len_squared != 0.0f) ? (dot(v, v_proj) / len_squared) * v_proj :
                                 make_float3(0.0f, 0.0f, 0.0f);
}

ccl_device_inline float3 saturate3(const float3 a)
{
  return make_float3(saturate(a.x), saturate(a.y), saturate(a.z));
}

ccl_device_inline float3 normalize_len(const float3 a, float *t)
{
  *t = len(a);
  float x = 1.0f / *t;
  return a * x;
}

ccl_device_inline float3 safe_normalize(const float3 a)
{
  float t = len(a);
  return (t != 0.0f) ? a * (1.0f / t) : a;
}

ccl_device_inline float3 safe_normalize_len(const float3 a, float *t)
{
  *t = len(a);
  return (*t != 0.0f) ? a / (*t) : a;
}

ccl_device_inline float3 safe_divide_float3_float3(const float3 a, const float3 b)
{
  return make_float3((b.x != 0.0f) ? a.x / b.x : 0.0f,
                     (b.y != 0.0f) ? a.y / b.y : 0.0f,
                     (b.z != 0.0f) ? a.z / b.z : 0.0f);
}

ccl_device_inline float3 safe_divide_float3_float(const float3 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float3(0.0f, 0.0f, 0.0f);
}

ccl_device_inline float3 interp(const float3 a, const float3 b, const float t)
{
  return a + t * (b - a);
}

ccl_device_inline float3 sqr3(const float3 a)
{
  return a * a;
}

ccl_device_inline float reduce_add(const float3 a)
{
  return (a.x + a.y + a.z);
}

ccl_device_inline float average(const float3 a)
{
  return reduce_add(a) * (1.0f / 3.0f);
}

ccl_device_inline bool isequal_float3(const float3 a, const float3 b)
{
#ifdef __KERNEL_OPENCL__
  return all(a == b);
#else
  return a == b;
#endif
}

ccl_device_inline float3 pow3(const float3 v, const float e)
{
  return make_float3(powf(v.x, e), powf(v.y, e), powf(v.z, e));
}

ccl_device_inline float3 exp3(const float3 v)
{
  return make_float3(expf(v.x), expf(v.y), expf(v.z));
}

ccl_device_inline float3 log3(const float3 v)
{
  return make_float3(logf(v.x), logf(v.y), logf(v.z));
}

ccl_device_inline int3 quick_floor_to_int3(const float3 a)
{
#ifdef __KERNEL_SSE__
  int3 b = int3(_mm_cvttps_epi32(a.m128));
  int3 isneg = int3(_mm_castps_si128(_mm_cmplt_ps(a.m128, _mm_set_ps1(0.0f))));
  /* Unsaturated add 0xffffffff is the same as subtract -1. */
  return b + isneg;
#else
  return make_int3(quick_floor_to_int(a.x), quick_floor_to_int(a.y), quick_floor_to_int(a.z));
#endif
}

ccl_device_inline bool isfinite3_safe(const float3 v)
{
  return isfinite_safe(v.x) && isfinite_safe(v.y) && isfinite_safe(v.z);
}

ccl_device_inline float3 ensure_finite3(float3 v)
{
  if (!isfinite_safe(v.x))
    v.x = 0.0f;
  if (!isfinite_safe(v.y))
    v.y = 0.0f;
  if (!isfinite_safe(v.z))
    v.z = 0.0f;
  return v;
}

CCL_NAMESPACE_END

#endif

#line 425 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT4_H__
#define __COM_KERNEL_MATH_FLOAT4_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float4 operator-(const float4 &a);
ccl_device_inline float4 operator*(const float4 &a, const float4 &b);
ccl_device_inline float4 operator*(const float4 &a, const float f);
ccl_device_inline float4 operator*(const float f, const float4 &a);
ccl_device_inline float4 operator/(const float4 &a, float f);
ccl_device_inline float4 operator/(const float f, const float4 &a);
ccl_device_inline float4 operator/(const float4 &a, const float4 &b);
ccl_device_inline float4 operator+(const float4 &a, const float f);
ccl_device_inline float4 operator+(const float f, const float4 &a);
ccl_device_inline float4 operator+(const float4 &a, const float4 &b);
ccl_device_inline float4 operator-(const float4 &a, const float f);
ccl_device_inline float4 operator-(const float f, const float4 &a);
ccl_device_inline float4 operator-(const float4 &a, const float4 &b);
ccl_device_inline float4 operator+=(float4 &a, const float4 &b);
ccl_device_inline float4 operator*=(float4 &a, const float4 &b);
ccl_device_inline float4 operator*=(float4 &a, const float f);
ccl_device_inline float4 operator/=(float4 &a, const float f);

ccl_device_inline int4 operator<(const float4 &a, const float4 &b);
ccl_device_inline int4 operator>(const float4 &a, const float4 &b);
ccl_device_inline int4 operator>=(const float4 &a, const float4 &b);
ccl_device_inline int4 operator<=(const float4 &a, const float4 &b);
ccl_device_inline int4 operator==(const float4 &a, const float4 &b);
ccl_device_inline int4 operator!=(const float4 &a, const float4 &b);

ccl_device_inline float distance(const float4 &a, const float4 &b);
ccl_device_inline float dot(const float4 &a, const float4 &b);
ccl_device_inline float len_squared(const float4 &a);
ccl_device_inline float4 rcp(const float4 &a);
ccl_device_inline float4 sqrt(const float4 &a);
ccl_device_inline float4 sqr(const float4 &a);
ccl_device_inline float4 cross(const float4 &a, const float4 &b);
ccl_device_inline float average(const float4 &a);
ccl_device_inline float len(const float4 &a);
ccl_device_inline float4 normalize(const float4 &a);
ccl_device_inline float4 safe_normalize(const float4 &a);
ccl_device_inline float4 min(const float4 &a, const float4 &b);
ccl_device_inline float4 min(const float4 &a, const float b);
ccl_device_inline float4 max(const float4 &a, const float4 &b);
ccl_device_inline float4 max(const float4 &a, const float b);
ccl_device_inline float4 clamp(const float4 &a, const float4 &mn, const float4 &mx);
ccl_device_inline float4 clamp(const float4 &a, const float mn, const float mx);
ccl_device_inline float4 fabs(const float4 &a);
ccl_device_inline float4 floor(const float4 &a);
ccl_device_inline float4 mix(const float4 &a, const float4 &b, const float t);
#endif /* !__KERNEL_OPENCL__*/

ccl_device_inline float4 safe_divide_float4_float(const float4 a, const float b);
ccl_device_inline float4 clamp_to_normal_f4(const float4 a);

#ifdef __KERNEL_SSE__
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &b);
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &a, const float4 &b);

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &b);

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &a, const float4 &b);
template<> __forceinline const float4 shuffle<2, 3, 2, 3>(const float4 &a, const float4 &b);

#  ifdef __KERNEL_SSE3__
template<> __forceinline const float4 shuffle<0, 0, 2, 2>(const float4 &b);
template<> __forceinline const float4 shuffle<1, 1, 3, 3>(const float4 &b);
#  endif
#endif /* __KERNEL_SSE__ */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline float4 select(const float4 &b_false, const float4 &a_true, const int4 &mask);
ccl_device_inline float4 reduce_min(const float4 &a);
ccl_device_inline float4 reduce_max(const float4 &a);
ccl_device_inline float4 reduce_add(const float4 &a);
#endif /* !__KERNEL_COMPUTE__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float4 operator-(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  __m128 mask = _mm_castsi128_ps(_mm_set1_epi32(0x80000000));
  return float4(_mm_xor_ps(a.m128, mask));
#  else
  return make_float4(-a.x, -a.y, -a.z, -a.w);
#  endif
}

ccl_device_inline float4 operator*(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_mul_ps(a.m128, b.m128));
#  else
  return make_float4(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
#  endif
}

ccl_device_inline float4 operator*(const float4 &a, const float f)
{
#  if defined(__KERNEL_SSE__)
  return a * make_float4_1(f);
#  else
  return make_float4(a.x * f, a.y * f, a.z * f, a.w * f);
#  endif
}

ccl_device_inline float4 operator*(const float f, const float4 &a)
{
  return a * f;
}

ccl_device_inline float4 operator/(const float4 &a, const float f)
{
  return a * (1.0f / f);
}

ccl_device_inline float4 operator/(const float f, const float4 &a)
{
  return make_float4_1(f) / a;
}
ccl_device_inline float4 operator/(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_div_ps(a.m128, b.m128));
#  else
  return make_float4(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
#  endif
}

ccl_device_inline float4 operator+(const float4 &a, const float f)
{
  return a + make_float4(f, f, f, f);
}

ccl_device_inline float4 operator+(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_add_ps(a.m128, b.m128));
#  else
  return make_float4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
#  endif
}

ccl_device_inline float4 operator+(const float f, const float4 &a)
{
  return make_float4(f, f, f, f) + a;
}

ccl_device_inline float4 operator-(const float4 &a, const float f)
{
  return a - make_float4(f, f, f, f);
}

ccl_device_inline float4 operator-(const float f, const float4 &a)
{
  return make_float4(f, f, f, f) - a;
}

ccl_device_inline float4 operator-(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_sub_ps(a.m128, b.m128));
#  else
  return make_float4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
#  endif
}

ccl_device_inline float4 operator+=(float4 &a, const float4 &b)
{
  return a = a + b;
}

ccl_device_inline float4 operator-=(float4 &a, const float4 &b)
{
  return a = a - b;
}

ccl_device_inline float4 operator*=(float4 &a, const float4 &b)
{
  return a = a * b;
}

ccl_device_inline float4 operator*=(float4 &a, const float f)
{
  return a = a * f;
}

ccl_device_inline float4 operator/=(float4 &a, const float f)
{
  return a = a / f;
}

ccl_device_inline int4 operator<(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmplt_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x < b.x, a.y < b.y, a.z < b.z, a.w < b.w);
#  endif
}

ccl_device_inline int4 operator>(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpgt_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x > b.x, a.y > b.y, a.z > b.z, a.w > b.w);
#  endif
}

ccl_device_inline int4 operator>=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpge_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x >= b.x, a.y >= b.y, a.z >= b.z, a.w >= b.w);
#  endif
}

ccl_device_inline int4 operator<=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmple_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x <= b.x, a.y <= b.y, a.z <= b.z, a.w <= b.w);
#  endif
}

ccl_device_inline int4 operator==(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpeq_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w);
#  endif
}

ccl_device_inline int4 operator!=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpneq_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x != b.x, a.y != b.y, a.z != b.z, a.w != b.w);
#  endif
}

ccl_device_inline float distance(const float4 &a, const float4 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float4 &a, const float4 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_dp_ps(a, b, 0xFF));
#  else
  return (a.x * b.x + a.y * b.y) + (a.z * b.z + a.w * b.w);
#  endif
}

ccl_device_inline float len_squared(const float4 &a)
{
  return dot(a, a);
}

ccl_device_inline float4 rcp(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  /* Don't use _mm_rcp_ps due to poor precision. */
  return float4(_mm_div_ps(_mm_set_ps1(1.0f), a.m128));
#  else
  return make_float4(1.0f / a.x, 1.0f / a.y, 1.0f / a.z, 1.0f / a.w);
#  endif
}

ccl_device_inline float4 sqrt(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_sqrt_ps(a.m128));
#  else
  return make_float4(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z), sqrtf(a.w));
#  endif
}

ccl_device_inline float4 sqr(const float4 &a)
{
  return a * a;
}

ccl_device_inline float4 cross(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return (shuffle<1, 2, 0, 0>(a) * shuffle<2, 0, 1, 0>(b)) -
         (shuffle<2, 0, 1, 0>(a) * shuffle<1, 2, 0, 0>(b));
#  else
  return make_float4(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x, 0.0f);
#  endif
}

ccl_device_inline float4 reduce_add(const float4 &a)
{
#  ifdef __KERNEL_SSE__
#    ifdef __KERNEL_SSE3__
  float4 h(_mm_hadd_ps(a.m128, a.m128));
  return float4(_mm_hadd_ps(h.m128, h.m128));
#    else
  float4 h(shuffle<1, 0, 3, 2>(a) + a);
  return shuffle<2, 3, 0, 1>(h) + h;
#    endif
#  else
  float sum = (a.x + a.y) + (a.z + a.w);
  return make_float4(sum, sum, sum, sum);
#  endif
}

ccl_device_inline float average(const float4 &a)
{
  return reduce_add(a).x * 0.25f;
}

ccl_device_inline float len(const float4 &a)
{
  return sqrtf(dot(a, a));
}

ccl_device_inline float4 normalize(const float4 &a)
{
  return a / len(a);
}

ccl_device_inline float4 safe_normalize(const float4 &a)
{
  float t = len(a);
  return (t != 0.0f) ? a / t : a;
}

ccl_device_inline float4 min(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_min_ps(a.m128, b.m128));
#  else
  return make_float4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));
#  endif
}

ccl_device_inline float4 min(const float4 &a, const float b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_min_ps(a.m128, _mm_set1_ps(b)));
#  else
  return make_float4(fminf(a.x, b), fminf(a.y, b), fminf(a.z, b), fminf(a.w, b));
#  endif
}

ccl_device_inline float4 max(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_max_ps(a.m128, b.m128));
#  else
  return make_float4(fmaxf(a.x, b.x), fmaxf(a.y, b.y), fmaxf(a.z, b.z), fmaxf(a.w, b.w));
#  endif
}

ccl_device_inline float4 max(const float4 &a, const float b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_max_ps(a.m128, _mm_set1_ps(b)));
#  else
  return make_float4(fminf(a.x, b), fminf(a.y, b), fminf(a.z, b), fminf(a.w, b));
#  endif
}

ccl_device_inline float4 clamp(const float4 &a, const float4 &mn, const float4 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float4 clamp(const float4 &a, const float mn, const float mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float4 fabs(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_and_ps(a.m128, _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff))));
#  else
  return make_float4(fabsf(a.x), fabsf(a.y), fabsf(a.z), fabsf(a.w));
#  endif
}

ccl_device_inline float4 floor(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_floor_ps(a));
#  else
  return make_float4(floorf(a.x), floorf(a.y), floorf(a.z), floorf(a.w));
#  endif
}

ccl_device_inline float4 mix(const float4 &a, const float4 &b, const float t)
{
  return a + t * (b - a);
}

#endif /* !__KERNEL_COMPUTE__*/

#ifdef __KERNEL_SSE__
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &b)
{
  return float4(_mm_castsi128_ps(
      _mm_shuffle_epi32(_mm_castps_si128(b), _MM_SHUFFLE(index_3, index_2, index_1, index_0))));
}

template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &a, const float4 &b)
{
  return float4(_mm_shuffle_ps(a.m128, b.m128, _MM_SHUFFLE(index_3, index_2, index_1, index_0)));
}

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &b)
{
  return float4(_mm_castpd_ps(_mm_movedup_pd(_mm_castps_pd(b))));
}

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &a, const float4 &b)
{
  return float4(_mm_movelh_ps(a.m128, b.m128));
}

template<> __forceinline const float4 shuffle<2, 3, 2, 3>(const float4 &a, const float4 &b)
{
  return float4(_mm_movehl_ps(b.m128, a.m128));
}

#  ifdef __KERNEL_SSE3__
template<> __forceinline const float4 shuffle<0, 0, 2, 2>(const float4 &b)
{
  return float4(_mm_moveldup_ps(b));
}

template<> __forceinline const float4 shuffle<1, 1, 3, 3>(const float4 &b)
{
  return float4(_mm_movehdup_ps(b));
}
#  endif /* __KERNEL_SSE3__ */
#endif   /* __KERNEL_SSE__ */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline float4 select(const float4 &b_false, const float4 &a_true, const int4 &mask)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_blendv_ps(b_false.m128, a_true.m128, _mm_castsi128_ps(mask.m128)));
#  else
  return make_float4((mask.x) ? a_true.x : b_false.x,
                     (mask.y) ? a_true.y : b_false.y,
                     (mask.z) ? a_true.z : b_false.z,
                     (mask.w) ? a_true.w : b_false.w);
#  endif
}

ccl_device_inline float4 reduce_min(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  float4 h = min(shuffle<1, 0, 3, 2>(a), a);
  return min(shuffle<2, 3, 0, 1>(h), h);
#  else
  return make_float4(min(min(a.x, a.y), min(a.z, a.w)));
#  endif
}

ccl_device_inline float4 reduce_max(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  float4 h = max(shuffle<1, 0, 3, 2>(a), a);
  return max(shuffle<2, 3, 0, 1>(h), h);
#  else
  return make_float4(max(max(a.x, a.y), max(a.z, a.w)));
#  endif
}

#endif /* !__KERNEL_COMPUTE__ */

ccl_device_inline float4 safe_divide_float4_float(const float4 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float4(0.0f, 0.0f, 0.0f, 0.0f);
}

ccl_device_inline float4 clamp_to_normal_f4(const float4 a)
{
  return min(max(a, 0.0f), 1.0f);
}

CCL_NAMESPACE_END

#endif

#line 426 ".kernel_util/COM_kernel_math.h"

CCL_NAMESPACE_BEGIN

#ifndef __KERNEL_OPENCL__
/* Interpolation */

template<class A, class B> A lerp(const A &a, const A &b, const B &t)
{
  return (A)(a * ((B)1 - t) + b * t);
}

#endif /* __KERNEL_OPENCL__ */

/* Triangle */
#ifndef __KERNEL_OPENCL__
ccl_device_inline float triangle_area(const float3 &v1, const float3 &v2, const float3 &v3)
#else
ccl_device_inline float triangle_area(const float3 v1, const float3 v2, const float3 v3)
#endif
{
  return len(cross(v3 - v2, v1 - v2)) * 0.5f;
}

/* Orthonormal vectors */

ccl_device_inline void make_orthonormals(const float3 N, float3 *a, float3 *b)
{
#if 0
  if (fabsf(N.y) >= 0.999f) {
    *a = make_float3(1, 0, 0);
    *b = make_float3(0, 0, 1);
    return;
  }
  if (fabsf(N.z) >= 0.999f) {
    *a = make_float3(1, 0, 0);
    *b = make_float3(0, 1, 0);
    return;
  }
#endif

  if (N.x != N.y || N.x != N.z)
    *a = make_float3(N.z - N.y, N.x - N.z, N.y - N.x);  //(1,1,1)x N
  else
    *a = make_float3(N.z - N.y, N.x + N.z, -N.y - N.x);  //(-1,1,1)x N

  *a = normalize(*a);
  *b = cross(N, *a);
}

/* Color division */

ccl_device_inline float3 safe_invert_color(const float3 a)
{
  float x, y, z;

  x = (a.x != 0.0f) ? 1.0f / a.x : 0.0f;
  y = (a.y != 0.0f) ? 1.0f / a.y : 0.0f;
  z = (a.z != 0.0f) ? 1.0f / a.z : 0.0f;

  return make_float3(x, y, z);
}

ccl_device_inline float3 safe_divide_color(const float3 a, const float3 b)
{
  float x, y, z;

  x = (b.x != 0.0f) ? a.x / b.x : 0.0f;
  y = (b.y != 0.0f) ? a.y / b.y : 0.0f;
  z = (b.z != 0.0f) ? a.z / b.z : 0.0f;

  return make_float3(x, y, z);
}

ccl_device_inline float3 safe_divide_even_color(const float3 a, const float3 b)
{
  float x, y, z;

  x = (b.x != 0.0f) ? a.x / b.x : 0.0f;
  y = (b.y != 0.0f) ? a.y / b.y : 0.0f;
  z = (b.z != 0.0f) ? a.z / b.z : 0.0f;

  /* try to get gray even if b is zero */
  if (b.x == 0.0f) {
    if (b.y == 0.0f) {
      x = z;
      y = z;
    }
    else if (b.z == 0.0f) {
      x = y;
      z = y;
    }
    else
      x = 0.5f * (y + z);
  }
  else if (b.y == 0.0f) {
    if (b.z == 0.0f) {
      y = x;
      z = x;
    }
    else
      y = 0.5f * (x + z);
  }
  else if (b.z == 0.0f) {
    z = 0.5f * (x + y);
  }

  return make_float3(x, y, z);
}

/* Rotation of point around axis and angle */

ccl_device_inline float3 rotate_around_axis(const float3 p, const float3 axis, const float angle)
{
  float costheta = cosf(angle);
  float sintheta = sinf(angle);
  float3 r;

  r.x = ((costheta + (1 - costheta) * axis.x * axis.x) * p.x) +
        (((1 - costheta) * axis.x * axis.y - axis.z * sintheta) * p.y) +
        (((1 - costheta) * axis.x * axis.z + axis.y * sintheta) * p.z);

  r.y = (((1 - costheta) * axis.x * axis.y + axis.z * sintheta) * p.x) +
        ((costheta + (1 - costheta) * axis.y * axis.y) * p.y) +
        (((1 - costheta) * axis.y * axis.z - axis.x * sintheta) * p.z);

  r.z = (((1 - costheta) * axis.x * axis.z - axis.y * sintheta) * p.x) +
        (((1 - costheta) * axis.y * axis.z + axis.x * sintheta) * p.y) +
        ((costheta + (1 - costheta) * axis.z * axis.z) * p.z);

  return r;
}

/* NaN-safe math ops */

ccl_device_inline float safe_sqrtf(const float f)
{
  return sqrtf(max(f, 0.0f));
}

ccl_device_inline float inversesqrtf(const float f)
{
  return (f > 0.0f) ? 1.0f / sqrtf(f) : 0.0f;
}

ccl_device float safe_asinf(const float a)
{
  return asinf(clamp(a, -1.0f, 1.0f));
}

ccl_device float safe_acosf(const float a)
{
  return acosf(clamp(a, -1.0f, 1.0f));
}

ccl_device float compatible_powf(const float x, const float y)
{
#ifdef __KERNEL_COMPUTE__
  if (y == 0.0f) /* x^0 -> 1, including 0^0 */
    return 1.0f;

  /* GPU pow doesn't accept negative x, do manual checks here */
  if (x < 0.0f) {
    if (fmodf(-y, 2.0f) == 0.0f)
      return powf(-x, y);
    else
      return -powf(-x, y);
  }
  else if (x == 0.0f)
    return 0.0f;
#endif
  return powf(x, y);
}

ccl_device float safe_powf(const float a, const float b)
{
  if (UNLIKELY(a < 0.0f && b != float_to_int(b)))
    return 0.0f;

  return compatible_powf(a, b);
}

ccl_device float safe_divide(const float a, const float b)
{
  return (b != 0.0f) ? a / b : 0.0f;
}

ccl_device float safe_logf(const float a, const float b)
{
  if (UNLIKELY(a <= 0.0f || b <= 0.0f))
    return 0.0f;

  return safe_divide(logf(a), logf(b));
}

ccl_device float safe_modulo(const float a, const float b)
{
  return (b != 0.0f) ? fmodf(a, b) : 0.0f;
}

ccl_device_inline float sqr(const float a)
{
  return a * a;
}

ccl_device_inline float pow20(const float a)
{
  return sqr(sqr(sqr(sqr(a)) * a));
}

ccl_device_inline float pow22(float a)
{
  return sqr(a * sqr(sqr(sqr(a)) * a));
}

ccl_device_inline float beta(float x, float y)
{
#ifndef __KERNEL_OPENCL__
  return expf(lgammaf(x) + lgammaf(y) - lgammaf(x + y));
#else
  return expf(lgamma(x) + lgamma(y) - lgamma(x + y));
#endif
}

ccl_device_inline float xor_signmask(const float x, const int y)
{
  return __int_as_float(__float_as_int(x) ^ y);
}

ccl_device float bits_to_01(const uint bits)
{
  return bits * (1.0f / (float)0xFFFFFFFF);
}

ccl_device_inline uint count_leading_zeros(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return __clz(x);
#elif defined(__KERNEL_OPENCL__)
  return clz(x);
#else
  assert(x != 0);
#  ifdef _MSC_VER
  unsigned long leading_zero = 0;
  _BitScanReverse(&leading_zero, x);
  return (31 - leading_zero);
#  else
  return __builtin_clz(x);
#  endif
#endif
}

ccl_device_inline uint count_trailing_zeros(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return (__ffs(x) - 1);
#elif defined(__KERNEL_OPENCL__)
  return (31 - count_leading_zeros(x & -x));
#else
  assert(x != 0);
#  ifdef _MSC_VER
  unsigned long ctz = 0;
  _BitScanForward(&ctz, x);
  return ctz;
#  else
  return __builtin_ctz(x);
#  endif
#endif
}

ccl_device_inline uint find_first_set(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return __ffs(x);
#elif defined(__KERNEL_OPENCL__)
  return (x != 0) ? (32 - count_leading_zeros(x & (-x))) : 0;
#else
#  ifdef _MSC_VER
  return (x != 0) ? (32 - count_leading_zeros(x & (-x))) : 0;
#  else
  return __builtin_ffs(x);
#  endif
#endif
}

/* projections */
ccl_device_inline float2 map_to_tube(const float3 co)
{
  float len, u, v;
  len = sqrtf(co.x * co.x + co.y * co.y);
  if (len > 0.0f) {
    u = (1.0f - (atan2f(co.x / len, co.y / len) / M_PI_F)) * 0.5f;
    v = (co.z + 1.0f) * 0.5f;
  }
  else {
    u = v = 0.0f;
  }
  return make_float2(u, v);
}

ccl_device_inline float2 map_to_sphere(const float3 co)
{
  float l = len(co);
  float u, v;
  if (l > 0.0f) {
    if (UNLIKELY(co.x == 0.0f && co.y == 0.0f)) {
      u = 0.0f; /* othwise domain error */
    }
    else {
      u = (1.0f - atan2f(co.x, co.y) / M_PI_F) / 2.0f;
    }
    v = 1.0f - safe_acosf(co.z / l) / M_PI_F;
  }
  else {
    u = v = 0.0f;
  }
  return make_float2(u, v);
}

/* Compares two floats.
 * Returns true if their absolute difference is smaller than abs_diff (for numbers near zero)
 * or their relative difference is less than ulp_diff ULPs.
 * Based on
 * https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
 */

ccl_device_inline float compare_floats(const float a,
                                       const float b,
                                       const float abs_diff,
                                       const int ulp_diff)
{
  if (fabsf(a - b) < abs_diff) {
    return true;
  }

  if ((a < 0.0f) != (b < 0.0f)) {
    return false;
  }

  return (abs(__float_as_int(a) - __float_as_int(b)) < ulp_diff);
}

ccl_device_inline float clamp_to_normal(const float a)
{
  return min(max(a, 0.0f), 1.0f);
}

ccl_device_inline float4 interp_f4f4(const float4 a, const float4 b, const float t)
{
  const float s = 1.0f - t;

  return s * a + t * b;
}

CCL_NAMESPACE_END

#endif

#line 7 ".kernel_util/COM_kernel_color.h"

CCL_NAMESPACE_BEGIN

/* YCbCr */
#ifndef BLI_YCC_ITU_BT601
#  define BLI_YCC_ITU_BT601 0
#endif
#ifndef BLI_YCC_ITU_BT709
#  define BLI_YCC_ITU_BT709 1
#endif
#ifndef BLI_YCC_JFIF_0_255
#  define BLI_YCC_JFIF_0_255 2
#endif
/* END of YCbCr */

/* **************** ColorBand ********************* */
/* colormode */
#define COLBAND_BLEND_RGB 0
#define COLBAND_BLEND_HSV 1
#define COLBAND_BLEND_HSL 2

/* interpolation */
#define COLBAND_INTERP_LINEAR 0
#define COLBAND_INTERP_EASE 1
#define COLBAND_INTERP_B_SPLINE 2
#define COLBAND_INTERP_CARDINAL 3
#define COLBAND_INTERP_CONSTANT 4

/* color interpolation */
#define COLBAND_HUE_NEAR 0
#define COLBAND_HUE_FAR 1
#define COLBAND_HUE_CW 2
#define COLBAND_HUE_CCW 3
/* **************** END of ColorBand ********************* */

ccl_constant float4 BLACK_PIXEL = make_float4(0, 0, 0, 1);
ccl_constant float4 TRANSPARENT_PIXEL = make_float4(0, 0, 0, 0);

ccl_device_inline float4 premul_to_straight(const float4 premul)
{
  if (premul.w == 0.0f || premul.w == 1.0f) {
    return premul;
  }
  else {
    float4 result = premul * (1.0f / premul.w);
    result.w = premul.w;
    return result;
  }
}

ccl_device_inline float4 straight_to_premul(const float4 straight)
{
  float4 result = straight * straight.w;
  result.w = straight.w;
  return result;
}

ccl_device_inline float4 hsv_to_rgb(const float4 hsv)
{
  float4 rgb;

  rgb.x = fabsf(hsv.x * 6.0f - 3.0f) - 1.0f;
  rgb.y = 2.0f - fabsf(hsv.x * 6.0f - 2.0f);
  rgb.z = 2.0f - fabsf(hsv.x * 6.0f - 4.0f);

  rgb = clamp(rgb, 0.0f, 1.0f);
  rgb = ((rgb - 1.0f) * hsv.y + 1.0f) * hsv.z;
  rgb.w = hsv.w;

  return rgb;
}

ccl_device_inline float4 hsl_to_rgb(const float4 hsl)
{
  float4 rgb;

  rgb.x = fabsf(hsl.x * 6.0f - 3.0f) - 1.0f;
  rgb.y = 2.0f - fabsf(hsl.x * 6.0f - 2.0f);
  rgb.z = 2.0f - fabsf(hsl.x * 6.0f - 4.0f);

  rgb = clamp(rgb, 0.0f, 1.0f);

  float chroma = (1.0f - fabsf(2.0f * hsl.z - 1.0f)) * hsl.y;
  rgb = (rgb - 0.5f) * chroma + hsl.z;
  rgb.w = hsl.w;

  return rgb;
}

// In compositor only BLI_YUV_ITU_BT709 color space is used
ccl_device_inline float4 rgb_to_yuv(const float4 rgb)
{
  float4 yuv;
  yuv.x = 0.2126f * rgb.x + 0.7152f * rgb.y + 0.0722f * rgb.z;
  yuv.y = -0.09991f * rgb.x - 0.33609f * rgb.y + 0.436f * rgb.z;
  yuv.z = 0.615f * rgb.x - 0.55861f * rgb.y - 0.05639f * rgb.z;
  yuv.w = rgb.w;
  return yuv;
}

// In compositor only BLI_YUV_ITU_BT709 color space is used
ccl_device_inline float4 yuv_to_rgb(const float4 yuv)
{
  float4 rgb;
  rgb.x = yuv.x + 1.28033f * yuv.z;
  rgb.y = yuv.x - 0.21482f * yuv.y - 0.38059f * yuv.z;
  rgb.z = yuv.x + 2.12798f * yuv.y;
  rgb.w = yuv.w;
  return rgb;
}

/* The RGB inputs are supposed gamma corrected and in the range 0 - 1.0f
 */
ccl_device_inline float4 rgb_to_ycc(float4 rgb, int colorspace)
{
  float4 ycc;

  float alpha = rgb.w;
  rgb = 255.0f * rgb;
  switch (colorspace) {
    case BLI_YCC_ITU_BT601:
      ycc.x = (0.257f * rgb.x) + (0.504f * rgb.y) + (0.098f * rgb.z) + 16.0f;
      ycc.y = (-0.148f * rgb.x) - (0.291f * rgb.y) + (0.439f * rgb.z) + 128.0f;
      ycc.z = (0.439f * rgb.x) - (0.368f * rgb.y) - (0.071f * rgb.z) + 128.0f;
      break;
    case BLI_YCC_ITU_BT709:
      ycc.x = (0.183f * rgb.x) + (0.614f * rgb.y) + (0.062f * rgb.z) + 16.0f;
      ycc.y = (-0.101f * rgb.x) - (0.338f * rgb.y) + (0.439f * rgb.z) + 128.0f;
      ycc.z = (0.439f * rgb.x) - (0.399f * rgb.y) - (0.040f * rgb.z) + 128.0f;
      break;
    case BLI_YCC_JFIF_0_255:
      ycc.x = (0.299f * rgb.x) + (0.587f * rgb.y) + (0.114f * rgb.z);
      ycc.y = (-0.16874f * rgb.x) - (0.33126f * rgb.y) + (0.5f * rgb.z) + 128.0f;
      ycc.z = (0.5f * rgb.x) - (0.41869f * rgb.y) - (0.08131f * rgb.z) + 128.0f;
      break;
    default:
      kernel_assert(!"invalid colorspace");
      break;
  }
  ycc /= 255.0f;
  ycc.w = alpha;
  return ycc;
}

/* May have a bug. See FIXME comment in blendlib math_color.c */
ccl_device_inline float4 ycc_to_rgb(float4 ycc, const int colorspace)
{
  float4 rgb;
  float alpha = ycc.w;
  ycc *= 255.0f;
  switch (colorspace) {
    case BLI_YCC_ITU_BT601:
      rgb.x = 1.164f * (ycc.x - 16.0f) + 1.596f * (ycc.z - 128.0f);
      rgb.y = 1.164f * (ycc.x - 16.0f) - 0.813f * (ycc.z - 128.0f) - 0.392f * (ycc.y - 128.0f);
      rgb.z = 1.164f * (ycc.x - 16.0f) + 2.017f * (ycc.y - 128.0f);
      break;
    case BLI_YCC_ITU_BT709:
      rgb.x = 1.164f * (ycc.x - 16.0f) + 1.793f * (ycc.z - 128.0f);
      rgb.y = 1.164f * (ycc.x - 16.0f) - 0.534f * (ycc.z - 128.0f) - 0.213f * (ycc.y - 128.0f);
      rgb.z = 1.164f * (ycc.x - 16.0f) + 2.115f * (ycc.y - 128.0f);
      break;
    case BLI_YCC_JFIF_0_255:
      rgb.x = ycc.x + 1.402f * ycc.z - 179.456f;
      rgb.y = ycc.x - 0.34414f * ycc.y - 0.71414f * ycc.z + 135.45984f;
      rgb.z = ycc.x + 1.772f * ycc.y - 226.816f;
      break;
    default:
      kernel_assert(!"invalid colorspace");
      break;
  }
  rgb = rgb / 255.0f;
  rgb.w = alpha;
  return rgb;
}

ccl_device_inline float4 rgb_to_hsv(float4 rgb)
{
  float k = 0.0f;
  float chroma;
  float min_gb;

  if (rgb.y < rgb.z) {
    SWAP(float, rgb.y, rgb.z);
    k = -1.0f;
  }
  min_gb = rgb.z;
  if (rgb.x < rgb.y) {
    SWAP(float, rgb.x, rgb.y);
    k = -2.0f / 6.0f - k;
    min_gb = fminf(rgb.y, rgb.z);
  }

  chroma = rgb.x - min_gb;

  float4 hsv;
  hsv.x = fabsf(k + (rgb.y - rgb.z) / (6.0f * chroma + 1e-20f));
  hsv.y = chroma / (rgb.x + 1e-20f);
  hsv.z = rgb.x;
  hsv.w = rgb.w;
  return hsv;
}

ccl_device_inline float4 rgb_to_hsl(const float4 rgb)
{
  float4 hsl;
  const float cmax = fmaxf3(rgb.x, rgb.y, rgb.z);
  const float cmin = fminf3(rgb.x, rgb.y, rgb.z);
  hsl.z = fminf(1.0, (cmax + cmin) / 2.0f);

  if (cmax == cmin) {
    hsl.x = hsl.y = 0.0f;  // achromatic
  }
  else {
    float d = cmax - cmin;
    hsl.y = hsl.z > 0.5f ? d / (2.0f - cmax - cmin) : d / (cmax + cmin);
    if (cmax == rgb.x) {
      hsl.x = (rgb.y - rgb.z) / d + (rgb.y < rgb.z ? 6.0f : 0.0f);
    }
    else if (cmax == rgb.y) {
      hsl.x = (rgb.z - rgb.x) / d + 2.0f;
    }
    else {
      hsl.x = (rgb.x - rgb.y) / d + 4.0f;
    }
  }
  hsl.x /= 6.0f;
  hsl.w = rgb.w;
  return hsl;
}

ccl_device_inline float srgb_to_linearrgb(const float c)
{
  if (c < 0.04045f) {
    return (c < 0.0f) ? 0.0f : c * (1.0f / 12.92f);
  }
  else {
    return powf((c + 0.055f) * (1.0f / 1.055f), 2.4f);
  }
}

ccl_device_inline float linearrgb_to_srgb(const float c)
{
  if (c < 0.0031308f) {
    return (c < 0.0f) ? 0.0f : c * 12.92f;
  }
  else {
    return 1.055f * powf(c, 1.0f / 2.4f) - 0.055f;
  }
}

/**  COLORBAND **/

ccl_device_inline float colorband_hue_interp(
    const int ipotype_hue, const float mfac, const float fac, float h1, float h2)
{
  float h_interp;
  int mode = 0;

#define HUE_INTERP(h_a, h_b) ((mfac * (h_a)) + (fac * (h_b)))
#define HUE_MOD(h) (((h) < 1.0f) ? (h) : (h)-1.0f)

  h1 = HUE_MOD(h1);
  h2 = HUE_MOD(h2);

  kernel_assert(h1 >= 0.0f && h1 < 1.0f);
  kernel_assert(h2 >= 0.0f && h2 < 1.0f);

  switch (ipotype_hue) {
    case COLBAND_HUE_NEAR: {
      if ((h1 < h2) && (h2 - h1) > +0.5f) {
        mode = 1;
      }
      else if ((h1 > h2) && (h2 - h1) < -0.5f) {
        mode = 2;
      }
      else {
        mode = 0;
      }
      break;
    }
    case COLBAND_HUE_FAR: {
      /* Do full loop in Hue space in case both stops are the same... */
      if (h1 == h2) {
        mode = 1;
      }
      else if ((h1 < h2) && (h2 - h1) < +0.5f) {
        mode = 1;
      }
      else if ((h1 > h2) && (h2 - h1) > -0.5f) {
        mode = 2;
      }
      else {
        mode = 0;
      }
      break;
    }
    case COLBAND_HUE_CCW: {
      if (h1 > h2) {
        mode = 2;
      }
      else {
        mode = 0;
      }
      break;
    }
    case COLBAND_HUE_CW: {
      if (h1 < h2) {
        mode = 1;
      }
      else {
        mode = 0;
      }
      break;
    }
  }

  switch (mode) {
    case 0:
      h_interp = HUE_INTERP(h1, h2);
      break;
    case 1:
      h_interp = HUE_INTERP(h1 + 1.0f, h2);
      h_interp = HUE_MOD(h_interp);
      break;
    case 2:
      h_interp = HUE_INTERP(h1, h2 + 1.0f);
      h_interp = HUE_MOD(h_interp);
      break;
  }

  kernel_assert(h_interp >= 0.0f && h_interp < 1.0f);

#undef HUE_INTERP
#undef HUE_MOD

  return h_interp;
}

ccl_device_inline float4 colorband_evaluate(const float input_factor,
                                            const int n_bands,
                                            const int interp_type,
                                            const int hue_interp_type,
                                            const int color_mode,
                                            ccl_global float4 *bands_colors,
                                            ccl_global float *bands_pos)
{
  int cbd1, cbd2, cbd0, cbd3;
  int ipotype;

  if (n_bands == 0) {
    return make_float4(0.0f, 0.0f, 0.0f, 1.0f);
  }

  cbd1 = 0;

  /* Note: when ipotype >= COLBAND_INTERP_B_SPLINE,
   * we cannot do early-out with a constant color before first color stop and after last one,
   * because interpolation starts before and ends after those... */
  ipotype = (color_mode == COLBAND_BLEND_RGB) ? interp_type : COLBAND_INTERP_LINEAR;

  if (n_bands == 1) {
    return bands_colors[cbd1];
  }
  else if ((input_factor <= bands_pos[cbd1]) &&
           (ipotype == COLBAND_INTERP_LINEAR || ipotype == COLBAND_INTERP_EASE ||
            ipotype == COLBAND_INTERP_CONSTANT)) {
    /* We are before first color stop. */
    return bands_colors[cbd1];
  }
  else {
    // float4 left_color, right_color;
    // float left_pos, right_pos;
    int pos_idx;
    const float right_pos = 1.0f;
    const float left_pos = 0.0f;

    /* we're looking for first pos > in */
    for (pos_idx = 0; pos_idx < n_bands; pos_idx++) {
      if (bands_pos[pos_idx] > input_factor) {
        break;
      }
    }
    cbd1 += pos_idx;

    float pos1_value = bands_pos[cbd1];
    float pos2_value;
    if (pos_idx == n_bands) {
      cbd2 = cbd1 - 1;
      pos2_value = bands_pos[cbd2];
      cbd1 = cbd2;
      pos1_value = right_pos;
    }
    else if (pos_idx == 0) {
      cbd2 = cbd1;
      pos2_value = left_pos;
    }
    else {
      cbd2 = cbd1 - 1;
      pos2_value = bands_pos[cbd2];
    }

    if ((pos_idx == n_bands) &&
        (ipotype == COLBAND_INTERP_LINEAR || ipotype == COLBAND_INTERP_EASE ||
         ipotype == COLBAND_INTERP_CONSTANT)) {
      /* We are after last color stop. */
      return bands_colors[cbd2];
    }
    else if (ipotype == COLBAND_INTERP_CONSTANT) {
      /* constant */
      return bands_colors[cbd2];
    }
    else {
      float fac;
      if (pos2_value != pos1_value) {
        fac = (input_factor - pos1_value) / (pos2_value - pos1_value);
      }
      else {
        /* was setting to 0.0 in 2.56 & previous, but this
         * is incorrect for the last element, see [#26732] */
        fac = (pos_idx != n_bands) ? 0.0f : 1.0f;
      }

      if (ipotype == COLBAND_INTERP_B_SPLINE || ipotype == COLBAND_INTERP_CARDINAL) {
        /* ipo from right to left: 3 2 1 0 */
        float t[4];

        if (pos_idx >= n_bands - 1) {
          cbd0 = cbd1;
        }
        else {
          cbd0 = cbd1 + 1;
        }
        if (pos_idx < 2) {
          cbd3 = cbd2;
        }
        else {
          cbd3 = cbd2 - 1;
        }

        fac = clamp(fac, 0.0f, 1.0f);

        if (ipotype == COLBAND_INTERP_CARDINAL) {
          key_curve_position_weights(fac, t, KEY_CARDINAL);
        }
        else {
          key_curve_position_weights(fac, t, KEY_BSPLINE);
        }

        float4 result = t[3] * bands_colors[cbd3] + t[2] * bands_colors[cbd2] +
                        t[1] * bands_colors[cbd1] + t[0] * bands_colors[cbd0];
        clamp(result, 0.0f, 1.0f);
        return result;
      }
      else {
        if (ipotype == COLBAND_INTERP_EASE) {
          const float fac2 = fac * fac;
          fac = 3.0f * fac2 - 2.0f * fac2 * fac;
        }
        const float mfac = 1.0f - fac;

        if (UNLIKELY(color_mode == COLBAND_BLEND_HSV)) {
          float4 col1 = rgb_to_hsv(bands_colors[cbd1]);
          float4 col2 = rgb_to_hsv(bands_colors[cbd2]);
          float4 result;

          result.x = colorband_hue_interp(hue_interp_type, mfac, fac, col1.x, col2.x);
          result.y = mfac * col1.y + fac * col2.y;
          result.z = mfac * col1.z + fac * col2.z;
          result.w = mfac * bands_colors[cbd1].w + fac * bands_colors[cbd2].w;

          return hsv_to_rgb(result);
        }
        else if (UNLIKELY(color_mode == COLBAND_BLEND_HSL)) {
          float4 col1 = rgb_to_hsl(bands_colors[cbd1]);
          float4 col2 = rgb_to_hsl(bands_colors[cbd2]);
          float4 result;

          result.x = colorband_hue_interp(hue_interp_type, mfac, fac, col1.x, col2.x);
          result.y = mfac * col1.y + fac * col2.y;
          result.z = mfac * col1.z + fac * col2.z;
          result.w = mfac * bands_colors[cbd1].w + fac * bands_colors[cbd2].w;

          return hsl_to_rgb(result);
        }
        else {
          /* COLBAND_BLEND_RGB */
          return mfac * bands_colors[cbd1] + fac * bands_colors[cbd2];
        }
      }
    }
  }
}

/** END of COLORBAND **/

CCL_NAMESPACE_END

#endif

#line 152 ".COM_kernel_opencl.h"
#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 153 ".COM_kernel_opencl.h"
#line 1 ".kernel_util/COM_kernel_geom.h"
#ifndef __COM_KERNEL_GEOM_H__
#define __COM_KERNEL_GEOM_H__

#line 1 ".kernel_util/COM_kernel_math.h"
#ifndef __COM_KERNEL_MATH_H__
#define __COM_KERNEL_MATH_H__

/* Math
 *
 * Basic math functions on scalar and vector types. This header is used by
 * both the kernel code when compiled as C++, and other C++ non-kernel code. */

#ifndef __KERNEL_COMPUTE__
#  include <cmath>
#endif

#ifndef __KERNEL_OPENCL__
#  include <float.h>
#  include <math.h>
#  include <stdio.h>
#endif /* __KERNEL_OPENCL__ */

#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 19 ".kernel_util/COM_kernel_math.h"

CCL_NAMESPACE_BEGIN

/* Float Pi variations */

/* Division */
#ifndef M_PI_F
#  define M_PI_F (3.1415926535897932f) /* pi */
#endif
#ifndef M_PI_2_F
#  define M_PI_2_F (1.5707963267948966f) /* pi/2 */
#endif
#ifndef M_PI_4_F
#  define M_PI_4_F (0.7853981633974830f) /* pi/4 */
#endif
#ifndef M_1_PI_F
#  define M_1_PI_F (0.3183098861837067f) /* 1/pi */
#endif
#ifndef M_2_PI_F
#  define M_2_PI_F (0.6366197723675813f) /* 2/pi */
#endif
#ifndef M_1_2PI_F
#  define M_1_2PI_F (0.1591549430918953f) /* 1/(2*pi) */
#endif
#ifndef M_SQRT_PI_8_F
#  define M_SQRT_PI_8_F (0.6266570686577501f) /* sqrt(pi/8) */
#endif
#ifndef M_LN_2PI_F
#  define M_LN_2PI_F (1.8378770664093454f) /* ln(2*pi) */
#endif

/* Multiplication */
#ifndef M_2PI_F
#  define M_2PI_F (6.2831853071795864f) /* 2*pi */
#endif
#ifndef M_4PI_F
#  define M_4PI_F (12.566370614359172f) /* 4*pi */
#endif

/* Float sqrt variations */
#ifndef M_SQRT2_F
#  define M_SQRT2_F (1.4142135623730950f) /* sqrt(2) */
#endif
#ifndef M_LN2_F
#  define M_LN2_F (0.6931471805599453f) /* ln(2) */
#endif
#ifndef M_LN10_F
#  define M_LN10_F (2.3025850929940457f) /* ln(10) */
#endif

#ifndef RAD2DEGF
#  define RAD2DEGF(_rad) ((_rad) * (float)(180.0f / M_PI_F))
#endif
#ifndef DEG2RADF
#  define DEG2RADF(_deg) ((_deg) * (float)(M_PI_F / 180.0f))
#endif

/* Scalar */

#ifdef _WIN32
#  ifndef __KERNEL_OPENCL__
ccl_device_inline float fmaxf(float a, float b)
{
  return (a > b) ? a : b;
}

ccl_device_inline float fminf(float a, float b)
{
  return (a < b) ? a : b;
}
#  endif /* !__KERNEL_OPENCL__ */
#endif   /* _WIN32 */

#ifndef __KERNEL_COMPUTE__
using std::isfinite;
using std::isnan;
using std::sqrt;

ccl_device_inline int abs(const int x)
{
  return (x > 0) ? x : -x;
}

ccl_device_inline int max(const int a, const int b)
{
  return (a > b) ? a : b;
}

ccl_device_inline int min(const int a, const int b)
{
  return (a < b) ? a : b;
}

ccl_device_inline float max(const float a, const float b)
{
  return (a > b) ? a : b;
}

ccl_device_inline float min(const float a, const float b)
{
  return (a < b) ? a : b;
}
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline float fminf3(const float a, const float b, const float c)
{
  return fminf(fminf(a, b), c);
}

ccl_device_inline float fmaxf3(const float a, const float b, const float c)
{
  return fmaxf(fmaxf(a, b), c);
}

ccl_device_inline float fminf4(const float a, const float b, const float c, const float d)
{
  return fminf(fminf(a, b), fminf(c, d));
}

ccl_device_inline float fmaxf4(const float a, const float b, const float c, const float d)
{
  return fmaxf(fmaxf(a, b), fmaxf(c, d));
}

#ifndef __KERNEL_OPENCL__
/* Int/Float conversion */

ccl_device_inline int as_int(uint i)
{
  union {
    uint ui;
    int i;
  } u;
  u.ui = i;
  return u.i;
}

ccl_device_inline uint as_uint(int i)
{
  union {
    uint ui;
    int i;
  } u;
  u.i = i;
  return u.ui;
}

ccl_device_inline uint as_uint(float f)
{
  union {
    uint i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline int __float_as_int(float f)
{
  union {
    int i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline float __int_as_float(int i)
{
  union {
    int i;
    float f;
  } u;
  u.i = i;
  return u.f;
}

ccl_device_inline uint __float_as_uint(float f)
{
  union {
    uint i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline float __uint_as_float(uint i)
{
  union {
    uint i;
    float f;
  } u;
  u.i = i;
  return u.f;
}

ccl_device_inline int4 __float4_as_int4(float4 f)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(f.m128));
#  else
  return make_int4(
      __float_as_int(f.x), __float_as_int(f.y), __float_as_int(f.z), __float_as_int(f.w));
#  endif
}

ccl_device_inline float4 __int4_as_float4(int4 i)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_castsi128_ps(i.m128));
#  else
  return make_float4(
      __int_as_float(i.x), __int_as_float(i.y), __int_as_float(i.z), __int_as_float(i.w));
#  endif
}
#endif /* __KERNEL_OPENCL__ */

/* Versions of functions which are safe for fast math. */
ccl_device_inline bool isnan_safe(const float f)
{
  unsigned int x = __float_as_uint(f);
  return (x << 1) > 0xff000000u;
}

ccl_device_inline bool isfinite_safe(const float f)
{
  /* By IEEE 754 rule, 2*Inf equals Inf */
  unsigned int x = __float_as_uint(f);
  return (f == f) && (x == 0 || x == (1u << 31) || (f != 2.0f * f)) && !((x << 1) > 0xff000000u);
}

ccl_device_inline float ensure_finite(const float v)
{
  return isfinite_safe(v) ? v : 0.0f;
}

#ifndef __KERNEL_OPENCL__
ccl_device_inline int clamp(const int a, const int mn, const int mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float clamp(const float a, const float mn, const float mx)
{
  return fminf(fmaxf(a, mn), mx);
}

ccl_device_inline float mix(const float a, const float b, const float t)
{
  return a + t * (b - a);
}

ccl_device_inline float smoothstep(const float edge0, const float edge1, const float x)
{
  float result;
  if (x < edge0)
    result = 0.0f;
  else if (x >= edge1)
    result = 1.0f;
  else {
    float t = (x - edge0) / (edge1 - edge0);
    result = (3.0f - 2.0f * t) * (t * t);
  }
  return result;
}

#endif /* __KERNEL_OPENCL__ */

#ifndef __KERNEL_CUDA__
ccl_device_inline float saturate(const float a)
{
  return clamp(a, 0.0f, 1.0f);
}
#endif /* __KERNEL_CUDA__ */

ccl_device_inline int float_to_int(const float f)
{
  return (int)f;
}

ccl_device_inline int floor_to_int(const float f)
{
  return float_to_int(floorf(f));
}

ccl_device_inline int quick_floor_to_int(const float x)
{
  return float_to_int(x) - ((x < 0) ? 1 : 0);
}

ccl_device_inline float floorfrac(const float x, int *i)
{
  *i = quick_floor_to_int(x);
  return x - *i;
}

ccl_device_inline int ceil_to_int(const float f)
{
  return float_to_int(ceilf(f));
}

ccl_device_inline float fractf(const float x)
{
  return x - floorf(x);
}

/* Adapted from godotengine math_funcs.h. */
ccl_device_inline float wrapf(const float value, const float max, const float min)
{
  float range = max - min;
  return (range != 0.0f) ? value - (range * floorf((value - min) / range)) : min;
}

ccl_device_inline float pingpongf(const float a, const float b)
{
  return (b != 0.0f) ? fabsf(fractf((a - b) / (b * 2.0f)) * b * 2.0f - b) : 0.0f;
}

ccl_device_inline float smoothminf(const float a, const float b, const float k)
{
  if (k != 0.0f) {
    float h = fmaxf(k - fabsf(a - b), 0.0f) / k;
    return fminf(a, b) - h * h * h * k * (1.0f / 6.0f);
  }
  else {
    return fminf(a, b);
  }
}

ccl_device_inline float signf(const float f)
{
  return (f < 0.0f) ? -1.0f : 1.0f;
}

ccl_device_inline float nonzerof(const float f, const float eps)
{
  if (fabsf(f) < eps)
    return signf(f) * eps;
  else
    return f;
}

/* Signum function testing for zero. Matches GLSL and OSL functions. */
ccl_device_inline float compatible_signf(const float f)
{
  if (f == 0.0f) {
    return 0.0f;
  }
  else {
    return signf(f);
  }
}

ccl_device_inline float smoothstepf(const float f)
{
  float ff = f * f;
  return (3.0f * ff - 2.0f * ff * f);
}

ccl_device_inline int mod(const int x, const int m)
{
  return (x % m + m) % m;
}

ccl_device_inline float3 float2_to_float3(const float2 a)
{
  return make_float3(a.x, a.y, 0.0f);
}

ccl_device_inline float3 float4_to_float3(const float4 a)
{
  return make_float3(a.x, a.y, a.z);
}

ccl_device_inline float4 float3_to_float4(const float3 a)
{
  return make_float4(a.x, a.y, a.z, 1.0f);
}

ccl_device_inline float inverse_lerp(const float a, const float b, const float x)
{
  return (x - a) / (b - a);
}

/* Cubic interpolation between b and c, a and d are the previous and next point. */
ccl_device_inline float cubic_interp(
    const float a, const float b, const float c, const float d, const float x)
{
  return 0.5f *
             (((d + 3.0f * (b - c) - a) * x + (2.0f * a - 5.0f * b + 4.0f * c - d)) * x +
              (c - a)) *
             x +
         b;
}

CCL_NAMESPACE_END

#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 418 ".kernel_util/COM_kernel_math.h"

#line 1 ".kernel_util/COM_kernel_math_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT2_H__
#define __COM_KERNEL_MATH_INT2_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline bool operator==(const int2 a, const int2 b);
ccl_device_inline int2 operator+(const int2 &a, const int2 &b);
ccl_device_inline int2 operator+=(int2 &a, const int2 &b);
ccl_device_inline int2 operator-(const int2 &a, const int2 &b);
ccl_device_inline int2 operator*(const int2 &a, const int2 &b);
ccl_device_inline int2 operator/(const int2 &a, const int2 &b);
#endif /* !__KERNEL_OPENCL__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline bool operator==(const int2 a, const int2 b)
{
  return (a.x == b.x && a.y == b.y);
}

ccl_device_inline int2 operator+(const int2 &a, const int2 &b)
{
  return make_int2(a.x + b.x, a.y + b.y);
}

ccl_device_inline int2 operator+=(int2 &a, const int2 &b)
{
  return a = a + b;
}

ccl_device_inline int2 operator-(const int2 &a, const int2 &b)
{
  return make_int2(a.x - b.x, a.y - b.y);
}

ccl_device_inline int2 operator*(const int2 &a, const int2 &b)
{
  return make_int2(a.x * b.x, a.y * b.y);
}

ccl_device_inline int2 operator/(const int2 &a, const int2 &b)
{
  return make_int2(a.x / b.x, a.y / b.y);
}
#endif /* !__KERNEL_OPENCL__ */

CCL_NAMESPACE_END

#endif

#line 420 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT3_H__
#define __COM_KERNEL_MATH_INT3_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline int3 min(int3 a, int3 b);
ccl_device_inline int3 max(int3 a, int3 b);
ccl_device_inline int3 clamp(const int3 &a, int mn, int mx);
ccl_device_inline int3 clamp(const int3 &a, int3 &mn, int mx);
#endif /* !__KERNEL_OPENCL__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline int3 min(int3 a, int3 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int3(_mm_min_epi32(a.m128, b.m128));
#  else
  return make_int3(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));
#  endif
}

ccl_device_inline int3 max(int3 a, int3 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int3(_mm_max_epi32(a.m128, b.m128));
#  else
  return make_int3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));
#  endif
}

ccl_device_inline int3 clamp(const int3 &a, int mn, int mx)
{
#  ifdef __KERNEL_SSE__
  return min(max(a, make_int3_1(mn)), make_int3_1(mx));
#  else
  return make_int3(clamp(a.x, mn, mx), clamp(a.y, mn, mx), clamp(a.z, mn, mx));
#  endif
}

ccl_device_inline int3 clamp(const int3 &a, int3 &mn, int mx)
{
#  ifdef __KERNEL_SSE__
  return min(max(a, mn), make_int3_1(mx));
#  else
  return make_int3(clamp(a.x, mn.x, mx), clamp(a.y, mn.y, mx), clamp(a.z, mn.z, mx));
#  endif
}

ccl_device_inline bool operator==(const int3 &a, const int3 &b)
{
  return a.x == b.x && a.y == b.y && a.z == b.z;
}

ccl_device_inline bool operator!=(const int3 &a, const int3 &b)
{
  return !(a == b);
}

ccl_device_inline bool operator<(const int3 &a, const int3 &b)
{
  return a.x < b.x && a.y < b.y && a.z < b.z;
}

ccl_device_inline int3 operator+(const int3 &a, const int3 &b)
{
#  ifdef __KERNEL_SSE__
  return int3(_mm_add_epi32(a.m128, b.m128));
#  else
  return make_int3(a.x + b.x, a.y + b.y, a.z + b.z);
#  endif
}

ccl_device_inline int3 operator-(const int3 &a, const int3 &b)
{
#  ifdef __KERNEL_SSE__
  return int3(_mm_sub_epi32(a.m128, b.m128));
#  else
  return make_int3(a.x - b.x, a.y - b.y, a.z - b.z);
#  endif
}
#endif /* !__KERNEL_OPENCL__ */

CCL_NAMESPACE_END

#endif /* __COM_kernel_MATH_INT3_H__ */

#line 421 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT4_H__
#define __COM_KERNEL_MATH_INT4_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline int4 operator+(const int4 &a, const int4 &b);
ccl_device_inline int4 operator+=(int4 &a, const int4 &b);
ccl_device_inline int4 operator>>(const int4 &a, int i);
ccl_device_inline int4 operator<<(const int4 &a, int i);
ccl_device_inline int4 operator<(const int4 &a, const int4 &b);
ccl_device_inline int4 operator>=(const int4 &a, const int4 &b);
ccl_device_inline int4 operator&(const int4 &a, const int4 &b);
ccl_device_inline int4 min(int4 a, int4 b);
ccl_device_inline int4 max(int4 a, int4 b);
ccl_device_inline int4 clamp(const int4 &a, const int4 &mn, const int4 &mx);
ccl_device_inline int4 select(const int4 &mask, const int4 &a, const int4 &b);
#endif /* __KERNEL_COMPUTE__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline int4 operator+(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_add_epi32(a.m128, b.m128));
#  else
  return make_int4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
#  endif
}

ccl_device_inline int4 operator+=(int4 &a, const int4 &b)
{
  return a = a + b;
}

ccl_device_inline int4 operator>>(const int4 &a, int i)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_srai_epi32(a.m128, i));
#  else
  return make_int4(a.x >> i, a.y >> i, a.z >> i, a.w >> i);
#  endif
}

ccl_device_inline int4 operator<<(const int4 &a, int i)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_slli_epi32(a.m128, i));
#  else
  return make_int4(a.x << i, a.y << i, a.z << i, a.w << i);
#  endif
}

ccl_device_inline int4 operator<(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_cmplt_epi32(a.m128, b.m128));
#  else
  return make_int4(a.x < b.x, a.y < b.y, a.z < b.z, a.w < b.w);
#  endif
}

ccl_device_inline int4 operator>=(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_xor_si128(_mm_set1_epi32(0xffffffff), _mm_cmplt_epi32(a.m128, b.m128)));
#  else
  return make_int4(a.x >= b.x, a.y >= b.y, a.z >= b.z, a.w >= b.w);
#  endif
}

ccl_device_inline int4 operator&(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_and_si128(a.m128, b.m128));
#  else
  return make_int4(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
#  endif
}

ccl_device_inline int4 min(int4 a, int4 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int4(_mm_min_epi32(a.m128, b.m128));
#  else
  return make_int4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));
#  endif
}

ccl_device_inline int4 max(int4 a, int4 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int4(_mm_max_epi32(a.m128, b.m128));
#  else
  return make_int4(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z), max(a.w, b.w));
#  endif
}

ccl_device_inline int4 clamp(const int4 &a, const int4 &mn, const int4 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline int4 select(const int4 &mask, const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  const __m128 m = _mm_cvtepi32_ps(mask);
  /* TODO(sergey): avoid cvt. */
  return int4(_mm_castps_si128(
      _mm_or_ps(_mm_and_ps(m, _mm_castsi128_ps(a)), _mm_andnot_ps(m, _mm_castsi128_ps(b)))));
#  else
  return make_int4(
      (mask.x) ? a.x : b.x, (mask.y) ? a.y : b.y, (mask.z) ? a.z : b.z, (mask.w) ? a.w : b.w);
#  endif
}

ccl_device_inline int4 load_int4(const int *v)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_loadu_si128((__m128i *)v));
#  else
  return make_int4(v[0], v[1], v[2], v[3]);
#  endif
}
#endif /* __KERNEL_COMPUTE__ */

CCL_NAMESPACE_END

#endif

#line 422 ".kernel_util/COM_kernel_math.h"

#line 1 ".kernel_util/COM_kernel_math_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT2_H__
#define __COM_KERNEL_MATH_FLOAT2_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float2 operator-(const float2 &a);
ccl_device_inline float2 operator*(const float2 &a, const float2 &b);
ccl_device_inline float2 operator*(const float2 &a, float f);
ccl_device_inline float2 operator*(float f, const float2 &a);
ccl_device_inline float2 operator/(float f, const float2 &a);
ccl_device_inline float2 operator/(const float2 &a, float f);
ccl_device_inline float2 operator/(const float2 &a, const float2 &b);
ccl_device_inline float2 operator+(const float2 &a, const float f);
ccl_device_inline float2 operator+(const float2 &a, const float2 &b);
ccl_device_inline float2 operator-(const float2 &a, const float f);
ccl_device_inline float2 operator-(const float2 &a, const float2 &b);
ccl_device_inline float2 operator+=(float2 &a, const float2 &b);
ccl_device_inline float2 operator*=(float2 &a, const float2 &b);
ccl_device_inline float2 operator*=(float2 &a, float f);
ccl_device_inline float2 operator/=(float2 &a, const float2 &b);
ccl_device_inline float2 operator/=(float2 &a, float f);

ccl_device_inline bool operator==(const float2 &a, const float2 &b);
ccl_device_inline bool operator!=(const float2 &a, const float2 &b);

ccl_device_inline float average(const float2 &a);
ccl_device_inline float distance(const float2 &a, const float2 &b);
ccl_device_inline float dot(const float2 &a, const float2 &b);
ccl_device_inline float cross(const float2 &a, const float2 &b);
ccl_device_inline float len(const float2 &a);
ccl_device_inline float2 normalize(const float2 &a);
ccl_device_inline float2 normalize_len(const float2 &a, float *t);
ccl_device_inline float2 safe_normalize(const float2 &a);
ccl_device_inline float2 min(const float2 &a, const float2 &b);
ccl_device_inline float2 max(const float2 &a, const float2 &b);
ccl_device_inline float2 clamp(const float2 &a, const float2 &mn, const float2 &mx);
ccl_device_inline float2 fabs(const float2 &a);
ccl_device_inline float2 as_float2(const float4 &a);
ccl_device_inline float2 interp(const float2 &a, const float2 &b, float t);
ccl_device_inline float2 floor(const float2 &a);
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float2 safe_divide_float2_float(const float2 a, const float b);

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float2 operator-(const float2 &a)
{
  return make_float2(-a.x, -a.y);
}

ccl_device_inline float2 operator*(const float2 &a, const float2 &b)
{
  return make_float2(a.x * b.x, a.y * b.y);
}

ccl_device_inline float2 operator*(const float2 &a, float f)
{
  return make_float2(a.x * f, a.y * f);
}

ccl_device_inline float2 operator*(float f, const float2 &a)
{
  return make_float2(a.x * f, a.y * f);
}

ccl_device_inline float2 operator/(float f, const float2 &a)
{
  return make_float2(f / a.x, f / a.y);
}

ccl_device_inline float2 operator/(const float2 &a, float f)
{
  float invf = 1.0f / f;
  return make_float2(a.x * invf, a.y * invf);
}

ccl_device_inline float2 operator/(const float2 &a, const float2 &b)
{
  return make_float2(a.x / b.x, a.y / b.y);
}

ccl_device_inline float2 operator+(const float2 &a, const float f)
{
  return a + make_float2(f, f);
}

ccl_device_inline float2 operator+(const float2 &a, const float2 &b)
{
  return make_float2(a.x + b.x, a.y + b.y);
}

ccl_device_inline float2 operator-(const float2 &a, const float f)
{
  return a - make_float2(f, f);
}

ccl_device_inline float2 operator-(const float2 &a, const float2 &b)
{
  return make_float2(a.x - b.x, a.y - b.y);
}

ccl_device_inline float2 operator+=(float2 &a, const float2 &b)
{
  return a = a + b;
}

ccl_device_inline float2 operator*=(float2 &a, const float2 &b)
{
  return a = a * b;
}

ccl_device_inline float2 operator*=(float2 &a, float f)
{
  return a = a * f;
}

ccl_device_inline float2 operator/=(float2 &a, const float2 &b)
{
  return a = a / b;
}

ccl_device_inline float2 operator/=(float2 &a, float f)
{
  float invf = 1.0f / f;
  return a = a * invf;
}

ccl_device_inline bool operator==(const float2 &a, const float2 &b)
{
  return (a.x == b.x && a.y == b.y);
}

ccl_device_inline bool operator!=(const float2 &a, const float2 &b)
{
  return !(a == b);
}

ccl_device_inline float average(const float2 &a)
{
  return (a.x + a.y) * (1.0f / 2.0f);
}

ccl_device_inline float distance(const float2 &a, const float2 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float2 &a, const float2 &b)
{
  return a.x * b.x + a.y * b.y;
}

ccl_device_inline float cross(const float2 &a, const float2 &b)
{
  return (a.x * b.y - a.y * b.x);
}

ccl_device_inline float len(const float2 &a)
{
  return sqrtf(dot(a, a));
}

ccl_device_inline float2 normalize(const float2 &a)
{
  return a / len(a);
}

ccl_device_inline float2 normalize_len(const float2 &a, float *t)
{
  *t = len(a);
  return a / (*t);
}

ccl_device_inline float2 safe_normalize(const float2 &a)
{
  float t = len(a);
  return (t != 0.0f) ? a / t : a;
}

ccl_device_inline float2 min(const float2 &a, const float2 &b)
{
  return make_float2(fminf(a.x, b.x), fminf(a.y, b.y));
}

ccl_device_inline float2 max(const float2 &a, const float2 &b)
{
  return make_float2(fmaxf(a.x, b.x), fmaxf(a.y, b.y));
}

ccl_device_inline float2 clamp(const float2 &a, const float2 &mn, const float2 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float2 fabs(const float2 &a)
{
  return make_float2(fabsf(a.x), fabsf(a.y));
}

ccl_device_inline float2 as_float2(const float4 &a)
{
  return make_float2(a.x, a.y);
}

ccl_device_inline float2 interp(const float2 &a, const float2 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float2 mix(const float2 &a, const float2 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float2 floor(const float2 &a)
{
  return make_float2(floorf(a.x), floorf(a.y));
}

#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float2 safe_divide_float2_float(const float2 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float2(0.0f, 0.0f);
}

CCL_NAMESPACE_END

#endif

#line 424 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT3_H__
#define __COM_KERNEL_MATH_FLOAT3_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float3 operator-(const float3 &a);
ccl_device_inline float3 operator*(const float3 &a, const float3 &b);
ccl_device_inline float3 operator*(const float3 &a, const float f);
ccl_device_inline float3 operator*(const float f, const float3 &a);
ccl_device_inline float3 operator/(const float f, const float3 &a);
ccl_device_inline float3 operator/(const float3 &a, const float f);
ccl_device_inline float3 operator/(const float3 &a, const float3 &b);
ccl_device_inline float3 operator+(const float3 &a, const float f);
ccl_device_inline float3 operator+(const float3 &a, const float3 &b);
ccl_device_inline float3 operator-(const float3 &a, const float f);
ccl_device_inline float3 operator-(const float3 &a, const float3 &b);
ccl_device_inline float3 operator+=(float3 &a, const float3 &b);
ccl_device_inline float3 operator-=(float3 &a, const float3 &b);
ccl_device_inline float3 operator*=(float3 &a, const float3 &b);
ccl_device_inline float3 operator*=(float3 &a, float f);
ccl_device_inline float3 operator/=(float3 &a, const float3 &b);
ccl_device_inline float3 operator/=(float3 &a, float f);

ccl_device_inline bool operator==(const float3 &a, const float3 &b);
ccl_device_inline bool operator!=(const float3 &a, const float3 &b);

ccl_device_inline float distance(const float3 &a, const float3 &b);
ccl_device_inline float dot(const float3 &a, const float3 &b);
ccl_device_inline float dot_xy(const float3 &a, const float3 &b);
ccl_device_inline float3 cross(const float3 &a, const float3 &b);
ccl_device_inline float3 normalize(const float3 &a);
ccl_device_inline float3 min(const float3 &a, const float3 &b);
ccl_device_inline float3 max(const float3 &a, const float3 &b);
ccl_device_inline float3 clamp(const float3 &a, const float3 &mn, const float3 &mx);
ccl_device_inline float3 fabs(const float3 &a);
ccl_device_inline float3 mix(const float3 &a, const float3 &b, float t);
ccl_device_inline float3 rcp(const float3 &a);
ccl_device_inline float3 sqrt(const float3 &a);
ccl_device_inline float3 floor(const float3 &a);
ccl_device_inline float3 ceil(const float3 &a);
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float min3(float3 a);
ccl_device_inline float max3(float3 a);
ccl_device_inline float len(const float3 a);
ccl_device_inline float len_squared(const float3 a);

ccl_device_inline float3 reflect(const float3 incident, const float3 normal);
ccl_device_inline float3 project(const float3 v, const float3 v_proj);

ccl_device_inline float3 saturate3(float3 a);
ccl_device_inline float3 safe_normalize(const float3 a);
ccl_device_inline float3 normalize_len(const float3 a, float *t);
ccl_device_inline float3 safe_normalize_len(const float3 a, float *t);
ccl_device_inline float3 safe_divide_float3_float3(const float3 a, const float3 b);
ccl_device_inline float3 safe_divide_float3_float(const float3 a, const float b);
ccl_device_inline float3 interp(float3 a, float3 b, float t);
ccl_device_inline float3 sqr3(float3 a);
ccl_device_inline float reduce_add(const float3 a);
ccl_device_inline float average(const float3 a);
ccl_device_inline bool isequal_float3(const float3 a, const float3 b);

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float3 operator-(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_xor_ps(a.m128, _mm_castsi128_ps(_mm_set1_epi32(0x80000000))));
#  else
  return make_float3(-a.x, -a.y, -a.z);
#  endif
}

ccl_device_inline float3 operator*(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_mul_ps(a.m128, b.m128));
#  else
  return make_float3(a.x * b.x, a.y * b.y, a.z * b.z);
#  endif
}

ccl_device_inline float3 operator*(const float3 &a, const float f)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_mul_ps(a.m128, _mm_set1_ps(f)));
#  else
  return make_float3(a.x * f, a.y * f, a.z * f);
#  endif
}

ccl_device_inline float3 operator*(const float f, const float3 &a)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_mul_ps(_mm_set1_ps(f), a.m128));
#  else
  return make_float3(a.x * f, a.y * f, a.z * f);
#  endif
}

ccl_device_inline float3 operator/(const float f, const float3 &a)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_div_ps(_mm_set1_ps(f), a.m128));
#  else
  return make_float3(f / a.x, f / a.y, f / a.z);
#  endif
}

ccl_device_inline float3 operator/(const float3 &a, const float f)
{
  float invf = 1.0f / f;
  return a * invf;
}

ccl_device_inline float3 operator/(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_div_ps(a.m128, b.m128));
#  else
  return make_float3(a.x / b.x, a.y / b.y, a.z / b.z);
#  endif
}

ccl_device_inline float3 operator+(const float3 &a, const float f)
{
  return a + make_float3(f, f, f);
}

ccl_device_inline float3 operator+(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_add_ps(a.m128, b.m128));
#  else
  return make_float3(a.x + b.x, a.y + b.y, a.z + b.z);
#  endif
}

ccl_device_inline float3 operator-(const float3 &a, const float f)
{
  return a - make_float3(f, f, f);
}

ccl_device_inline float3 operator-(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_sub_ps(a.m128, b.m128));
#  else
  return make_float3(a.x - b.x, a.y - b.y, a.z - b.z);
#  endif
}

ccl_device_inline float3 operator+=(float3 &a, const float3 &b)
{
  return a = a + b;
}

ccl_device_inline float3 operator-=(float3 &a, const float3 &b)
{
  return a = a - b;
}

ccl_device_inline float3 operator*=(float3 &a, const float3 &b)
{
  return a = a * b;
}

ccl_device_inline float3 operator*=(float3 &a, float f)
{
  return a = a * f;
}

ccl_device_inline float3 operator/=(float3 &a, const float3 &b)
{
  return a = a / b;
}

ccl_device_inline float3 operator/=(float3 &a, float f)
{
  float invf = 1.0f / f;
  return a = a * invf;
}

ccl_device_inline bool operator==(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return (_mm_movemask_ps(_mm_cmpeq_ps(a.m128, b.m128)) & 7) == 7;
#  else
  return (a.x == b.x && a.y == b.y && a.z == b.z);
#  endif
}

ccl_device_inline bool operator!=(const float3 &a, const float3 &b)
{
  return !(a == b);
}

ccl_device_inline float distance(const float3 &a, const float3 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_dp_ps(a, b, 0x7F));
#  else
  return a.x * b.x + a.y * b.y + a.z * b.z;
#  endif
}

ccl_device_inline float dot_xy(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_hadd_ps(_mm_mul_ps(a, b), b));
#  else
  return a.x * b.x + a.y * b.y;
#  endif
}

ccl_device_inline float3 cross(const float3 &a, const float3 &b)
{
  float3 r = make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
  return r;
}

ccl_device_inline float3 normalize(const float3 &a)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  __m128 norm = _mm_sqrt_ps(_mm_dp_ps(a.m128, a.m128, 0x7F));
  return float3(_mm_div_ps(a.m128, norm));
#  else
  return a / len(a);
#  endif
}

ccl_device_inline float3 min(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_min_ps(a.m128, b.m128));
#  else
  return make_float3(fminf(a.x, b.x), fminf(a.y, b.y), fminf(a.z, b.z));
#  endif
}

ccl_device_inline float3 max(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_max_ps(a.m128, b.m128));
#  else
  return make_float3(fmaxf(a.x, b.x), fmaxf(a.y, b.y), fmaxf(a.z, b.z));
#  endif
}

ccl_device_inline float3 clamp(const float3 &a, const float3 &mn, const float3 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float3 fabs(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  __m128 mask = _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff));
  return float3(_mm_and_ps(a.m128, mask));
#  else
  return make_float3(fabsf(a.x), fabsf(a.y), fabsf(a.z));
#  endif
}

ccl_device_inline float3 sqrt(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_sqrt_ps(a));
#  else
  return make_float3(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z));
#  endif
}

ccl_device_inline float3 floor(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_floor_ps(a));
#  else
  return make_float3(floorf(a.x), floorf(a.y), floorf(a.z));
#  endif
}

ccl_device_inline float3 ceil(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_ceil_ps(a));
#  else
  return make_float3(ceilf(a.x), ceilf(a.y), ceilf(a.z));
#  endif
}

ccl_device_inline float3 mix(const float3 &a, const float3 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float3 rcp(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  /* Don't use _mm_rcp_ps due to poor precision. */
  return float3(_mm_div_ps(_mm_set_ps1(1.0f), a.m128));
#  else
  return make_float3(1.0f / a.x, 1.0f / a.y, 1.0f / a.z);
#  endif
}
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float min3(const float3 a)
{
  return min(min(a.x, a.y), a.z);
}

ccl_device_inline float max3(const float3 a)
{
  return max(max(a.x, a.y), a.z);
}

ccl_device_inline float len(const float3 a)
{
#if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_sqrt_ss(_mm_dp_ps(a.m128, a.m128, 0x7F)));
#else
  return sqrtf(dot(a, a));
#endif
}

ccl_device_inline float len_squared(const float3 a)
{
  return dot(a, a);
}

ccl_device_inline float3 reflect(const float3 incident, const float3 normal)
{
  float3 unit_normal = normalize(normal);
  return incident - 2.0f * unit_normal * dot(incident, unit_normal);
}

ccl_device_inline float3 project(const float3 v, const float3 v_proj)
{
  float len_squared = dot(v_proj, v_proj);
  return (len_squared != 0.0f) ? (dot(v, v_proj) / len_squared) * v_proj :
                                 make_float3(0.0f, 0.0f, 0.0f);
}

ccl_device_inline float3 saturate3(const float3 a)
{
  return make_float3(saturate(a.x), saturate(a.y), saturate(a.z));
}

ccl_device_inline float3 normalize_len(const float3 a, float *t)
{
  *t = len(a);
  float x = 1.0f / *t;
  return a * x;
}

ccl_device_inline float3 safe_normalize(const float3 a)
{
  float t = len(a);
  return (t != 0.0f) ? a * (1.0f / t) : a;
}

ccl_device_inline float3 safe_normalize_len(const float3 a, float *t)
{
  *t = len(a);
  return (*t != 0.0f) ? a / (*t) : a;
}

ccl_device_inline float3 safe_divide_float3_float3(const float3 a, const float3 b)
{
  return make_float3((b.x != 0.0f) ? a.x / b.x : 0.0f,
                     (b.y != 0.0f) ? a.y / b.y : 0.0f,
                     (b.z != 0.0f) ? a.z / b.z : 0.0f);
}

ccl_device_inline float3 safe_divide_float3_float(const float3 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float3(0.0f, 0.0f, 0.0f);
}

ccl_device_inline float3 interp(const float3 a, const float3 b, const float t)
{
  return a + t * (b - a);
}

ccl_device_inline float3 sqr3(const float3 a)
{
  return a * a;
}

ccl_device_inline float reduce_add(const float3 a)
{
  return (a.x + a.y + a.z);
}

ccl_device_inline float average(const float3 a)
{
  return reduce_add(a) * (1.0f / 3.0f);
}

ccl_device_inline bool isequal_float3(const float3 a, const float3 b)
{
#ifdef __KERNEL_OPENCL__
  return all(a == b);
#else
  return a == b;
#endif
}

ccl_device_inline float3 pow3(const float3 v, const float e)
{
  return make_float3(powf(v.x, e), powf(v.y, e), powf(v.z, e));
}

ccl_device_inline float3 exp3(const float3 v)
{
  return make_float3(expf(v.x), expf(v.y), expf(v.z));
}

ccl_device_inline float3 log3(const float3 v)
{
  return make_float3(logf(v.x), logf(v.y), logf(v.z));
}

ccl_device_inline int3 quick_floor_to_int3(const float3 a)
{
#ifdef __KERNEL_SSE__
  int3 b = int3(_mm_cvttps_epi32(a.m128));
  int3 isneg = int3(_mm_castps_si128(_mm_cmplt_ps(a.m128, _mm_set_ps1(0.0f))));
  /* Unsaturated add 0xffffffff is the same as subtract -1. */
  return b + isneg;
#else
  return make_int3(quick_floor_to_int(a.x), quick_floor_to_int(a.y), quick_floor_to_int(a.z));
#endif
}

ccl_device_inline bool isfinite3_safe(const float3 v)
{
  return isfinite_safe(v.x) && isfinite_safe(v.y) && isfinite_safe(v.z);
}

ccl_device_inline float3 ensure_finite3(float3 v)
{
  if (!isfinite_safe(v.x))
    v.x = 0.0f;
  if (!isfinite_safe(v.y))
    v.y = 0.0f;
  if (!isfinite_safe(v.z))
    v.z = 0.0f;
  return v;
}

CCL_NAMESPACE_END

#endif

#line 425 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT4_H__
#define __COM_KERNEL_MATH_FLOAT4_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float4 operator-(const float4 &a);
ccl_device_inline float4 operator*(const float4 &a, const float4 &b);
ccl_device_inline float4 operator*(const float4 &a, const float f);
ccl_device_inline float4 operator*(const float f, const float4 &a);
ccl_device_inline float4 operator/(const float4 &a, float f);
ccl_device_inline float4 operator/(const float f, const float4 &a);
ccl_device_inline float4 operator/(const float4 &a, const float4 &b);
ccl_device_inline float4 operator+(const float4 &a, const float f);
ccl_device_inline float4 operator+(const float f, const float4 &a);
ccl_device_inline float4 operator+(const float4 &a, const float4 &b);
ccl_device_inline float4 operator-(const float4 &a, const float f);
ccl_device_inline float4 operator-(const float f, const float4 &a);
ccl_device_inline float4 operator-(const float4 &a, const float4 &b);
ccl_device_inline float4 operator+=(float4 &a, const float4 &b);
ccl_device_inline float4 operator*=(float4 &a, const float4 &b);
ccl_device_inline float4 operator*=(float4 &a, const float f);
ccl_device_inline float4 operator/=(float4 &a, const float f);

ccl_device_inline int4 operator<(const float4 &a, const float4 &b);
ccl_device_inline int4 operator>(const float4 &a, const float4 &b);
ccl_device_inline int4 operator>=(const float4 &a, const float4 &b);
ccl_device_inline int4 operator<=(const float4 &a, const float4 &b);
ccl_device_inline int4 operator==(const float4 &a, const float4 &b);
ccl_device_inline int4 operator!=(const float4 &a, const float4 &b);

ccl_device_inline float distance(const float4 &a, const float4 &b);
ccl_device_inline float dot(const float4 &a, const float4 &b);
ccl_device_inline float len_squared(const float4 &a);
ccl_device_inline float4 rcp(const float4 &a);
ccl_device_inline float4 sqrt(const float4 &a);
ccl_device_inline float4 sqr(const float4 &a);
ccl_device_inline float4 cross(const float4 &a, const float4 &b);
ccl_device_inline float average(const float4 &a);
ccl_device_inline float len(const float4 &a);
ccl_device_inline float4 normalize(const float4 &a);
ccl_device_inline float4 safe_normalize(const float4 &a);
ccl_device_inline float4 min(const float4 &a, const float4 &b);
ccl_device_inline float4 min(const float4 &a, const float b);
ccl_device_inline float4 max(const float4 &a, const float4 &b);
ccl_device_inline float4 max(const float4 &a, const float b);
ccl_device_inline float4 clamp(const float4 &a, const float4 &mn, const float4 &mx);
ccl_device_inline float4 clamp(const float4 &a, const float mn, const float mx);
ccl_device_inline float4 fabs(const float4 &a);
ccl_device_inline float4 floor(const float4 &a);
ccl_device_inline float4 mix(const float4 &a, const float4 &b, const float t);
#endif /* !__KERNEL_OPENCL__*/

ccl_device_inline float4 safe_divide_float4_float(const float4 a, const float b);
ccl_device_inline float4 clamp_to_normal_f4(const float4 a);

#ifdef __KERNEL_SSE__
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &b);
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &a, const float4 &b);

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &b);

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &a, const float4 &b);
template<> __forceinline const float4 shuffle<2, 3, 2, 3>(const float4 &a, const float4 &b);

#  ifdef __KERNEL_SSE3__
template<> __forceinline const float4 shuffle<0, 0, 2, 2>(const float4 &b);
template<> __forceinline const float4 shuffle<1, 1, 3, 3>(const float4 &b);
#  endif
#endif /* __KERNEL_SSE__ */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline float4 select(const float4 &b_false, const float4 &a_true, const int4 &mask);
ccl_device_inline float4 reduce_min(const float4 &a);
ccl_device_inline float4 reduce_max(const float4 &a);
ccl_device_inline float4 reduce_add(const float4 &a);
#endif /* !__KERNEL_COMPUTE__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float4 operator-(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  __m128 mask = _mm_castsi128_ps(_mm_set1_epi32(0x80000000));
  return float4(_mm_xor_ps(a.m128, mask));
#  else
  return make_float4(-a.x, -a.y, -a.z, -a.w);
#  endif
}

ccl_device_inline float4 operator*(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_mul_ps(a.m128, b.m128));
#  else
  return make_float4(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
#  endif
}

ccl_device_inline float4 operator*(const float4 &a, const float f)
{
#  if defined(__KERNEL_SSE__)
  return a * make_float4_1(f);
#  else
  return make_float4(a.x * f, a.y * f, a.z * f, a.w * f);
#  endif
}

ccl_device_inline float4 operator*(const float f, const float4 &a)
{
  return a * f;
}

ccl_device_inline float4 operator/(const float4 &a, const float f)
{
  return a * (1.0f / f);
}

ccl_device_inline float4 operator/(const float f, const float4 &a)
{
  return make_float4_1(f) / a;
}
ccl_device_inline float4 operator/(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_div_ps(a.m128, b.m128));
#  else
  return make_float4(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
#  endif
}

ccl_device_inline float4 operator+(const float4 &a, const float f)
{
  return a + make_float4(f, f, f, f);
}

ccl_device_inline float4 operator+(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_add_ps(a.m128, b.m128));
#  else
  return make_float4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
#  endif
}

ccl_device_inline float4 operator+(const float f, const float4 &a)
{
  return make_float4(f, f, f, f) + a;
}

ccl_device_inline float4 operator-(const float4 &a, const float f)
{
  return a - make_float4(f, f, f, f);
}

ccl_device_inline float4 operator-(const float f, const float4 &a)
{
  return make_float4(f, f, f, f) - a;
}

ccl_device_inline float4 operator-(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_sub_ps(a.m128, b.m128));
#  else
  return make_float4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
#  endif
}

ccl_device_inline float4 operator+=(float4 &a, const float4 &b)
{
  return a = a + b;
}

ccl_device_inline float4 operator-=(float4 &a, const float4 &b)
{
  return a = a - b;
}

ccl_device_inline float4 operator*=(float4 &a, const float4 &b)
{
  return a = a * b;
}

ccl_device_inline float4 operator*=(float4 &a, const float f)
{
  return a = a * f;
}

ccl_device_inline float4 operator/=(float4 &a, const float f)
{
  return a = a / f;
}

ccl_device_inline int4 operator<(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmplt_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x < b.x, a.y < b.y, a.z < b.z, a.w < b.w);
#  endif
}

ccl_device_inline int4 operator>(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpgt_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x > b.x, a.y > b.y, a.z > b.z, a.w > b.w);
#  endif
}

ccl_device_inline int4 operator>=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpge_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x >= b.x, a.y >= b.y, a.z >= b.z, a.w >= b.w);
#  endif
}

ccl_device_inline int4 operator<=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmple_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x <= b.x, a.y <= b.y, a.z <= b.z, a.w <= b.w);
#  endif
}

ccl_device_inline int4 operator==(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpeq_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w);
#  endif
}

ccl_device_inline int4 operator!=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpneq_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x != b.x, a.y != b.y, a.z != b.z, a.w != b.w);
#  endif
}

ccl_device_inline float distance(const float4 &a, const float4 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float4 &a, const float4 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_dp_ps(a, b, 0xFF));
#  else
  return (a.x * b.x + a.y * b.y) + (a.z * b.z + a.w * b.w);
#  endif
}

ccl_device_inline float len_squared(const float4 &a)
{
  return dot(a, a);
}

ccl_device_inline float4 rcp(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  /* Don't use _mm_rcp_ps due to poor precision. */
  return float4(_mm_div_ps(_mm_set_ps1(1.0f), a.m128));
#  else
  return make_float4(1.0f / a.x, 1.0f / a.y, 1.0f / a.z, 1.0f / a.w);
#  endif
}

ccl_device_inline float4 sqrt(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_sqrt_ps(a.m128));
#  else
  return make_float4(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z), sqrtf(a.w));
#  endif
}

ccl_device_inline float4 sqr(const float4 &a)
{
  return a * a;
}

ccl_device_inline float4 cross(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return (shuffle<1, 2, 0, 0>(a) * shuffle<2, 0, 1, 0>(b)) -
         (shuffle<2, 0, 1, 0>(a) * shuffle<1, 2, 0, 0>(b));
#  else
  return make_float4(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x, 0.0f);
#  endif
}

ccl_device_inline float4 reduce_add(const float4 &a)
{
#  ifdef __KERNEL_SSE__
#    ifdef __KERNEL_SSE3__
  float4 h(_mm_hadd_ps(a.m128, a.m128));
  return float4(_mm_hadd_ps(h.m128, h.m128));
#    else
  float4 h(shuffle<1, 0, 3, 2>(a) + a);
  return shuffle<2, 3, 0, 1>(h) + h;
#    endif
#  else
  float sum = (a.x + a.y) + (a.z + a.w);
  return make_float4(sum, sum, sum, sum);
#  endif
}

ccl_device_inline float average(const float4 &a)
{
  return reduce_add(a).x * 0.25f;
}

ccl_device_inline float len(const float4 &a)
{
  return sqrtf(dot(a, a));
}

ccl_device_inline float4 normalize(const float4 &a)
{
  return a / len(a);
}

ccl_device_inline float4 safe_normalize(const float4 &a)
{
  float t = len(a);
  return (t != 0.0f) ? a / t : a;
}

ccl_device_inline float4 min(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_min_ps(a.m128, b.m128));
#  else
  return make_float4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));
#  endif
}

ccl_device_inline float4 min(const float4 &a, const float b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_min_ps(a.m128, _mm_set1_ps(b)));
#  else
  return make_float4(fminf(a.x, b), fminf(a.y, b), fminf(a.z, b), fminf(a.w, b));
#  endif
}

ccl_device_inline float4 max(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_max_ps(a.m128, b.m128));
#  else
  return make_float4(fmaxf(a.x, b.x), fmaxf(a.y, b.y), fmaxf(a.z, b.z), fmaxf(a.w, b.w));
#  endif
}

ccl_device_inline float4 max(const float4 &a, const float b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_max_ps(a.m128, _mm_set1_ps(b)));
#  else
  return make_float4(fminf(a.x, b), fminf(a.y, b), fminf(a.z, b), fminf(a.w, b));
#  endif
}

ccl_device_inline float4 clamp(const float4 &a, const float4 &mn, const float4 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float4 clamp(const float4 &a, const float mn, const float mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float4 fabs(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_and_ps(a.m128, _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff))));
#  else
  return make_float4(fabsf(a.x), fabsf(a.y), fabsf(a.z), fabsf(a.w));
#  endif
}

ccl_device_inline float4 floor(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_floor_ps(a));
#  else
  return make_float4(floorf(a.x), floorf(a.y), floorf(a.z), floorf(a.w));
#  endif
}

ccl_device_inline float4 mix(const float4 &a, const float4 &b, const float t)
{
  return a + t * (b - a);
}

#endif /* !__KERNEL_COMPUTE__*/

#ifdef __KERNEL_SSE__
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &b)
{
  return float4(_mm_castsi128_ps(
      _mm_shuffle_epi32(_mm_castps_si128(b), _MM_SHUFFLE(index_3, index_2, index_1, index_0))));
}

template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &a, const float4 &b)
{
  return float4(_mm_shuffle_ps(a.m128, b.m128, _MM_SHUFFLE(index_3, index_2, index_1, index_0)));
}

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &b)
{
  return float4(_mm_castpd_ps(_mm_movedup_pd(_mm_castps_pd(b))));
}

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &a, const float4 &b)
{
  return float4(_mm_movelh_ps(a.m128, b.m128));
}

template<> __forceinline const float4 shuffle<2, 3, 2, 3>(const float4 &a, const float4 &b)
{
  return float4(_mm_movehl_ps(b.m128, a.m128));
}

#  ifdef __KERNEL_SSE3__
template<> __forceinline const float4 shuffle<0, 0, 2, 2>(const float4 &b)
{
  return float4(_mm_moveldup_ps(b));
}

template<> __forceinline const float4 shuffle<1, 1, 3, 3>(const float4 &b)
{
  return float4(_mm_movehdup_ps(b));
}
#  endif /* __KERNEL_SSE3__ */
#endif   /* __KERNEL_SSE__ */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline float4 select(const float4 &b_false, const float4 &a_true, const int4 &mask)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_blendv_ps(b_false.m128, a_true.m128, _mm_castsi128_ps(mask.m128)));
#  else
  return make_float4((mask.x) ? a_true.x : b_false.x,
                     (mask.y) ? a_true.y : b_false.y,
                     (mask.z) ? a_true.z : b_false.z,
                     (mask.w) ? a_true.w : b_false.w);
#  endif
}

ccl_device_inline float4 reduce_min(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  float4 h = min(shuffle<1, 0, 3, 2>(a), a);
  return min(shuffle<2, 3, 0, 1>(h), h);
#  else
  return make_float4(min(min(a.x, a.y), min(a.z, a.w)));
#  endif
}

ccl_device_inline float4 reduce_max(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  float4 h = max(shuffle<1, 0, 3, 2>(a), a);
  return max(shuffle<2, 3, 0, 1>(h), h);
#  else
  return make_float4(max(max(a.x, a.y), max(a.z, a.w)));
#  endif
}

#endif /* !__KERNEL_COMPUTE__ */

ccl_device_inline float4 safe_divide_float4_float(const float4 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float4(0.0f, 0.0f, 0.0f, 0.0f);
}

ccl_device_inline float4 clamp_to_normal_f4(const float4 a)
{
  return min(max(a, 0.0f), 1.0f);
}

CCL_NAMESPACE_END

#endif

#line 426 ".kernel_util/COM_kernel_math.h"

CCL_NAMESPACE_BEGIN

#ifndef __KERNEL_OPENCL__
/* Interpolation */

template<class A, class B> A lerp(const A &a, const A &b, const B &t)
{
  return (A)(a * ((B)1 - t) + b * t);
}

#endif /* __KERNEL_OPENCL__ */

/* Triangle */
#ifndef __KERNEL_OPENCL__
ccl_device_inline float triangle_area(const float3 &v1, const float3 &v2, const float3 &v3)
#else
ccl_device_inline float triangle_area(const float3 v1, const float3 v2, const float3 v3)
#endif
{
  return len(cross(v3 - v2, v1 - v2)) * 0.5f;
}

/* Orthonormal vectors */

ccl_device_inline void make_orthonormals(const float3 N, float3 *a, float3 *b)
{
#if 0
  if (fabsf(N.y) >= 0.999f) {
    *a = make_float3(1, 0, 0);
    *b = make_float3(0, 0, 1);
    return;
  }
  if (fabsf(N.z) >= 0.999f) {
    *a = make_float3(1, 0, 0);
    *b = make_float3(0, 1, 0);
    return;
  }
#endif

  if (N.x != N.y || N.x != N.z)
    *a = make_float3(N.z - N.y, N.x - N.z, N.y - N.x);  //(1,1,1)x N
  else
    *a = make_float3(N.z - N.y, N.x + N.z, -N.y - N.x);  //(-1,1,1)x N

  *a = normalize(*a);
  *b = cross(N, *a);
}

/* Color division */

ccl_device_inline float3 safe_invert_color(const float3 a)
{
  float x, y, z;

  x = (a.x != 0.0f) ? 1.0f / a.x : 0.0f;
  y = (a.y != 0.0f) ? 1.0f / a.y : 0.0f;
  z = (a.z != 0.0f) ? 1.0f / a.z : 0.0f;

  return make_float3(x, y, z);
}

ccl_device_inline float3 safe_divide_color(const float3 a, const float3 b)
{
  float x, y, z;

  x = (b.x != 0.0f) ? a.x / b.x : 0.0f;
  y = (b.y != 0.0f) ? a.y / b.y : 0.0f;
  z = (b.z != 0.0f) ? a.z / b.z : 0.0f;

  return make_float3(x, y, z);
}

ccl_device_inline float3 safe_divide_even_color(const float3 a, const float3 b)
{
  float x, y, z;

  x = (b.x != 0.0f) ? a.x / b.x : 0.0f;
  y = (b.y != 0.0f) ? a.y / b.y : 0.0f;
  z = (b.z != 0.0f) ? a.z / b.z : 0.0f;

  /* try to get gray even if b is zero */
  if (b.x == 0.0f) {
    if (b.y == 0.0f) {
      x = z;
      y = z;
    }
    else if (b.z == 0.0f) {
      x = y;
      z = y;
    }
    else
      x = 0.5f * (y + z);
  }
  else if (b.y == 0.0f) {
    if (b.z == 0.0f) {
      y = x;
      z = x;
    }
    else
      y = 0.5f * (x + z);
  }
  else if (b.z == 0.0f) {
    z = 0.5f * (x + y);
  }

  return make_float3(x, y, z);
}

/* Rotation of point around axis and angle */

ccl_device_inline float3 rotate_around_axis(const float3 p, const float3 axis, const float angle)
{
  float costheta = cosf(angle);
  float sintheta = sinf(angle);
  float3 r;

  r.x = ((costheta + (1 - costheta) * axis.x * axis.x) * p.x) +
        (((1 - costheta) * axis.x * axis.y - axis.z * sintheta) * p.y) +
        (((1 - costheta) * axis.x * axis.z + axis.y * sintheta) * p.z);

  r.y = (((1 - costheta) * axis.x * axis.y + axis.z * sintheta) * p.x) +
        ((costheta + (1 - costheta) * axis.y * axis.y) * p.y) +
        (((1 - costheta) * axis.y * axis.z - axis.x * sintheta) * p.z);

  r.z = (((1 - costheta) * axis.x * axis.z - axis.y * sintheta) * p.x) +
        (((1 - costheta) * axis.y * axis.z + axis.x * sintheta) * p.y) +
        ((costheta + (1 - costheta) * axis.z * axis.z) * p.z);

  return r;
}

/* NaN-safe math ops */

ccl_device_inline float safe_sqrtf(const float f)
{
  return sqrtf(max(f, 0.0f));
}

ccl_device_inline float inversesqrtf(const float f)
{
  return (f > 0.0f) ? 1.0f / sqrtf(f) : 0.0f;
}

ccl_device float safe_asinf(const float a)
{
  return asinf(clamp(a, -1.0f, 1.0f));
}

ccl_device float safe_acosf(const float a)
{
  return acosf(clamp(a, -1.0f, 1.0f));
}

ccl_device float compatible_powf(const float x, const float y)
{
#ifdef __KERNEL_COMPUTE__
  if (y == 0.0f) /* x^0 -> 1, including 0^0 */
    return 1.0f;

  /* GPU pow doesn't accept negative x, do manual checks here */
  if (x < 0.0f) {
    if (fmodf(-y, 2.0f) == 0.0f)
      return powf(-x, y);
    else
      return -powf(-x, y);
  }
  else if (x == 0.0f)
    return 0.0f;
#endif
  return powf(x, y);
}

ccl_device float safe_powf(const float a, const float b)
{
  if (UNLIKELY(a < 0.0f && b != float_to_int(b)))
    return 0.0f;

  return compatible_powf(a, b);
}

ccl_device float safe_divide(const float a, const float b)
{
  return (b != 0.0f) ? a / b : 0.0f;
}

ccl_device float safe_logf(const float a, const float b)
{
  if (UNLIKELY(a <= 0.0f || b <= 0.0f))
    return 0.0f;

  return safe_divide(logf(a), logf(b));
}

ccl_device float safe_modulo(const float a, const float b)
{
  return (b != 0.0f) ? fmodf(a, b) : 0.0f;
}

ccl_device_inline float sqr(const float a)
{
  return a * a;
}

ccl_device_inline float pow20(const float a)
{
  return sqr(sqr(sqr(sqr(a)) * a));
}

ccl_device_inline float pow22(float a)
{
  return sqr(a * sqr(sqr(sqr(a)) * a));
}

ccl_device_inline float beta(float x, float y)
{
#ifndef __KERNEL_OPENCL__
  return expf(lgammaf(x) + lgammaf(y) - lgammaf(x + y));
#else
  return expf(lgamma(x) + lgamma(y) - lgamma(x + y));
#endif
}

ccl_device_inline float xor_signmask(const float x, const int y)
{
  return __int_as_float(__float_as_int(x) ^ y);
}

ccl_device float bits_to_01(const uint bits)
{
  return bits * (1.0f / (float)0xFFFFFFFF);
}

ccl_device_inline uint count_leading_zeros(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return __clz(x);
#elif defined(__KERNEL_OPENCL__)
  return clz(x);
#else
  assert(x != 0);
#  ifdef _MSC_VER
  unsigned long leading_zero = 0;
  _BitScanReverse(&leading_zero, x);
  return (31 - leading_zero);
#  else
  return __builtin_clz(x);
#  endif
#endif
}

ccl_device_inline uint count_trailing_zeros(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return (__ffs(x) - 1);
#elif defined(__KERNEL_OPENCL__)
  return (31 - count_leading_zeros(x & -x));
#else
  assert(x != 0);
#  ifdef _MSC_VER
  unsigned long ctz = 0;
  _BitScanForward(&ctz, x);
  return ctz;
#  else
  return __builtin_ctz(x);
#  endif
#endif
}

ccl_device_inline uint find_first_set(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return __ffs(x);
#elif defined(__KERNEL_OPENCL__)
  return (x != 0) ? (32 - count_leading_zeros(x & (-x))) : 0;
#else
#  ifdef _MSC_VER
  return (x != 0) ? (32 - count_leading_zeros(x & (-x))) : 0;
#  else
  return __builtin_ffs(x);
#  endif
#endif
}

/* projections */
ccl_device_inline float2 map_to_tube(const float3 co)
{
  float len, u, v;
  len = sqrtf(co.x * co.x + co.y * co.y);
  if (len > 0.0f) {
    u = (1.0f - (atan2f(co.x / len, co.y / len) / M_PI_F)) * 0.5f;
    v = (co.z + 1.0f) * 0.5f;
  }
  else {
    u = v = 0.0f;
  }
  return make_float2(u, v);
}

ccl_device_inline float2 map_to_sphere(const float3 co)
{
  float l = len(co);
  float u, v;
  if (l > 0.0f) {
    if (UNLIKELY(co.x == 0.0f && co.y == 0.0f)) {
      u = 0.0f; /* othwise domain error */
    }
    else {
      u = (1.0f - atan2f(co.x, co.y) / M_PI_F) / 2.0f;
    }
    v = 1.0f - safe_acosf(co.z / l) / M_PI_F;
  }
  else {
    u = v = 0.0f;
  }
  return make_float2(u, v);
}

/* Compares two floats.
 * Returns true if their absolute difference is smaller than abs_diff (for numbers near zero)
 * or their relative difference is less than ulp_diff ULPs.
 * Based on
 * https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
 */

ccl_device_inline float compare_floats(const float a,
                                       const float b,
                                       const float abs_diff,
                                       const int ulp_diff)
{
  if (fabsf(a - b) < abs_diff) {
    return true;
  }

  if ((a < 0.0f) != (b < 0.0f)) {
    return false;
  }

  return (abs(__float_as_int(a) - __float_as_int(b)) < ulp_diff);
}

ccl_device_inline float clamp_to_normal(const float a)
{
  return min(max(a, 0.0f), 1.0f);
}

ccl_device_inline float4 interp_f4f4(const float4 a, const float4 b, const float t)
{
  const float s = 1.0f - t;

  return s * a + t * b;
}

CCL_NAMESPACE_END

#endif

#line 4 ".kernel_util/COM_kernel_geom.h"

/* All this methods has been taken from blendlib math_geom.c file.
 * They are adapted for vectors and kernel compatibility */
CCL_NAMESPACE_BEGIN

#define KEY_LINEAR 0
#define KEY_CARDINAL 1
#define KEY_BSPLINE 2
#define KEY_CATMULL_ROM 3

ccl_device_inline float2 closest_to_line_v2(const float2 p, const float2 l1, const float2 l2)
{
  float2 u = l2 - l1;
  float2 h = p - l1;
  float lambda = dot(u, h) / dot(u, u);
  return l1 + u * lambda;
}

ccl_device_inline void key_curve_position_weights(const float t, float data[4], const int type)
{
  float t2, t3, fc;

  if (type == KEY_LINEAR) {
    data[0] = 0.0f;
    data[1] = -t + 1.0f;
    data[2] = t;
    data[3] = 0.0f;
  }
  else if (type == KEY_CARDINAL) {
    t2 = t * t;
    t3 = t2 * t;
    fc = 0.71f;

    data[0] = -fc * t3 + 2.0f * fc * t2 - fc * t;
    data[1] = (2.0f - fc) * t3 + (fc - 3.0f) * t2 + 1.0f;
    data[2] = (fc - 2.0f) * t3 + (3.0f - 2.0f * fc) * t2 + fc * t;
    data[3] = fc * t3 - fc * t2;
  }
  else if (type == KEY_BSPLINE) {
    t2 = t * t;
    t3 = t2 * t;

    data[0] = -0.16666666f * t3 + 0.5f * t2 - 0.5f * t + 0.16666666f;
    data[1] = 0.5f * t3 - t2 + 0.66666666f;
    data[2] = -0.5f * t3 + 0.5f * t2 + 0.5f * t + 0.16666666f;
    data[3] = 0.16666666f * t3;
  }
  else if (type == KEY_CATMULL_ROM) {
    t2 = t * t;
    t3 = t2 * t;
    fc = 0.5f;

    data[0] = -fc * t3 + 2.0f * fc * t2 - fc * t;
    data[1] = (2.0f - fc) * t3 + (fc - 3.0f) * t2 + 1.0f;
    data[2] = (fc - 2.0f) * t3 + (3.0f - 2.0f * fc) * t2 + fc * t;
    data[3] = fc * t3 - fc * t2;
  }
}

CCL_NAMESPACE_END

#endif

#line 154 ".COM_kernel_opencl.h"
#line 1 ".kernel_util/COM_kernel_math.h"
#ifndef __COM_KERNEL_MATH_H__
#define __COM_KERNEL_MATH_H__

/* Math
 *
 * Basic math functions on scalar and vector types. This header is used by
 * both the kernel code when compiled as C++, and other C++ non-kernel code. */

#ifndef __KERNEL_COMPUTE__
#  include <cmath>
#endif

#ifndef __KERNEL_OPENCL__
#  include <float.h>
#  include <math.h>
#  include <stdio.h>
#endif /* __KERNEL_OPENCL__ */

#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 19 ".kernel_util/COM_kernel_math.h"

CCL_NAMESPACE_BEGIN

/* Float Pi variations */

/* Division */
#ifndef M_PI_F
#  define M_PI_F (3.1415926535897932f) /* pi */
#endif
#ifndef M_PI_2_F
#  define M_PI_2_F (1.5707963267948966f) /* pi/2 */
#endif
#ifndef M_PI_4_F
#  define M_PI_4_F (0.7853981633974830f) /* pi/4 */
#endif
#ifndef M_1_PI_F
#  define M_1_PI_F (0.3183098861837067f) /* 1/pi */
#endif
#ifndef M_2_PI_F
#  define M_2_PI_F (0.6366197723675813f) /* 2/pi */
#endif
#ifndef M_1_2PI_F
#  define M_1_2PI_F (0.1591549430918953f) /* 1/(2*pi) */
#endif
#ifndef M_SQRT_PI_8_F
#  define M_SQRT_PI_8_F (0.6266570686577501f) /* sqrt(pi/8) */
#endif
#ifndef M_LN_2PI_F
#  define M_LN_2PI_F (1.8378770664093454f) /* ln(2*pi) */
#endif

/* Multiplication */
#ifndef M_2PI_F
#  define M_2PI_F (6.2831853071795864f) /* 2*pi */
#endif
#ifndef M_4PI_F
#  define M_4PI_F (12.566370614359172f) /* 4*pi */
#endif

/* Float sqrt variations */
#ifndef M_SQRT2_F
#  define M_SQRT2_F (1.4142135623730950f) /* sqrt(2) */
#endif
#ifndef M_LN2_F
#  define M_LN2_F (0.6931471805599453f) /* ln(2) */
#endif
#ifndef M_LN10_F
#  define M_LN10_F (2.3025850929940457f) /* ln(10) */
#endif

#ifndef RAD2DEGF
#  define RAD2DEGF(_rad) ((_rad) * (float)(180.0f / M_PI_F))
#endif
#ifndef DEG2RADF
#  define DEG2RADF(_deg) ((_deg) * (float)(M_PI_F / 180.0f))
#endif

/* Scalar */

#ifdef _WIN32
#  ifndef __KERNEL_OPENCL__
ccl_device_inline float fmaxf(float a, float b)
{
  return (a > b) ? a : b;
}

ccl_device_inline float fminf(float a, float b)
{
  return (a < b) ? a : b;
}
#  endif /* !__KERNEL_OPENCL__ */
#endif   /* _WIN32 */

#ifndef __KERNEL_COMPUTE__
using std::isfinite;
using std::isnan;
using std::sqrt;

ccl_device_inline int abs(const int x)
{
  return (x > 0) ? x : -x;
}

ccl_device_inline int max(const int a, const int b)
{
  return (a > b) ? a : b;
}

ccl_device_inline int min(const int a, const int b)
{
  return (a < b) ? a : b;
}

ccl_device_inline float max(const float a, const float b)
{
  return (a > b) ? a : b;
}

ccl_device_inline float min(const float a, const float b)
{
  return (a < b) ? a : b;
}
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline float fminf3(const float a, const float b, const float c)
{
  return fminf(fminf(a, b), c);
}

ccl_device_inline float fmaxf3(const float a, const float b, const float c)
{
  return fmaxf(fmaxf(a, b), c);
}

ccl_device_inline float fminf4(const float a, const float b, const float c, const float d)
{
  return fminf(fminf(a, b), fminf(c, d));
}

ccl_device_inline float fmaxf4(const float a, const float b, const float c, const float d)
{
  return fmaxf(fmaxf(a, b), fmaxf(c, d));
}

#ifndef __KERNEL_OPENCL__
/* Int/Float conversion */

ccl_device_inline int as_int(uint i)
{
  union {
    uint ui;
    int i;
  } u;
  u.ui = i;
  return u.i;
}

ccl_device_inline uint as_uint(int i)
{
  union {
    uint ui;
    int i;
  } u;
  u.i = i;
  return u.ui;
}

ccl_device_inline uint as_uint(float f)
{
  union {
    uint i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline int __float_as_int(float f)
{
  union {
    int i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline float __int_as_float(int i)
{
  union {
    int i;
    float f;
  } u;
  u.i = i;
  return u.f;
}

ccl_device_inline uint __float_as_uint(float f)
{
  union {
    uint i;
    float f;
  } u;
  u.f = f;
  return u.i;
}

ccl_device_inline float __uint_as_float(uint i)
{
  union {
    uint i;
    float f;
  } u;
  u.i = i;
  return u.f;
}

ccl_device_inline int4 __float4_as_int4(float4 f)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(f.m128));
#  else
  return make_int4(
      __float_as_int(f.x), __float_as_int(f.y), __float_as_int(f.z), __float_as_int(f.w));
#  endif
}

ccl_device_inline float4 __int4_as_float4(int4 i)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_castsi128_ps(i.m128));
#  else
  return make_float4(
      __int_as_float(i.x), __int_as_float(i.y), __int_as_float(i.z), __int_as_float(i.w));
#  endif
}
#endif /* __KERNEL_OPENCL__ */

/* Versions of functions which are safe for fast math. */
ccl_device_inline bool isnan_safe(const float f)
{
  unsigned int x = __float_as_uint(f);
  return (x << 1) > 0xff000000u;
}

ccl_device_inline bool isfinite_safe(const float f)
{
  /* By IEEE 754 rule, 2*Inf equals Inf */
  unsigned int x = __float_as_uint(f);
  return (f == f) && (x == 0 || x == (1u << 31) || (f != 2.0f * f)) && !((x << 1) > 0xff000000u);
}

ccl_device_inline float ensure_finite(const float v)
{
  return isfinite_safe(v) ? v : 0.0f;
}

#ifndef __KERNEL_OPENCL__
ccl_device_inline int clamp(const int a, const int mn, const int mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float clamp(const float a, const float mn, const float mx)
{
  return fminf(fmaxf(a, mn), mx);
}

ccl_device_inline float mix(const float a, const float b, const float t)
{
  return a + t * (b - a);
}

ccl_device_inline float smoothstep(const float edge0, const float edge1, const float x)
{
  float result;
  if (x < edge0)
    result = 0.0f;
  else if (x >= edge1)
    result = 1.0f;
  else {
    float t = (x - edge0) / (edge1 - edge0);
    result = (3.0f - 2.0f * t) * (t * t);
  }
  return result;
}

#endif /* __KERNEL_OPENCL__ */

#ifndef __KERNEL_CUDA__
ccl_device_inline float saturate(const float a)
{
  return clamp(a, 0.0f, 1.0f);
}
#endif /* __KERNEL_CUDA__ */

ccl_device_inline int float_to_int(const float f)
{
  return (int)f;
}

ccl_device_inline int floor_to_int(const float f)
{
  return float_to_int(floorf(f));
}

ccl_device_inline int quick_floor_to_int(const float x)
{
  return float_to_int(x) - ((x < 0) ? 1 : 0);
}

ccl_device_inline float floorfrac(const float x, int *i)
{
  *i = quick_floor_to_int(x);
  return x - *i;
}

ccl_device_inline int ceil_to_int(const float f)
{
  return float_to_int(ceilf(f));
}

ccl_device_inline float fractf(const float x)
{
  return x - floorf(x);
}

/* Adapted from godotengine math_funcs.h. */
ccl_device_inline float wrapf(const float value, const float max, const float min)
{
  float range = max - min;
  return (range != 0.0f) ? value - (range * floorf((value - min) / range)) : min;
}

ccl_device_inline float pingpongf(const float a, const float b)
{
  return (b != 0.0f) ? fabsf(fractf((a - b) / (b * 2.0f)) * b * 2.0f - b) : 0.0f;
}

ccl_device_inline float smoothminf(const float a, const float b, const float k)
{
  if (k != 0.0f) {
    float h = fmaxf(k - fabsf(a - b), 0.0f) / k;
    return fminf(a, b) - h * h * h * k * (1.0f / 6.0f);
  }
  else {
    return fminf(a, b);
  }
}

ccl_device_inline float signf(const float f)
{
  return (f < 0.0f) ? -1.0f : 1.0f;
}

ccl_device_inline float nonzerof(const float f, const float eps)
{
  if (fabsf(f) < eps)
    return signf(f) * eps;
  else
    return f;
}

/* Signum function testing for zero. Matches GLSL and OSL functions. */
ccl_device_inline float compatible_signf(const float f)
{
  if (f == 0.0f) {
    return 0.0f;
  }
  else {
    return signf(f);
  }
}

ccl_device_inline float smoothstepf(const float f)
{
  float ff = f * f;
  return (3.0f * ff - 2.0f * ff * f);
}

ccl_device_inline int mod(const int x, const int m)
{
  return (x % m + m) % m;
}

ccl_device_inline float3 float2_to_float3(const float2 a)
{
  return make_float3(a.x, a.y, 0.0f);
}

ccl_device_inline float3 float4_to_float3(const float4 a)
{
  return make_float3(a.x, a.y, a.z);
}

ccl_device_inline float4 float3_to_float4(const float3 a)
{
  return make_float4(a.x, a.y, a.z, 1.0f);
}

ccl_device_inline float inverse_lerp(const float a, const float b, const float x)
{
  return (x - a) / (b - a);
}

/* Cubic interpolation between b and c, a and d are the previous and next point. */
ccl_device_inline float cubic_interp(
    const float a, const float b, const float c, const float d, const float x)
{
  return 0.5f *
             (((d + 3.0f * (b - c) - a) * x + (2.0f * a - 5.0f * b + 4.0f * c - d)) * x +
              (c - a)) *
             x +
         b;
}

CCL_NAMESPACE_END

#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 418 ".kernel_util/COM_kernel_math.h"

#line 1 ".kernel_util/COM_kernel_math_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT2_H__
#define __COM_KERNEL_MATH_INT2_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline bool operator==(const int2 a, const int2 b);
ccl_device_inline int2 operator+(const int2 &a, const int2 &b);
ccl_device_inline int2 operator+=(int2 &a, const int2 &b);
ccl_device_inline int2 operator-(const int2 &a, const int2 &b);
ccl_device_inline int2 operator*(const int2 &a, const int2 &b);
ccl_device_inline int2 operator/(const int2 &a, const int2 &b);
#endif /* !__KERNEL_OPENCL__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline bool operator==(const int2 a, const int2 b)
{
  return (a.x == b.x && a.y == b.y);
}

ccl_device_inline int2 operator+(const int2 &a, const int2 &b)
{
  return make_int2(a.x + b.x, a.y + b.y);
}

ccl_device_inline int2 operator+=(int2 &a, const int2 &b)
{
  return a = a + b;
}

ccl_device_inline int2 operator-(const int2 &a, const int2 &b)
{
  return make_int2(a.x - b.x, a.y - b.y);
}

ccl_device_inline int2 operator*(const int2 &a, const int2 &b)
{
  return make_int2(a.x * b.x, a.y * b.y);
}

ccl_device_inline int2 operator/(const int2 &a, const int2 &b)
{
  return make_int2(a.x / b.x, a.y / b.y);
}
#endif /* !__KERNEL_OPENCL__ */

CCL_NAMESPACE_END

#endif

#line 420 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT3_H__
#define __COM_KERNEL_MATH_INT3_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline int3 min(int3 a, int3 b);
ccl_device_inline int3 max(int3 a, int3 b);
ccl_device_inline int3 clamp(const int3 &a, int mn, int mx);
ccl_device_inline int3 clamp(const int3 &a, int3 &mn, int mx);
#endif /* !__KERNEL_OPENCL__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline int3 min(int3 a, int3 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int3(_mm_min_epi32(a.m128, b.m128));
#  else
  return make_int3(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));
#  endif
}

ccl_device_inline int3 max(int3 a, int3 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int3(_mm_max_epi32(a.m128, b.m128));
#  else
  return make_int3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));
#  endif
}

ccl_device_inline int3 clamp(const int3 &a, int mn, int mx)
{
#  ifdef __KERNEL_SSE__
  return min(max(a, make_int3_1(mn)), make_int3_1(mx));
#  else
  return make_int3(clamp(a.x, mn, mx), clamp(a.y, mn, mx), clamp(a.z, mn, mx));
#  endif
}

ccl_device_inline int3 clamp(const int3 &a, int3 &mn, int mx)
{
#  ifdef __KERNEL_SSE__
  return min(max(a, mn), make_int3_1(mx));
#  else
  return make_int3(clamp(a.x, mn.x, mx), clamp(a.y, mn.y, mx), clamp(a.z, mn.z, mx));
#  endif
}

ccl_device_inline bool operator==(const int3 &a, const int3 &b)
{
  return a.x == b.x && a.y == b.y && a.z == b.z;
}

ccl_device_inline bool operator!=(const int3 &a, const int3 &b)
{
  return !(a == b);
}

ccl_device_inline bool operator<(const int3 &a, const int3 &b)
{
  return a.x < b.x && a.y < b.y && a.z < b.z;
}

ccl_device_inline int3 operator+(const int3 &a, const int3 &b)
{
#  ifdef __KERNEL_SSE__
  return int3(_mm_add_epi32(a.m128, b.m128));
#  else
  return make_int3(a.x + b.x, a.y + b.y, a.z + b.z);
#  endif
}

ccl_device_inline int3 operator-(const int3 &a, const int3 &b)
{
#  ifdef __KERNEL_SSE__
  return int3(_mm_sub_epi32(a.m128, b.m128));
#  else
  return make_int3(a.x - b.x, a.y - b.y, a.z - b.z);
#  endif
}
#endif /* !__KERNEL_OPENCL__ */

CCL_NAMESPACE_END

#endif /* __COM_kernel_MATH_INT3_H__ */

#line 421 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_INT4_H__
#define __COM_KERNEL_MATH_INT4_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline int4 operator+(const int4 &a, const int4 &b);
ccl_device_inline int4 operator+=(int4 &a, const int4 &b);
ccl_device_inline int4 operator>>(const int4 &a, int i);
ccl_device_inline int4 operator<<(const int4 &a, int i);
ccl_device_inline int4 operator<(const int4 &a, const int4 &b);
ccl_device_inline int4 operator>=(const int4 &a, const int4 &b);
ccl_device_inline int4 operator&(const int4 &a, const int4 &b);
ccl_device_inline int4 min(int4 a, int4 b);
ccl_device_inline int4 max(int4 a, int4 b);
ccl_device_inline int4 clamp(const int4 &a, const int4 &mn, const int4 &mx);
ccl_device_inline int4 select(const int4 &mask, const int4 &a, const int4 &b);
#endif /* __KERNEL_COMPUTE__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline int4 operator+(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_add_epi32(a.m128, b.m128));
#  else
  return make_int4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
#  endif
}

ccl_device_inline int4 operator+=(int4 &a, const int4 &b)
{
  return a = a + b;
}

ccl_device_inline int4 operator>>(const int4 &a, int i)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_srai_epi32(a.m128, i));
#  else
  return make_int4(a.x >> i, a.y >> i, a.z >> i, a.w >> i);
#  endif
}

ccl_device_inline int4 operator<<(const int4 &a, int i)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_slli_epi32(a.m128, i));
#  else
  return make_int4(a.x << i, a.y << i, a.z << i, a.w << i);
#  endif
}

ccl_device_inline int4 operator<(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_cmplt_epi32(a.m128, b.m128));
#  else
  return make_int4(a.x < b.x, a.y < b.y, a.z < b.z, a.w < b.w);
#  endif
}

ccl_device_inline int4 operator>=(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_xor_si128(_mm_set1_epi32(0xffffffff), _mm_cmplt_epi32(a.m128, b.m128)));
#  else
  return make_int4(a.x >= b.x, a.y >= b.y, a.z >= b.z, a.w >= b.w);
#  endif
}

ccl_device_inline int4 operator&(const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_and_si128(a.m128, b.m128));
#  else
  return make_int4(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
#  endif
}

ccl_device_inline int4 min(int4 a, int4 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int4(_mm_min_epi32(a.m128, b.m128));
#  else
  return make_int4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));
#  endif
}

ccl_device_inline int4 max(int4 a, int4 b)
{
#  if defined(__KERNEL_SSE__) && defined(__KERNEL_SSE41__)
  return int4(_mm_max_epi32(a.m128, b.m128));
#  else
  return make_int4(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z), max(a.w, b.w));
#  endif
}

ccl_device_inline int4 clamp(const int4 &a, const int4 &mn, const int4 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline int4 select(const int4 &mask, const int4 &a, const int4 &b)
{
#  ifdef __KERNEL_SSE__
  const __m128 m = _mm_cvtepi32_ps(mask);
  /* TODO(sergey): avoid cvt. */
  return int4(_mm_castps_si128(
      _mm_or_ps(_mm_and_ps(m, _mm_castsi128_ps(a)), _mm_andnot_ps(m, _mm_castsi128_ps(b)))));
#  else
  return make_int4(
      (mask.x) ? a.x : b.x, (mask.y) ? a.y : b.y, (mask.z) ? a.z : b.z, (mask.w) ? a.w : b.w);
#  endif
}

ccl_device_inline int4 load_int4(const int *v)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_loadu_si128((__m128i *)v));
#  else
  return make_int4(v[0], v[1], v[2], v[3]);
#  endif
}
#endif /* __KERNEL_COMPUTE__ */

CCL_NAMESPACE_END

#endif

#line 422 ".kernel_util/COM_kernel_math.h"

#line 1 ".kernel_util/COM_kernel_math_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT2_H__
#define __COM_KERNEL_MATH_FLOAT2_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float2 operator-(const float2 &a);
ccl_device_inline float2 operator*(const float2 &a, const float2 &b);
ccl_device_inline float2 operator*(const float2 &a, float f);
ccl_device_inline float2 operator*(float f, const float2 &a);
ccl_device_inline float2 operator/(float f, const float2 &a);
ccl_device_inline float2 operator/(const float2 &a, float f);
ccl_device_inline float2 operator/(const float2 &a, const float2 &b);
ccl_device_inline float2 operator+(const float2 &a, const float f);
ccl_device_inline float2 operator+(const float2 &a, const float2 &b);
ccl_device_inline float2 operator-(const float2 &a, const float f);
ccl_device_inline float2 operator-(const float2 &a, const float2 &b);
ccl_device_inline float2 operator+=(float2 &a, const float2 &b);
ccl_device_inline float2 operator*=(float2 &a, const float2 &b);
ccl_device_inline float2 operator*=(float2 &a, float f);
ccl_device_inline float2 operator/=(float2 &a, const float2 &b);
ccl_device_inline float2 operator/=(float2 &a, float f);

ccl_device_inline bool operator==(const float2 &a, const float2 &b);
ccl_device_inline bool operator!=(const float2 &a, const float2 &b);

ccl_device_inline float average(const float2 &a);
ccl_device_inline float distance(const float2 &a, const float2 &b);
ccl_device_inline float dot(const float2 &a, const float2 &b);
ccl_device_inline float cross(const float2 &a, const float2 &b);
ccl_device_inline float len(const float2 &a);
ccl_device_inline float2 normalize(const float2 &a);
ccl_device_inline float2 normalize_len(const float2 &a, float *t);
ccl_device_inline float2 safe_normalize(const float2 &a);
ccl_device_inline float2 min(const float2 &a, const float2 &b);
ccl_device_inline float2 max(const float2 &a, const float2 &b);
ccl_device_inline float2 clamp(const float2 &a, const float2 &mn, const float2 &mx);
ccl_device_inline float2 fabs(const float2 &a);
ccl_device_inline float2 as_float2(const float4 &a);
ccl_device_inline float2 interp(const float2 &a, const float2 &b, float t);
ccl_device_inline float2 floor(const float2 &a);
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float2 safe_divide_float2_float(const float2 a, const float b);

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float2 operator-(const float2 &a)
{
  return make_float2(-a.x, -a.y);
}

ccl_device_inline float2 operator*(const float2 &a, const float2 &b)
{
  return make_float2(a.x * b.x, a.y * b.y);
}

ccl_device_inline float2 operator*(const float2 &a, float f)
{
  return make_float2(a.x * f, a.y * f);
}

ccl_device_inline float2 operator*(float f, const float2 &a)
{
  return make_float2(a.x * f, a.y * f);
}

ccl_device_inline float2 operator/(float f, const float2 &a)
{
  return make_float2(f / a.x, f / a.y);
}

ccl_device_inline float2 operator/(const float2 &a, float f)
{
  float invf = 1.0f / f;
  return make_float2(a.x * invf, a.y * invf);
}

ccl_device_inline float2 operator/(const float2 &a, const float2 &b)
{
  return make_float2(a.x / b.x, a.y / b.y);
}

ccl_device_inline float2 operator+(const float2 &a, const float f)
{
  return a + make_float2(f, f);
}

ccl_device_inline float2 operator+(const float2 &a, const float2 &b)
{
  return make_float2(a.x + b.x, a.y + b.y);
}

ccl_device_inline float2 operator-(const float2 &a, const float f)
{
  return a - make_float2(f, f);
}

ccl_device_inline float2 operator-(const float2 &a, const float2 &b)
{
  return make_float2(a.x - b.x, a.y - b.y);
}

ccl_device_inline float2 operator+=(float2 &a, const float2 &b)
{
  return a = a + b;
}

ccl_device_inline float2 operator*=(float2 &a, const float2 &b)
{
  return a = a * b;
}

ccl_device_inline float2 operator*=(float2 &a, float f)
{
  return a = a * f;
}

ccl_device_inline float2 operator/=(float2 &a, const float2 &b)
{
  return a = a / b;
}

ccl_device_inline float2 operator/=(float2 &a, float f)
{
  float invf = 1.0f / f;
  return a = a * invf;
}

ccl_device_inline bool operator==(const float2 &a, const float2 &b)
{
  return (a.x == b.x && a.y == b.y);
}

ccl_device_inline bool operator!=(const float2 &a, const float2 &b)
{
  return !(a == b);
}

ccl_device_inline float average(const float2 &a)
{
  return (a.x + a.y) * (1.0f / 2.0f);
}

ccl_device_inline float distance(const float2 &a, const float2 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float2 &a, const float2 &b)
{
  return a.x * b.x + a.y * b.y;
}

ccl_device_inline float cross(const float2 &a, const float2 &b)
{
  return (a.x * b.y - a.y * b.x);
}

ccl_device_inline float len(const float2 &a)
{
  return sqrtf(dot(a, a));
}

ccl_device_inline float2 normalize(const float2 &a)
{
  return a / len(a);
}

ccl_device_inline float2 normalize_len(const float2 &a, float *t)
{
  *t = len(a);
  return a / (*t);
}

ccl_device_inline float2 safe_normalize(const float2 &a)
{
  float t = len(a);
  return (t != 0.0f) ? a / t : a;
}

ccl_device_inline float2 min(const float2 &a, const float2 &b)
{
  return make_float2(fminf(a.x, b.x), fminf(a.y, b.y));
}

ccl_device_inline float2 max(const float2 &a, const float2 &b)
{
  return make_float2(fmaxf(a.x, b.x), fmaxf(a.y, b.y));
}

ccl_device_inline float2 clamp(const float2 &a, const float2 &mn, const float2 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float2 fabs(const float2 &a)
{
  return make_float2(fabsf(a.x), fabsf(a.y));
}

ccl_device_inline float2 as_float2(const float4 &a)
{
  return make_float2(a.x, a.y);
}

ccl_device_inline float2 interp(const float2 &a, const float2 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float2 mix(const float2 &a, const float2 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float2 floor(const float2 &a)
{
  return make_float2(floorf(a.x), floorf(a.y));
}

#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float2 safe_divide_float2_float(const float2 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float2(0.0f, 0.0f);
}

CCL_NAMESPACE_END

#endif

#line 424 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT3_H__
#define __COM_KERNEL_MATH_FLOAT3_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float3 operator-(const float3 &a);
ccl_device_inline float3 operator*(const float3 &a, const float3 &b);
ccl_device_inline float3 operator*(const float3 &a, const float f);
ccl_device_inline float3 operator*(const float f, const float3 &a);
ccl_device_inline float3 operator/(const float f, const float3 &a);
ccl_device_inline float3 operator/(const float3 &a, const float f);
ccl_device_inline float3 operator/(const float3 &a, const float3 &b);
ccl_device_inline float3 operator+(const float3 &a, const float f);
ccl_device_inline float3 operator+(const float3 &a, const float3 &b);
ccl_device_inline float3 operator-(const float3 &a, const float f);
ccl_device_inline float3 operator-(const float3 &a, const float3 &b);
ccl_device_inline float3 operator+=(float3 &a, const float3 &b);
ccl_device_inline float3 operator-=(float3 &a, const float3 &b);
ccl_device_inline float3 operator*=(float3 &a, const float3 &b);
ccl_device_inline float3 operator*=(float3 &a, float f);
ccl_device_inline float3 operator/=(float3 &a, const float3 &b);
ccl_device_inline float3 operator/=(float3 &a, float f);

ccl_device_inline bool operator==(const float3 &a, const float3 &b);
ccl_device_inline bool operator!=(const float3 &a, const float3 &b);

ccl_device_inline float distance(const float3 &a, const float3 &b);
ccl_device_inline float dot(const float3 &a, const float3 &b);
ccl_device_inline float dot_xy(const float3 &a, const float3 &b);
ccl_device_inline float3 cross(const float3 &a, const float3 &b);
ccl_device_inline float3 normalize(const float3 &a);
ccl_device_inline float3 min(const float3 &a, const float3 &b);
ccl_device_inline float3 max(const float3 &a, const float3 &b);
ccl_device_inline float3 clamp(const float3 &a, const float3 &mn, const float3 &mx);
ccl_device_inline float3 fabs(const float3 &a);
ccl_device_inline float3 mix(const float3 &a, const float3 &b, float t);
ccl_device_inline float3 rcp(const float3 &a);
ccl_device_inline float3 sqrt(const float3 &a);
ccl_device_inline float3 floor(const float3 &a);
ccl_device_inline float3 ceil(const float3 &a);
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float min3(float3 a);
ccl_device_inline float max3(float3 a);
ccl_device_inline float len(const float3 a);
ccl_device_inline float len_squared(const float3 a);

ccl_device_inline float3 reflect(const float3 incident, const float3 normal);
ccl_device_inline float3 project(const float3 v, const float3 v_proj);

ccl_device_inline float3 saturate3(float3 a);
ccl_device_inline float3 safe_normalize(const float3 a);
ccl_device_inline float3 normalize_len(const float3 a, float *t);
ccl_device_inline float3 safe_normalize_len(const float3 a, float *t);
ccl_device_inline float3 safe_divide_float3_float3(const float3 a, const float3 b);
ccl_device_inline float3 safe_divide_float3_float(const float3 a, const float b);
ccl_device_inline float3 interp(float3 a, float3 b, float t);
ccl_device_inline float3 sqr3(float3 a);
ccl_device_inline float reduce_add(const float3 a);
ccl_device_inline float average(const float3 a);
ccl_device_inline bool isequal_float3(const float3 a, const float3 b);

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float3 operator-(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_xor_ps(a.m128, _mm_castsi128_ps(_mm_set1_epi32(0x80000000))));
#  else
  return make_float3(-a.x, -a.y, -a.z);
#  endif
}

ccl_device_inline float3 operator*(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_mul_ps(a.m128, b.m128));
#  else
  return make_float3(a.x * b.x, a.y * b.y, a.z * b.z);
#  endif
}

ccl_device_inline float3 operator*(const float3 &a, const float f)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_mul_ps(a.m128, _mm_set1_ps(f)));
#  else
  return make_float3(a.x * f, a.y * f, a.z * f);
#  endif
}

ccl_device_inline float3 operator*(const float f, const float3 &a)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_mul_ps(_mm_set1_ps(f), a.m128));
#  else
  return make_float3(a.x * f, a.y * f, a.z * f);
#  endif
}

ccl_device_inline float3 operator/(const float f, const float3 &a)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_div_ps(_mm_set1_ps(f), a.m128));
#  else
  return make_float3(f / a.x, f / a.y, f / a.z);
#  endif
}

ccl_device_inline float3 operator/(const float3 &a, const float f)
{
  float invf = 1.0f / f;
  return a * invf;
}

ccl_device_inline float3 operator/(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE__)
  return float3(_mm_div_ps(a.m128, b.m128));
#  else
  return make_float3(a.x / b.x, a.y / b.y, a.z / b.z);
#  endif
}

ccl_device_inline float3 operator+(const float3 &a, const float f)
{
  return a + make_float3(f, f, f);
}

ccl_device_inline float3 operator+(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_add_ps(a.m128, b.m128));
#  else
  return make_float3(a.x + b.x, a.y + b.y, a.z + b.z);
#  endif
}

ccl_device_inline float3 operator-(const float3 &a, const float f)
{
  return a - make_float3(f, f, f);
}

ccl_device_inline float3 operator-(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_sub_ps(a.m128, b.m128));
#  else
  return make_float3(a.x - b.x, a.y - b.y, a.z - b.z);
#  endif
}

ccl_device_inline float3 operator+=(float3 &a, const float3 &b)
{
  return a = a + b;
}

ccl_device_inline float3 operator-=(float3 &a, const float3 &b)
{
  return a = a - b;
}

ccl_device_inline float3 operator*=(float3 &a, const float3 &b)
{
  return a = a * b;
}

ccl_device_inline float3 operator*=(float3 &a, float f)
{
  return a = a * f;
}

ccl_device_inline float3 operator/=(float3 &a, const float3 &b)
{
  return a = a / b;
}

ccl_device_inline float3 operator/=(float3 &a, float f)
{
  float invf = 1.0f / f;
  return a = a * invf;
}

ccl_device_inline bool operator==(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return (_mm_movemask_ps(_mm_cmpeq_ps(a.m128, b.m128)) & 7) == 7;
#  else
  return (a.x == b.x && a.y == b.y && a.z == b.z);
#  endif
}

ccl_device_inline bool operator!=(const float3 &a, const float3 &b)
{
  return !(a == b);
}

ccl_device_inline float distance(const float3 &a, const float3 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_dp_ps(a, b, 0x7F));
#  else
  return a.x * b.x + a.y * b.y + a.z * b.z;
#  endif
}

ccl_device_inline float dot_xy(const float3 &a, const float3 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_hadd_ps(_mm_mul_ps(a, b), b));
#  else
  return a.x * b.x + a.y * b.y;
#  endif
}

ccl_device_inline float3 cross(const float3 &a, const float3 &b)
{
  float3 r = make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
  return r;
}

ccl_device_inline float3 normalize(const float3 &a)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  __m128 norm = _mm_sqrt_ps(_mm_dp_ps(a.m128, a.m128, 0x7F));
  return float3(_mm_div_ps(a.m128, norm));
#  else
  return a / len(a);
#  endif
}

ccl_device_inline float3 min(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_min_ps(a.m128, b.m128));
#  else
  return make_float3(fminf(a.x, b.x), fminf(a.y, b.y), fminf(a.z, b.z));
#  endif
}

ccl_device_inline float3 max(const float3 &a, const float3 &b)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_max_ps(a.m128, b.m128));
#  else
  return make_float3(fmaxf(a.x, b.x), fmaxf(a.y, b.y), fmaxf(a.z, b.z));
#  endif
}

ccl_device_inline float3 clamp(const float3 &a, const float3 &mn, const float3 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float3 fabs(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  __m128 mask = _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff));
  return float3(_mm_and_ps(a.m128, mask));
#  else
  return make_float3(fabsf(a.x), fabsf(a.y), fabsf(a.z));
#  endif
}

ccl_device_inline float3 sqrt(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_sqrt_ps(a));
#  else
  return make_float3(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z));
#  endif
}

ccl_device_inline float3 floor(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_floor_ps(a));
#  else
  return make_float3(floorf(a.x), floorf(a.y), floorf(a.z));
#  endif
}

ccl_device_inline float3 ceil(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  return float3(_mm_ceil_ps(a));
#  else
  return make_float3(ceilf(a.x), ceilf(a.y), ceilf(a.z));
#  endif
}

ccl_device_inline float3 mix(const float3 &a, const float3 &b, float t)
{
  return a + t * (b - a);
}

ccl_device_inline float3 rcp(const float3 &a)
{
#  ifdef __KERNEL_SSE__
  /* Don't use _mm_rcp_ps due to poor precision. */
  return float3(_mm_div_ps(_mm_set_ps1(1.0f), a.m128));
#  else
  return make_float3(1.0f / a.x, 1.0f / a.y, 1.0f / a.z);
#  endif
}
#endif /* !__KERNEL_OPENCL__ */

ccl_device_inline float min3(const float3 a)
{
  return min(min(a.x, a.y), a.z);
}

ccl_device_inline float max3(const float3 a)
{
  return max(max(a.x, a.y), a.z);
}

ccl_device_inline float len(const float3 a)
{
#if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_sqrt_ss(_mm_dp_ps(a.m128, a.m128, 0x7F)));
#else
  return sqrtf(dot(a, a));
#endif
}

ccl_device_inline float len_squared(const float3 a)
{
  return dot(a, a);
}

ccl_device_inline float3 reflect(const float3 incident, const float3 normal)
{
  float3 unit_normal = normalize(normal);
  return incident - 2.0f * unit_normal * dot(incident, unit_normal);
}

ccl_device_inline float3 project(const float3 v, const float3 v_proj)
{
  float len_squared = dot(v_proj, v_proj);
  return (len_squared != 0.0f) ? (dot(v, v_proj) / len_squared) * v_proj :
                                 make_float3(0.0f, 0.0f, 0.0f);
}

ccl_device_inline float3 saturate3(const float3 a)
{
  return make_float3(saturate(a.x), saturate(a.y), saturate(a.z));
}

ccl_device_inline float3 normalize_len(const float3 a, float *t)
{
  *t = len(a);
  float x = 1.0f / *t;
  return a * x;
}

ccl_device_inline float3 safe_normalize(const float3 a)
{
  float t = len(a);
  return (t != 0.0f) ? a * (1.0f / t) : a;
}

ccl_device_inline float3 safe_normalize_len(const float3 a, float *t)
{
  *t = len(a);
  return (*t != 0.0f) ? a / (*t) : a;
}

ccl_device_inline float3 safe_divide_float3_float3(const float3 a, const float3 b)
{
  return make_float3((b.x != 0.0f) ? a.x / b.x : 0.0f,
                     (b.y != 0.0f) ? a.y / b.y : 0.0f,
                     (b.z != 0.0f) ? a.z / b.z : 0.0f);
}

ccl_device_inline float3 safe_divide_float3_float(const float3 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float3(0.0f, 0.0f, 0.0f);
}

ccl_device_inline float3 interp(const float3 a, const float3 b, const float t)
{
  return a + t * (b - a);
}

ccl_device_inline float3 sqr3(const float3 a)
{
  return a * a;
}

ccl_device_inline float reduce_add(const float3 a)
{
  return (a.x + a.y + a.z);
}

ccl_device_inline float average(const float3 a)
{
  return reduce_add(a) * (1.0f / 3.0f);
}

ccl_device_inline bool isequal_float3(const float3 a, const float3 b)
{
#ifdef __KERNEL_OPENCL__
  return all(a == b);
#else
  return a == b;
#endif
}

ccl_device_inline float3 pow3(const float3 v, const float e)
{
  return make_float3(powf(v.x, e), powf(v.y, e), powf(v.z, e));
}

ccl_device_inline float3 exp3(const float3 v)
{
  return make_float3(expf(v.x), expf(v.y), expf(v.z));
}

ccl_device_inline float3 log3(const float3 v)
{
  return make_float3(logf(v.x), logf(v.y), logf(v.z));
}

ccl_device_inline int3 quick_floor_to_int3(const float3 a)
{
#ifdef __KERNEL_SSE__
  int3 b = int3(_mm_cvttps_epi32(a.m128));
  int3 isneg = int3(_mm_castps_si128(_mm_cmplt_ps(a.m128, _mm_set_ps1(0.0f))));
  /* Unsaturated add 0xffffffff is the same as subtract -1. */
  return b + isneg;
#else
  return make_int3(quick_floor_to_int(a.x), quick_floor_to_int(a.y), quick_floor_to_int(a.z));
#endif
}

ccl_device_inline bool isfinite3_safe(const float3 v)
{
  return isfinite_safe(v.x) && isfinite_safe(v.y) && isfinite_safe(v.z);
}

ccl_device_inline float3 ensure_finite3(float3 v)
{
  if (!isfinite_safe(v.x))
    v.x = 0.0f;
  if (!isfinite_safe(v.y))
    v.y = 0.0f;
  if (!isfinite_safe(v.z))
    v.z = 0.0f;
  return v;
}

CCL_NAMESPACE_END

#endif

#line 425 ".kernel_util/COM_kernel_math.h"
#line 1 ".kernel_util/COM_kernel_math_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_MATH_FLOAT4_H__
#define __COM_KERNEL_MATH_FLOAT4_H__

#ifndef __COM_KERNEL_MATH_H__
#  error "Do not include this file directly, include COM_kernel_math.h instead."
#endif

CCL_NAMESPACE_BEGIN

/*******************************************************************************
 * Declaration.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float4 operator-(const float4 &a);
ccl_device_inline float4 operator*(const float4 &a, const float4 &b);
ccl_device_inline float4 operator*(const float4 &a, const float f);
ccl_device_inline float4 operator*(const float f, const float4 &a);
ccl_device_inline float4 operator/(const float4 &a, float f);
ccl_device_inline float4 operator/(const float f, const float4 &a);
ccl_device_inline float4 operator/(const float4 &a, const float4 &b);
ccl_device_inline float4 operator+(const float4 &a, const float f);
ccl_device_inline float4 operator+(const float f, const float4 &a);
ccl_device_inline float4 operator+(const float4 &a, const float4 &b);
ccl_device_inline float4 operator-(const float4 &a, const float f);
ccl_device_inline float4 operator-(const float f, const float4 &a);
ccl_device_inline float4 operator-(const float4 &a, const float4 &b);
ccl_device_inline float4 operator+=(float4 &a, const float4 &b);
ccl_device_inline float4 operator*=(float4 &a, const float4 &b);
ccl_device_inline float4 operator*=(float4 &a, const float f);
ccl_device_inline float4 operator/=(float4 &a, const float f);

ccl_device_inline int4 operator<(const float4 &a, const float4 &b);
ccl_device_inline int4 operator>(const float4 &a, const float4 &b);
ccl_device_inline int4 operator>=(const float4 &a, const float4 &b);
ccl_device_inline int4 operator<=(const float4 &a, const float4 &b);
ccl_device_inline int4 operator==(const float4 &a, const float4 &b);
ccl_device_inline int4 operator!=(const float4 &a, const float4 &b);

ccl_device_inline float distance(const float4 &a, const float4 &b);
ccl_device_inline float dot(const float4 &a, const float4 &b);
ccl_device_inline float len_squared(const float4 &a);
ccl_device_inline float4 rcp(const float4 &a);
ccl_device_inline float4 sqrt(const float4 &a);
ccl_device_inline float4 sqr(const float4 &a);
ccl_device_inline float4 cross(const float4 &a, const float4 &b);
ccl_device_inline float average(const float4 &a);
ccl_device_inline float len(const float4 &a);
ccl_device_inline float4 normalize(const float4 &a);
ccl_device_inline float4 safe_normalize(const float4 &a);
ccl_device_inline float4 min(const float4 &a, const float4 &b);
ccl_device_inline float4 min(const float4 &a, const float b);
ccl_device_inline float4 max(const float4 &a, const float4 &b);
ccl_device_inline float4 max(const float4 &a, const float b);
ccl_device_inline float4 clamp(const float4 &a, const float4 &mn, const float4 &mx);
ccl_device_inline float4 clamp(const float4 &a, const float mn, const float mx);
ccl_device_inline float4 fabs(const float4 &a);
ccl_device_inline float4 floor(const float4 &a);
ccl_device_inline float4 mix(const float4 &a, const float4 &b, const float t);
#endif /* !__KERNEL_OPENCL__*/

ccl_device_inline float4 safe_divide_float4_float(const float4 a, const float b);
ccl_device_inline float4 clamp_to_normal_f4(const float4 a);

#ifdef __KERNEL_SSE__
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &b);
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &a, const float4 &b);

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &b);

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &a, const float4 &b);
template<> __forceinline const float4 shuffle<2, 3, 2, 3>(const float4 &a, const float4 &b);

#  ifdef __KERNEL_SSE3__
template<> __forceinline const float4 shuffle<0, 0, 2, 2>(const float4 &b);
template<> __forceinline const float4 shuffle<1, 1, 3, 3>(const float4 &b);
#  endif
#endif /* __KERNEL_SSE__ */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline float4 select(const float4 &b_false, const float4 &a_true, const int4 &mask);
ccl_device_inline float4 reduce_min(const float4 &a);
ccl_device_inline float4 reduce_max(const float4 &a);
ccl_device_inline float4 reduce_add(const float4 &a);
#endif /* !__KERNEL_COMPUTE__ */

/*******************************************************************************
 * Definition.
 */

#ifndef __KERNEL_OPENCL__
ccl_device_inline float4 operator-(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  __m128 mask = _mm_castsi128_ps(_mm_set1_epi32(0x80000000));
  return float4(_mm_xor_ps(a.m128, mask));
#  else
  return make_float4(-a.x, -a.y, -a.z, -a.w);
#  endif
}

ccl_device_inline float4 operator*(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_mul_ps(a.m128, b.m128));
#  else
  return make_float4(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
#  endif
}

ccl_device_inline float4 operator*(const float4 &a, const float f)
{
#  if defined(__KERNEL_SSE__)
  return a * make_float4_1(f);
#  else
  return make_float4(a.x * f, a.y * f, a.z * f, a.w * f);
#  endif
}

ccl_device_inline float4 operator*(const float f, const float4 &a)
{
  return a * f;
}

ccl_device_inline float4 operator/(const float4 &a, const float f)
{
  return a * (1.0f / f);
}

ccl_device_inline float4 operator/(const float f, const float4 &a)
{
  return make_float4_1(f) / a;
}
ccl_device_inline float4 operator/(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_div_ps(a.m128, b.m128));
#  else
  return make_float4(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
#  endif
}

ccl_device_inline float4 operator+(const float4 &a, const float f)
{
  return a + make_float4(f, f, f, f);
}

ccl_device_inline float4 operator+(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_add_ps(a.m128, b.m128));
#  else
  return make_float4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
#  endif
}

ccl_device_inline float4 operator+(const float f, const float4 &a)
{
  return make_float4(f, f, f, f) + a;
}

ccl_device_inline float4 operator-(const float4 &a, const float f)
{
  return a - make_float4(f, f, f, f);
}

ccl_device_inline float4 operator-(const float f, const float4 &a)
{
  return make_float4(f, f, f, f) - a;
}

ccl_device_inline float4 operator-(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_sub_ps(a.m128, b.m128));
#  else
  return make_float4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
#  endif
}

ccl_device_inline float4 operator+=(float4 &a, const float4 &b)
{
  return a = a + b;
}

ccl_device_inline float4 operator-=(float4 &a, const float4 &b)
{
  return a = a - b;
}

ccl_device_inline float4 operator*=(float4 &a, const float4 &b)
{
  return a = a * b;
}

ccl_device_inline float4 operator*=(float4 &a, const float f)
{
  return a = a * f;
}

ccl_device_inline float4 operator/=(float4 &a, const float f)
{
  return a = a / f;
}

ccl_device_inline int4 operator<(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmplt_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x < b.x, a.y < b.y, a.z < b.z, a.w < b.w);
#  endif
}

ccl_device_inline int4 operator>(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpgt_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x > b.x, a.y > b.y, a.z > b.z, a.w > b.w);
#  endif
}

ccl_device_inline int4 operator>=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpge_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x >= b.x, a.y >= b.y, a.z >= b.z, a.w >= b.w);
#  endif
}

ccl_device_inline int4 operator<=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmple_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x <= b.x, a.y <= b.y, a.z <= b.z, a.w <= b.w);
#  endif
}

ccl_device_inline int4 operator==(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpeq_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w);
#  endif
}

ccl_device_inline int4 operator!=(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return int4(_mm_castps_si128(_mm_cmpneq_ps(a.m128, b.m128)));
#  else
  return make_int4(a.x != b.x, a.y != b.y, a.z != b.z, a.w != b.w);
#  endif
}

ccl_device_inline float distance(const float4 &a, const float4 &b)
{
  return len(a - b);
}

ccl_device_inline float dot(const float4 &a, const float4 &b)
{
#  if defined(__KERNEL_SSE41__) && defined(__KERNEL_SSE__)
  return _mm_cvtss_f32(_mm_dp_ps(a, b, 0xFF));
#  else
  return (a.x * b.x + a.y * b.y) + (a.z * b.z + a.w * b.w);
#  endif
}

ccl_device_inline float len_squared(const float4 &a)
{
  return dot(a, a);
}

ccl_device_inline float4 rcp(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  /* Don't use _mm_rcp_ps due to poor precision. */
  return float4(_mm_div_ps(_mm_set_ps1(1.0f), a.m128));
#  else
  return make_float4(1.0f / a.x, 1.0f / a.y, 1.0f / a.z, 1.0f / a.w);
#  endif
}

ccl_device_inline float4 sqrt(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_sqrt_ps(a.m128));
#  else
  return make_float4(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z), sqrtf(a.w));
#  endif
}

ccl_device_inline float4 sqr(const float4 &a)
{
  return a * a;
}

ccl_device_inline float4 cross(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return (shuffle<1, 2, 0, 0>(a) * shuffle<2, 0, 1, 0>(b)) -
         (shuffle<2, 0, 1, 0>(a) * shuffle<1, 2, 0, 0>(b));
#  else
  return make_float4(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x, 0.0f);
#  endif
}

ccl_device_inline float4 reduce_add(const float4 &a)
{
#  ifdef __KERNEL_SSE__
#    ifdef __KERNEL_SSE3__
  float4 h(_mm_hadd_ps(a.m128, a.m128));
  return float4(_mm_hadd_ps(h.m128, h.m128));
#    else
  float4 h(shuffle<1, 0, 3, 2>(a) + a);
  return shuffle<2, 3, 0, 1>(h) + h;
#    endif
#  else
  float sum = (a.x + a.y) + (a.z + a.w);
  return make_float4(sum, sum, sum, sum);
#  endif
}

ccl_device_inline float average(const float4 &a)
{
  return reduce_add(a).x * 0.25f;
}

ccl_device_inline float len(const float4 &a)
{
  return sqrtf(dot(a, a));
}

ccl_device_inline float4 normalize(const float4 &a)
{
  return a / len(a);
}

ccl_device_inline float4 safe_normalize(const float4 &a)
{
  float t = len(a);
  return (t != 0.0f) ? a / t : a;
}

ccl_device_inline float4 min(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_min_ps(a.m128, b.m128));
#  else
  return make_float4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));
#  endif
}

ccl_device_inline float4 min(const float4 &a, const float b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_min_ps(a.m128, _mm_set1_ps(b)));
#  else
  return make_float4(fminf(a.x, b), fminf(a.y, b), fminf(a.z, b), fminf(a.w, b));
#  endif
}

ccl_device_inline float4 max(const float4 &a, const float4 &b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_max_ps(a.m128, b.m128));
#  else
  return make_float4(fmaxf(a.x, b.x), fmaxf(a.y, b.y), fmaxf(a.z, b.z), fmaxf(a.w, b.w));
#  endif
}

ccl_device_inline float4 max(const float4 &a, const float b)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_max_ps(a.m128, _mm_set1_ps(b)));
#  else
  return make_float4(fminf(a.x, b), fminf(a.y, b), fminf(a.z, b), fminf(a.w, b));
#  endif
}

ccl_device_inline float4 clamp(const float4 &a, const float4 &mn, const float4 &mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float4 clamp(const float4 &a, const float mn, const float mx)
{
  return min(max(a, mn), mx);
}

ccl_device_inline float4 fabs(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_and_ps(a.m128, _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff))));
#  else
  return make_float4(fabsf(a.x), fabsf(a.y), fabsf(a.z), fabsf(a.w));
#  endif
}

ccl_device_inline float4 floor(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_floor_ps(a));
#  else
  return make_float4(floorf(a.x), floorf(a.y), floorf(a.z), floorf(a.w));
#  endif
}

ccl_device_inline float4 mix(const float4 &a, const float4 &b, const float t)
{
  return a + t * (b - a);
}

#endif /* !__KERNEL_COMPUTE__*/

#ifdef __KERNEL_SSE__
template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &b)
{
  return float4(_mm_castsi128_ps(
      _mm_shuffle_epi32(_mm_castps_si128(b), _MM_SHUFFLE(index_3, index_2, index_1, index_0))));
}

template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>
__forceinline const float4 shuffle(const float4 &a, const float4 &b)
{
  return float4(_mm_shuffle_ps(a.m128, b.m128, _MM_SHUFFLE(index_3, index_2, index_1, index_0)));
}

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &b)
{
  return float4(_mm_castpd_ps(_mm_movedup_pd(_mm_castps_pd(b))));
}

template<> __forceinline const float4 shuffle<0, 1, 0, 1>(const float4 &a, const float4 &b)
{
  return float4(_mm_movelh_ps(a.m128, b.m128));
}

template<> __forceinline const float4 shuffle<2, 3, 2, 3>(const float4 &a, const float4 &b)
{
  return float4(_mm_movehl_ps(b.m128, a.m128));
}

#  ifdef __KERNEL_SSE3__
template<> __forceinline const float4 shuffle<0, 0, 2, 2>(const float4 &b)
{
  return float4(_mm_moveldup_ps(b));
}

template<> __forceinline const float4 shuffle<1, 1, 3, 3>(const float4 &b)
{
  return float4(_mm_movehdup_ps(b));
}
#  endif /* __KERNEL_SSE3__ */
#endif   /* __KERNEL_SSE__ */

#ifndef __KERNEL_COMPUTE__
ccl_device_inline float4 select(const float4 &b_false, const float4 &a_true, const int4 &mask)
{
#  ifdef __KERNEL_SSE__
  return float4(_mm_blendv_ps(b_false.m128, a_true.m128, _mm_castsi128_ps(mask.m128)));
#  else
  return make_float4((mask.x) ? a_true.x : b_false.x,
                     (mask.y) ? a_true.y : b_false.y,
                     (mask.z) ? a_true.z : b_false.z,
                     (mask.w) ? a_true.w : b_false.w);
#  endif
}

ccl_device_inline float4 reduce_min(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  float4 h = min(shuffle<1, 0, 3, 2>(a), a);
  return min(shuffle<2, 3, 0, 1>(h), h);
#  else
  return make_float4(min(min(a.x, a.y), min(a.z, a.w)));
#  endif
}

ccl_device_inline float4 reduce_max(const float4 &a)
{
#  ifdef __KERNEL_SSE__
  float4 h = max(shuffle<1, 0, 3, 2>(a), a);
  return max(shuffle<2, 3, 0, 1>(h), h);
#  else
  return make_float4(max(max(a.x, a.y), max(a.z, a.w)));
#  endif
}

#endif /* !__KERNEL_COMPUTE__ */

ccl_device_inline float4 safe_divide_float4_float(const float4 a, const float b)
{
  return (b != 0.0f) ? a / b : make_float4(0.0f, 0.0f, 0.0f, 0.0f);
}

ccl_device_inline float4 clamp_to_normal_f4(const float4 a)
{
  return min(max(a, 0.0f), 1.0f);
}

CCL_NAMESPACE_END

#endif

#line 426 ".kernel_util/COM_kernel_math.h"

CCL_NAMESPACE_BEGIN

#ifndef __KERNEL_OPENCL__
/* Interpolation */

template<class A, class B> A lerp(const A &a, const A &b, const B &t)
{
  return (A)(a * ((B)1 - t) + b * t);
}

#endif /* __KERNEL_OPENCL__ */

/* Triangle */
#ifndef __KERNEL_OPENCL__
ccl_device_inline float triangle_area(const float3 &v1, const float3 &v2, const float3 &v3)
#else
ccl_device_inline float triangle_area(const float3 v1, const float3 v2, const float3 v3)
#endif
{
  return len(cross(v3 - v2, v1 - v2)) * 0.5f;
}

/* Orthonormal vectors */

ccl_device_inline void make_orthonormals(const float3 N, float3 *a, float3 *b)
{
#if 0
  if (fabsf(N.y) >= 0.999f) {
    *a = make_float3(1, 0, 0);
    *b = make_float3(0, 0, 1);
    return;
  }
  if (fabsf(N.z) >= 0.999f) {
    *a = make_float3(1, 0, 0);
    *b = make_float3(0, 1, 0);
    return;
  }
#endif

  if (N.x != N.y || N.x != N.z)
    *a = make_float3(N.z - N.y, N.x - N.z, N.y - N.x);  //(1,1,1)x N
  else
    *a = make_float3(N.z - N.y, N.x + N.z, -N.y - N.x);  //(-1,1,1)x N

  *a = normalize(*a);
  *b = cross(N, *a);
}

/* Color division */

ccl_device_inline float3 safe_invert_color(const float3 a)
{
  float x, y, z;

  x = (a.x != 0.0f) ? 1.0f / a.x : 0.0f;
  y = (a.y != 0.0f) ? 1.0f / a.y : 0.0f;
  z = (a.z != 0.0f) ? 1.0f / a.z : 0.0f;

  return make_float3(x, y, z);
}

ccl_device_inline float3 safe_divide_color(const float3 a, const float3 b)
{
  float x, y, z;

  x = (b.x != 0.0f) ? a.x / b.x : 0.0f;
  y = (b.y != 0.0f) ? a.y / b.y : 0.0f;
  z = (b.z != 0.0f) ? a.z / b.z : 0.0f;

  return make_float3(x, y, z);
}

ccl_device_inline float3 safe_divide_even_color(const float3 a, const float3 b)
{
  float x, y, z;

  x = (b.x != 0.0f) ? a.x / b.x : 0.0f;
  y = (b.y != 0.0f) ? a.y / b.y : 0.0f;
  z = (b.z != 0.0f) ? a.z / b.z : 0.0f;

  /* try to get gray even if b is zero */
  if (b.x == 0.0f) {
    if (b.y == 0.0f) {
      x = z;
      y = z;
    }
    else if (b.z == 0.0f) {
      x = y;
      z = y;
    }
    else
      x = 0.5f * (y + z);
  }
  else if (b.y == 0.0f) {
    if (b.z == 0.0f) {
      y = x;
      z = x;
    }
    else
      y = 0.5f * (x + z);
  }
  else if (b.z == 0.0f) {
    z = 0.5f * (x + y);
  }

  return make_float3(x, y, z);
}

/* Rotation of point around axis and angle */

ccl_device_inline float3 rotate_around_axis(const float3 p, const float3 axis, const float angle)
{
  float costheta = cosf(angle);
  float sintheta = sinf(angle);
  float3 r;

  r.x = ((costheta + (1 - costheta) * axis.x * axis.x) * p.x) +
        (((1 - costheta) * axis.x * axis.y - axis.z * sintheta) * p.y) +
        (((1 - costheta) * axis.x * axis.z + axis.y * sintheta) * p.z);

  r.y = (((1 - costheta) * axis.x * axis.y + axis.z * sintheta) * p.x) +
        ((costheta + (1 - costheta) * axis.y * axis.y) * p.y) +
        (((1 - costheta) * axis.y * axis.z - axis.x * sintheta) * p.z);

  r.z = (((1 - costheta) * axis.x * axis.z - axis.y * sintheta) * p.x) +
        (((1 - costheta) * axis.y * axis.z + axis.x * sintheta) * p.y) +
        ((costheta + (1 - costheta) * axis.z * axis.z) * p.z);

  return r;
}

/* NaN-safe math ops */

ccl_device_inline float safe_sqrtf(const float f)
{
  return sqrtf(max(f, 0.0f));
}

ccl_device_inline float inversesqrtf(const float f)
{
  return (f > 0.0f) ? 1.0f / sqrtf(f) : 0.0f;
}

ccl_device float safe_asinf(const float a)
{
  return asinf(clamp(a, -1.0f, 1.0f));
}

ccl_device float safe_acosf(const float a)
{
  return acosf(clamp(a, -1.0f, 1.0f));
}

ccl_device float compatible_powf(const float x, const float y)
{
#ifdef __KERNEL_COMPUTE__
  if (y == 0.0f) /* x^0 -> 1, including 0^0 */
    return 1.0f;

  /* GPU pow doesn't accept negative x, do manual checks here */
  if (x < 0.0f) {
    if (fmodf(-y, 2.0f) == 0.0f)
      return powf(-x, y);
    else
      return -powf(-x, y);
  }
  else if (x == 0.0f)
    return 0.0f;
#endif
  return powf(x, y);
}

ccl_device float safe_powf(const float a, const float b)
{
  if (UNLIKELY(a < 0.0f && b != float_to_int(b)))
    return 0.0f;

  return compatible_powf(a, b);
}

ccl_device float safe_divide(const float a, const float b)
{
  return (b != 0.0f) ? a / b : 0.0f;
}

ccl_device float safe_logf(const float a, const float b)
{
  if (UNLIKELY(a <= 0.0f || b <= 0.0f))
    return 0.0f;

  return safe_divide(logf(a), logf(b));
}

ccl_device float safe_modulo(const float a, const float b)
{
  return (b != 0.0f) ? fmodf(a, b) : 0.0f;
}

ccl_device_inline float sqr(const float a)
{
  return a * a;
}

ccl_device_inline float pow20(const float a)
{
  return sqr(sqr(sqr(sqr(a)) * a));
}

ccl_device_inline float pow22(float a)
{
  return sqr(a * sqr(sqr(sqr(a)) * a));
}

ccl_device_inline float beta(float x, float y)
{
#ifndef __KERNEL_OPENCL__
  return expf(lgammaf(x) + lgammaf(y) - lgammaf(x + y));
#else
  return expf(lgamma(x) + lgamma(y) - lgamma(x + y));
#endif
}

ccl_device_inline float xor_signmask(const float x, const int y)
{
  return __int_as_float(__float_as_int(x) ^ y);
}

ccl_device float bits_to_01(const uint bits)
{
  return bits * (1.0f / (float)0xFFFFFFFF);
}

ccl_device_inline uint count_leading_zeros(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return __clz(x);
#elif defined(__KERNEL_OPENCL__)
  return clz(x);
#else
  assert(x != 0);
#  ifdef _MSC_VER
  unsigned long leading_zero = 0;
  _BitScanReverse(&leading_zero, x);
  return (31 - leading_zero);
#  else
  return __builtin_clz(x);
#  endif
#endif
}

ccl_device_inline uint count_trailing_zeros(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return (__ffs(x) - 1);
#elif defined(__KERNEL_OPENCL__)
  return (31 - count_leading_zeros(x & -x));
#else
  assert(x != 0);
#  ifdef _MSC_VER
  unsigned long ctz = 0;
  _BitScanForward(&ctz, x);
  return ctz;
#  else
  return __builtin_ctz(x);
#  endif
#endif
}

ccl_device_inline uint find_first_set(const uint x)
{
#if defined(__KERNEL_CUDA__) || defined(__KERNEL_OPTIX__)
  return __ffs(x);
#elif defined(__KERNEL_OPENCL__)
  return (x != 0) ? (32 - count_leading_zeros(x & (-x))) : 0;
#else
#  ifdef _MSC_VER
  return (x != 0) ? (32 - count_leading_zeros(x & (-x))) : 0;
#  else
  return __builtin_ffs(x);
#  endif
#endif
}

/* projections */
ccl_device_inline float2 map_to_tube(const float3 co)
{
  float len, u, v;
  len = sqrtf(co.x * co.x + co.y * co.y);
  if (len > 0.0f) {
    u = (1.0f - (atan2f(co.x / len, co.y / len) / M_PI_F)) * 0.5f;
    v = (co.z + 1.0f) * 0.5f;
  }
  else {
    u = v = 0.0f;
  }
  return make_float2(u, v);
}

ccl_device_inline float2 map_to_sphere(const float3 co)
{
  float l = len(co);
  float u, v;
  if (l > 0.0f) {
    if (UNLIKELY(co.x == 0.0f && co.y == 0.0f)) {
      u = 0.0f; /* othwise domain error */
    }
    else {
      u = (1.0f - atan2f(co.x, co.y) / M_PI_F) / 2.0f;
    }
    v = 1.0f - safe_acosf(co.z / l) / M_PI_F;
  }
  else {
    u = v = 0.0f;
  }
  return make_float2(u, v);
}

/* Compares two floats.
 * Returns true if their absolute difference is smaller than abs_diff (for numbers near zero)
 * or their relative difference is less than ulp_diff ULPs.
 * Based on
 * https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
 */

ccl_device_inline float compare_floats(const float a,
                                       const float b,
                                       const float abs_diff,
                                       const int ulp_diff)
{
  if (fabsf(a - b) < abs_diff) {
    return true;
  }

  if ((a < 0.0f) != (b < 0.0f)) {
    return false;
  }

  return (abs(__float_as_int(a) - __float_as_int(b)) < ulp_diff);
}

ccl_device_inline float clamp_to_normal(const float a)
{
  return min(max(a, 0.0f), 1.0f);
}

ccl_device_inline float4 interp_f4f4(const float4 a, const float4 b, const float t)
{
  const float s = 1.0f - t;

  return s * a + t * b;
}

CCL_NAMESPACE_END

#endif

#line 155 ".COM_kernel_opencl.h"
#line 1 ".kernel_util/COM_kernel_types.h"
#ifndef __COM_KERNEL_TYPES_H__
#define __COM_KERNEL_TYPES_H__

#ifndef __KERNEL_OPENCL__
#  include <stdlib.h>
#endif

#line 1 ".kernel_util/COM_kernel_defines.h"

/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* clang-format off */

/* #define __forceinline triggers a bug in some clang-format versions, disable
 * format for entire file to keep results consistent. */

#ifndef __COM_KERNEL_DEFINES_H__
#define __COM_KERNEL_DEFINES_H__

/* On x86_64, versions of glibc < 2.16 have an issue where expf is
 * much slower than the double version.  This was fixed in glibc 2.16.
 */
#if defined(__x86_64__) && defined(__x86_64__) && defined(__GNU_LIBRARY__) && \
    defined(__GLIBC__) && defined(__GLIBC_MINOR__) && (__GLIBC__ <= 2 && __GLIBC_MINOR__ < 16)
#  define expf(x) ((float)exp((double)(x)))
#endif

/* Bitness */

#if defined(__ppc64__) || defined(__PPC64__) || defined(__x86_64__) || defined(__ia64__) || \
    defined(_M_X64)
#  define __KERNEL_64_BIT__
#endif

/* Use to suppress '-Wimplicit-fallthrough' (in place of 'break'). */
#ifndef ATTR_FALLTHROUGH
#  if defined(__GNUC__) && (__GNUC__ >= 7) /* gcc7.0+ only */
#    define ATTR_FALLTHROUGH __attribute__((fallthrough))
#  else
#    define ATTR_FALLTHROUGH ((void)0)
#  endif
#endif

/* macros */

/* hints for branch prediction, only use in code that runs a _lot_ */
#if defined(__GNUC__) && defined(__KERNEL_CPU__)
#  define LIKELY(x) __builtin_expect(!!(x), 1)
#  define UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#  define LIKELY(x) (x)
#  define UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) || defined(__clang__)
#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_##x
#endif

#if defined(__GNUC__) || defined(__clang__)
#  if defined(__cplusplus)
/* Some magic to be sure we don't have reference in the type. */
template<typename T> static inline T decltype_helper(T x)
{
  return x;
}
#    define TYPEOF(x) decltype(decltype_helper(x))
#  else
#    define TYPEOF(x) typeof(x)
#  endif
#endif

/* Causes warning:
 * incompatible types when assigning to type 'Foo' from type 'Bar'
 * ... the compiler optimizes away the temp var */
#undef CHECK_TYPE
#undef CHECK_TYPE_PAIR
#undef CHECK_TYPE_INLINE

#if defined(__GNUC__) && !defined(__KERNEL_COMPUTE__)
#  define CHECK_TYPE(var, type) \
    { \
      TYPEOF(var) * __tmp; \
      __tmp = (type *)NULL; \
      (void)__tmp; \
    } \
    (void)0

#  define CHECK_TYPE_PAIR(var_a, var_b) \
    { \
      TYPEOF(var_a) * __tmp; \
      __tmp = (typeof(var_b) *)NULL; \
      (void)__tmp; \
    } \
    (void)0
#else
#  define CHECK_TYPE(var, type)
#  define CHECK_TYPE_PAIR(var_a, var_b)
#endif

/* can be used in simple macros */
#if !defined(__KERNEL_COMPUTE__)
#define CHECK_TYPE_INLINE(val, type) ((void)(((type)0) != (val)))
#else
#  define CHECK_TYPE_INLINE(val, type)
#endif

#undef SWAP
#define SWAP(type, a, b) \
  { \
    type sw_ap; \
    CHECK_TYPE(a, type); \
    CHECK_TYPE(b, type); \
    sw_ap = (a); \
    (a) = (b); \
    (b) = sw_ap; \
  } \
  (void)0

#endif /* __COM_KERNEL_DEFINES_H__ */

#line 8 ".kernel_util/COM_kernel_types.h"

/* Standard Integer Types */

#if !defined(__KERNEL_COMPUTE__) && !defined(_WIN32)
#  include <stdint.h>
#endif

#ifndef __KERNEL_COMPUTE__
#  include <cassert>

#line 1 ".kernel_util/COM_kernel_optimization.h"
/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_OPTIMIZATION_H__
#define __COM_KERNEL_OPTIMIZATION_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

/* x86
 *
 * Compile a regular, SSE2 and SSE3 kernel. */

#  if defined(i386) || defined(_M_IX86)

/* We require minimum SSE2 support on x86, so auto enable. */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(i386) || defined(_M_IX86) */

/* x86-64
 *
 * Compile a regular (includes SSE2), SSE3, SSE 4.1, AVX and AVX2 kernel. */

#  if defined(__x86_64__) || defined(_M_X64)

/* SSE2 is always available on x86-64 CPUs, so auto enable */
#    define __KERNEL_SSE__
#    define __KERNEL_SSE2__

#  endif /* defined(__x86_64__) || defined(_M_X64) */

#endif /* __KERNEL_COMPUTE__ */

#endif

#line 19 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util/COM_kernel_simd.h"
/*
 * Copyright 2011-2013 Intel Corporation
 * Modifications Copyright 2014, Blender Foundation.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_SIMD_H__
#define __COM_KERNEL_SIMD_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

#ifndef __KERNEL_COMPUTE__

#  include <limits>

/* SSE Intrinsics includes
 *
 * We assume __KERNEL_SSEX__ flags to have been defined at this point */

/* SSE intrinsics headers */
#  ifndef FREE_WINDOWS64

#    ifdef _MSC_VER
#      include <intrin.h>
#    elif (defined(__x86_64__) || defined(__i386__))
#      include <x86intrin.h>
#    endif

#  else

/* MinGW64 has conflicting declarations for these SSE headers in <windows.h>.
 * Since we can't avoid including <windows.h>, better only include that */
#    include "util/util_windows.h"

#  endif

#  if defined(__x86_64__) || defined(_M_X64)
#    define SIMD_SET_FLUSH_TO_ZERO \
      _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); \
      _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
#  else
#    define SIMD_SET_FLUSH_TO_ZERO
#  endif

CCL_NAMESPACE_BEGIN

#  ifdef __KERNEL_SSE2__

extern const __m128 _mm_lookupmask_ps[16];

/* Special Types */

static struct TrueTy {
  __forceinline operator bool() const
  {
    return true;
  }
} True ccl_maybe_unused;

static struct FalseTy {
  __forceinline operator bool() const
  {
    return false;
  }
} False ccl_maybe_unused;

static struct ZeroTy {
  __forceinline operator float() const
  {
    return 0;
  }
  __forceinline operator int() const
  {
    return 0;
  }
} zero ccl_maybe_unused;

static struct OneTy {
  __forceinline operator float() const
  {
    return 1;
  }
  __forceinline operator int() const
  {
    return 1;
  }
} one ccl_maybe_unused;

static struct NegInfTy {
  __forceinline operator float() const
  {
    return -std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::min();
  }
} neg_inf ccl_maybe_unused;

static struct PosInfTy {
  __forceinline operator float() const
  {
    return std::numeric_limits<float>::infinity();
  }
  __forceinline operator int() const
  {
    return std::numeric_limits<int>::max();
  }
} inf ccl_maybe_unused, pos_inf ccl_maybe_unused;

static struct StepTy {
} step ccl_maybe_unused;

/* Intrinsics Functions */

#    if defined(__BMI__) && defined(__GNUC__)
#      ifndef _tzcnt_u32
#        define _tzcnt_u32 __tzcnt_u32
#      endif
#      ifndef _tzcnt_u64
#        define _tzcnt_u64 __tzcnt_u64
#      endif
#    endif

#    if defined(__LZCNT__)
#      define _lzcnt_u32 __lzcnt32
#      define _lzcnt_u64 __lzcnt64
#    endif

#    if defined(_WIN32) && !defined(__MINGW32__) && !defined(__clang__)

__forceinline int __popcnt(int in)
{
  return _mm_popcnt_u32(in);
}

#      if !defined(_MSC_VER)
__forceinline unsigned int __popcnt(unsigned int in)
{
  return _mm_popcnt_u32(in);
}
#      endif

#      if defined(__KERNEL_64_BIT__)
__forceinline long long __popcnt(long long in)
{
  return _mm_popcnt_u64(in);
}
__forceinline size_t __popcnt(size_t in)
{
  return _mm_popcnt_u64(in);
}
#      endif

__forceinline int __bsf(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline unsigned int __bsf(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  unsigned long r = 0;
  _BitScanForward(&r, v);
  return r;
#      endif
}

__forceinline int __bsr(int v)
{
  unsigned long r = 0;
  _BitScanReverse(&r, v);
  return r;
}

__forceinline int __btc(int v, int i)
{
  long r = v;
  _bittestandcomplement(&r, i);
  return r;
}

__forceinline int __bts(int v, int i)
{
  long r = v;
  _bittestandset(&r, i);
  return r;
}

__forceinline int __btr(int v, int i)
{
  long r = v;
  _bittestandreset(&r, i);
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = __bsf(v);
  v &= v - 1;
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = __bsf(v);
  v &= v - 1;
  return i;
}

#      if defined(__KERNEL_64_BIT__)

__forceinline size_t __bsf(size_t v)
{
#        if defined(__KERNEL_AVX2__)
  return _tzcnt_u64(v);
#        else
  unsigned long r = 0;
  _BitScanForward64(&r, v);
  return r;
#        endif
}

__forceinline size_t __bsr(size_t v)
{
  unsigned long r = 0;
  _BitScanReverse64(&r, v);
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = v;
  _bittestandcomplement64((__int64 *)&r, i);
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandset64(&r, i);
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  __int64 r = v;
  _bittestandreset64(&r, i);
  return r;
}

__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}

__forceinline size_t __bscf(size_t &v)
{
  size_t i = __bsf(v);
  v &= v - 1;
  return i;
}

#      endif /* __KERNEL_64_BIT__ */

#    else /* _WIN32 */

__forceinline unsigned int __popcnt(unsigned int in)
{
  int r = 0;
  asm("popcnt %1,%0" : "=r"(r) : "r"(in));
  return r;
}

__forceinline int __bsf(int v)
{
  int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __bsr(int v)
{
  int r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline int __btc(int v, int i)
{
  int r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __bts(int v, int i)
{
  int r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int __btr(int v, int i)
{
  int r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bsf(size_t v)
{
  size_t r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}
#      endif

__forceinline unsigned int __bsf(unsigned int v)
{
  unsigned int r = 0;
  asm("bsf %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __bsr(size_t v)
{
  size_t r = 0;
  asm("bsr %1,%0" : "=r"(r) : "r"(v));
  return r;
}

__forceinline size_t __btc(size_t v, size_t i)
{
  size_t r = 0;
  asm("btc %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __bts(size_t v, size_t i)
{
  size_t r = 0;
  asm("bts %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline size_t __btr(size_t v, size_t i)
{
  size_t r = 0;
  asm("btr %1,%0" : "=r"(r) : "r"(i), "0"(v) : "flags");
  return r;
}

__forceinline int bitscan(int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

__forceinline unsigned int bitscan(unsigned int v)
{
#      if defined(__KERNEL_AVX2__)
  return _tzcnt_u32(v);
#      else
  return __bsf(v);
#      endif
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t bitscan(size_t v)
{
#        if defined(__KERNEL_AVX2__)
#          if defined(__KERNEL_64_BIT__)
  return _tzcnt_u64(v);
#          else
  return _tzcnt_u32(v);
#          endif
#        else
  return __bsf(v);
#        endif
}
#      endif

__forceinline int clz(const int x)
{
#      if defined(__KERNEL_AVX2__)
  return _lzcnt_u32(x);
#      else
  if (UNLIKELY(x == 0))
    return 32;
  return 31 - __bsr(x);
#      endif
}

__forceinline int __bscf(int &v)
{
  int i = bitscan(v);
#      if defined(__KERNEL_AVX2__)
  v &= v - 1;
#      else
  v = __btc(v, i);
#      endif
  return i;
}

__forceinline unsigned int __bscf(unsigned int &v)
{
  unsigned int i = bitscan(v);
  v &= v - 1;
  return i;
}

#      if (defined(__KERNEL_64_BIT__) || defined(__APPLE__)) && \
          !(defined(__ILP32__) && defined(__x86_64__))
__forceinline size_t __bscf(size_t &v)
{
  size_t i = bitscan(v);
#        if defined(__KERNEL_AVX2__)
  v &= v - 1;
#        else
  v = __btc(v, i);
#        endif
  return i;
}
#      endif

#    endif /* _WIN32 */

/* Test __KERNEL_SSE41__ for MSVC which does not define __SSE4_1__, and test
 * __SSE4_1__ to avoid OpenImageIO conflicts with our emulation macros on other
 * platforms when compiling code outside the kernel. */
#    if !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__))

/* Emulation of SSE4 functions with SSE2 */

#      define _MM_FROUND_TO_NEAREST_INT 0x00
#      define _MM_FROUND_TO_NEG_INF 0x01
#      define _MM_FROUND_TO_POS_INF 0x02
#      define _MM_FROUND_TO_ZERO 0x03
#      define _MM_FROUND_CUR_DIRECTION 0x04

#      undef _mm_blendv_ps
#      define _mm_blendv_ps _mm_blendv_ps_emu
__forceinline __m128 _mm_blendv_ps_emu(__m128 value, __m128 input, __m128 mask)
{
  __m128i isignmask = _mm_set1_epi32(0x80000000);
  __m128 signmask = _mm_castsi128_ps(isignmask);
  __m128i iandsign = _mm_castps_si128(_mm_and_ps(mask, signmask));
  __m128i icmpmask = _mm_cmpeq_epi32(iandsign, isignmask);
  __m128 cmpmask = _mm_castsi128_ps(icmpmask);
  return _mm_or_ps(_mm_and_ps(cmpmask, input), _mm_andnot_ps(cmpmask, value));
}

#      undef _mm_blend_ps
#      define _mm_blend_ps _mm_blend_ps_emu
__forceinline __m128 _mm_blend_ps_emu(__m128 value, __m128 input, const int mask)
{
  assert(mask < 0x10);
  return _mm_blendv_ps(value, input, _mm_lookupmask_ps[mask]);
}

#      undef _mm_blendv_epi8
#      define _mm_blendv_epi8 _mm_blendv_epi8_emu
__forceinline __m128i _mm_blendv_epi8_emu(__m128i value, __m128i input, __m128i mask)
{
  return _mm_or_si128(_mm_and_si128(mask, input), _mm_andnot_si128(mask, value));
}

#      undef _mm_min_epi32
#      define _mm_min_epi32 _mm_min_epi32_emu
__forceinline __m128i _mm_min_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(input, value, _mm_cmplt_epi32(value, input));
}

#      undef _mm_max_epi32
#      define _mm_max_epi32 _mm_max_epi32_emu
__forceinline __m128i _mm_max_epi32_emu(__m128i value, __m128i input)
{
  return _mm_blendv_epi8(value, input, _mm_cmplt_epi32(value, input));
}

#      undef _mm_extract_epi32
#      define _mm_extract_epi32 _mm_extract_epi32_emu
__forceinline int _mm_extract_epi32_emu(__m128i input, const int index)
{
  switch (index) {
    case 0:
      return _mm_cvtsi128_si32(input);
    case 1:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(1, 1, 1, 1)));
    case 2:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(2, 2, 2, 2)));
    case 3:
      return _mm_cvtsi128_si32(_mm_shuffle_epi32(input, _MM_SHUFFLE(3, 3, 3, 3)));
    default:
      assert(false);
      return 0;
  }
}

#      undef _mm_insert_epi32
#      define _mm_insert_epi32 _mm_insert_epi32_emu
__forceinline __m128i _mm_insert_epi32_emu(__m128i value, int input, const int index)
{
  assert(index >= 0 && index < 4);
  ((int *)&value)[index] = input;
  return value;
}

#      undef _mm_insert_ps
#      define _mm_insert_ps _mm_insert_ps_emu
__forceinline __m128 _mm_insert_ps_emu(__m128 value, __m128 input, const int index)
{
  assert(index < 0x100);
  ((float *)&value)[(index >> 4) & 0x3] = ((float *)&input)[index >> 6];
  return _mm_andnot_ps(_mm_lookupmask_ps[index & 0xf], value);
}

#      undef _mm_round_ps
#      define _mm_round_ps _mm_round_ps_emu
__forceinline __m128 _mm_round_ps_emu(__m128 value, const int flags)
{
  switch (flags) {
    case _MM_FROUND_TO_NEAREST_INT:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(value));
    case _MM_FROUND_TO_NEG_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(-0.5f))));
    case _MM_FROUND_TO_POS_INF:
      return _mm_cvtepi32_ps(_mm_cvtps_epi32(_mm_add_ps(value, _mm_set1_ps(0.5f))));
    case _MM_FROUND_TO_ZERO:
      return _mm_cvtepi32_ps(_mm_cvttps_epi32(value));
  }
  return value;
}

#    endif /* !(defined(__KERNEL_SSE41__) || defined(__SSE4_1__) || defined(__SSE4_2__)) */

/* Older GCC versions do not have _mm256_cvtss_f32 yet, so define it ourselves.
 * _mm256_castps256_ps128 generates no instructions so this is just as efficient. */
#    if defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
#      undef _mm256_cvtss_f32
#      define _mm256_cvtss_f32(a) (_mm_cvtss_f32(_mm256_castps256_ps128(a)))
#    endif

#  else /* __KERNEL_SSE2__ */

/* This section is for utility functions which operates on non-register data
 * which might be used from a non-vectorized code.
 */

ccl_device_inline int bitscan(int value)
{
  assert(value != 0);
  int bit = 0;
  while ((value & (1 << bit)) == 0) {
    ++bit;
  }
  return bit;
}

ccl_device_inline int __bsr(int value)
{
  assert(value != 0);
  int bit = 0;
  while (value >>= 1) {
    ++bit;
  }
  return bit;
}

#  endif /* __KERNEL_SSE2__ */

/* quiet unused define warnings */
#  if defined(__KERNEL_SSE2__) || defined(__KERNEL_SSE3__) || defined(__KERNEL_SSSE3__) || \
      defined(__KERNEL_SSE41__) || defined(__KERNEL_AVX__) || defined(__KERNEL_AVX2__)
/* do nothing */
#  endif

CCL_NAMESPACE_END

#endif /* __KERNEL_COMPUTE__ */

#endif /* __COM_KERNEL_SIMD_H__ */

#line 20 ".kernel_util/COM_kernel_types.h"
#endif

CCL_NAMESPACE_BEGIN

/* Types
 *
 * Define simpler unsigned type names, and integer with defined number of bits.
 * Also vector types, named to be compatible with OpenCL builtin types, while
 * working for CUDA and C++ too. */

/* Shorter Unsigned Names */

#ifndef __KERNEL_OPENCL__
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
#endif

/* There might be kernel types that don't support bool as kernel arguments (OpenCL for example),
 * we just use int in kernels which usually has better performance than other types*/
#define BOOL int
#define TRUE 1
#define FALSE 0

/* Fixed Bits Types */

#ifdef __KERNEL_OPENCL__
typedef ulong uint64_t;
#endif

#ifndef __KERNEL_COMPUTE__
#  ifdef _WIN32
typedef signed char int8_t;
typedef unsigned char uint8_t;

typedef signed short int16_t;
typedef unsigned short uint16_t;

typedef signed int int32_t;
typedef unsigned int uint32_t;

typedef long long int64_t;
typedef unsigned long long uint64_t;
#    ifdef __KERNEL_64_BIT__
typedef int64_t ssize_t;
#    else
typedef int32_t ssize_t;
#    endif
#  endif /* _WIN32 */

/* Generic Memory Pointer */

typedef uint64_t device_ptr;
#endif /* __KERNEL_COMPUTE__ */

ccl_device_inline size_t align_up(size_t offset, size_t alignment)
{
  return (offset + alignment - 1) & ~(alignment - 1);
}

ccl_device_inline size_t divide_up(size_t x, size_t y)
{
  return (x + y - 1) / y;
}

ccl_device_inline size_t round_up(size_t x, size_t multiple)
{
  return ((x + multiple - 1) / multiple) * multiple;
}

ccl_device_inline size_t round_down(size_t x, size_t multiple)
{
  return (x / multiple) * multiple;
}

ccl_device_inline bool is_power_of_two(size_t x)
{
  return (x & (x - 1)) == 0;
}

CCL_NAMESPACE_END

#ifndef __KERNEL_COMPUTE__

#line 1 ".kernel_util\\COM_kernel_types_int2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_H__
#define __COM_KERNEL_TYPES_INT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int2 {
  int x, y;

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int2 make_int2(int x, int y);

CCL_NAMESPACE_END

#endif

#line 105 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_H__
#define __COM_KERNEL_TYPES_INT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) int3
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int3();
  __forceinline int3(const int3 &a);
  __forceinline explicit int3(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int3 &operator=(const int3 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int3 make_int3_1(int i);
ccl_device_inline int3 make_int3(int x, int y, int z);
ccl_device_inline void print_int3(const char *label, const int3 &a);

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_H__ */

#line 106 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_H__
#define __COM_KERNEL_TYPES_INT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float3;
struct float4;

struct ccl_try_align(16) int4
{
#ifdef __KERNEL_SSE__
  union {
    __m128i m128;
    struct {
      int x, y, z, w;
    };
  };

  __forceinline int4();
  __forceinline int4(const int4 &a);
  __forceinline explicit int4(const __m128i &a);

  __forceinline operator const __m128i &() const;
  __forceinline operator __m128i &();

  __forceinline int4 &operator=(const int4 &a);
#else  /* __KERNEL_SSE__ */
  int x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline int operator[](int i) const;
  __forceinline int &operator[](int i);
};

ccl_device_inline int4 make_int4_1(int i);
ccl_device_inline int4 make_int4(int x, int y, int z, int w);
ccl_device_inline void print_int4(const char *label, const int4 &a);

CCL_NAMESPACE_END

#endif

#line 107 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_H__
#define __COM_KERNEL_TYPES_FLOAT2_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct float2 {
  float x, y;

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

float2 make_float2(float x, float y);
ccl_device_inline void print_float2(const char *label, const float2 &a);

CCL_NAMESPACE_END

#endif

#line 109 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_H__
#define __COM_KERNEL_TYPES_FLOAT3_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct ccl_try_align(16) float3
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float3();
  __forceinline float3(const float3 &a);
  __forceinline explicit float3(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float3 &operator=(const float3 &a);
#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float3 make_float3_1(float f);
ccl_device_inline float3 make_float3(float x, float y, float z);
ccl_device_inline float3 make_float3_4(const float4 &f4);
ccl_device_inline void print_float3(const char *label, const float3 &a);

CCL_NAMESPACE_END

#endif

#line 110 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_H__
#define __COM_KERNEL_TYPES_FLOAT4_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

struct int4;

struct ccl_try_align(16) float4
{
#ifdef __KERNEL_SSE__
  union {
    __m128 m128;
    struct {
      float x, y, z, w;
    };
  };

  __forceinline float4();
  __forceinline explicit float4(const __m128 &a);

  __forceinline operator const __m128 &() const;
  __forceinline operator __m128 &();

  __forceinline float4 &operator=(const float4 &a);

#else  /* __KERNEL_SSE__ */
  float x, y, z, w;
#endif /* __KERNEL_SSE__ */

  __forceinline float operator[](int i) const;
  __forceinline float &operator[](int i);
};

ccl_device_inline float4 make_float4_1(float f);
ccl_device_inline float4 make_float4(float x, float y, float z, float w);
ccl_device_inline float4 make_float4_3(const float3 &f3);
ccl_device_inline void print_float4(const char *label, const float4 &a);

CCL_NAMESPACE_END

#endif

#line 111 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_int2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT2_IMPL_H__
#define __COM_KERNEL_TYPES_INT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

int int2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

int &int2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline int2 make_int2(int x, int y)
{
  int2 a = {x, y};
  return a;
}

CCL_NAMESPACE_END

#endif

#line 113 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT3_IMPL_H__
#define __COM_KERNEL_TYPES_INT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int3::int3()
{
}

__forceinline int3::int3(const __m128i &a) : m128(a)
{
}

__forceinline int3::int3(const int3 &a) : m128(a.m128)
{
}

__forceinline int3::operator const __m128i &() const
{
  return m128;
}

__forceinline int3::operator __m128i &()
{
  return m128;
}

__forceinline int3 &int3::operator=(const int3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline int &int3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline int3 make_int3_1(int i)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set1_epi32(i));
#else
  int3 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int3 make_int3(int x, int y, int z)
{
#ifdef __KERNEL_SSE__
  int3 a(_mm_set_epi32(0, z, y, x));
#else
  int3 a = {x, y, z, 0};
#endif

  return a;
}

ccl_device_inline void print_int3(const char *label, const int3 &a)
{
  printf("%s: %d %d %d\n", label, a.x, a.y, a.z);
}

CCL_NAMESPACE_END

#endif /* __COM_KERNEL_TYPES_INT3_IMPL_H__ */

#line 114 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_int4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_INT4_IMPL_H__
#define __COM_KERNEL_TYPES_INT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline int4::int4()
{
}

__forceinline int4::int4(const int4 &a) : m128(a.m128)
{
}

__forceinline int4::int4(const __m128i &a) : m128(a)
{
}

__forceinline int4::operator const __m128i &() const
{
  return m128;
}

__forceinline int4::operator __m128i &()
{
  return m128;
}

__forceinline int4 &int4::operator=(const int4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline int int4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline int &int4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline int4 make_int4_1(int i)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set1_epi32(i));
#else
  int4 a = {i, i, i, i};
#endif
  return a;
}

ccl_device_inline int4 make_int4(int x, int y, int z, int w)
{
#ifdef __KERNEL_SSE__
  int4 a(_mm_set_epi32(w, z, y, x));
#else
  int4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline void print_int4(const char *label, const int4 &a)
{
  printf("%s: %d %d %d %d\n", label, a.x, a.y, a.z, a.w);
}

CCL_NAMESPACE_END

#endif

#line 115 ".kernel_util/COM_kernel_types.h"

#line 1 ".kernel_util\\COM_kernel_types_float2_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT2_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT2_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

__forceinline float float2::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

__forceinline float &float2::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 2);
  return *(&x + i);
}

ccl_device_inline float2 make_float2(float x, float y)
{
  float2 a = {x, y};
  return a;
}

ccl_device_inline void print_float2(const char *label, const float2 &a)
{
  printf("%s: %.8f %.8f\n", label, (double)a.x, (double)a.y);
}

CCL_NAMESPACE_END

#endif

#line 117 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float3_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT3_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT3_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float3::float3()
{
}

__forceinline float3::float3(const float3 &a) : m128(a.m128)
{
}

__forceinline float3::float3(const __m128 &a) : m128(a)
{
}

__forceinline float3::operator const __m128 &() const
{
  return m128;
}

__forceinline float3::operator __m128 &()
{
  return m128;
}

__forceinline float3 &float3::operator=(const float3 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float3::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

__forceinline float &float3::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 3);
  return *(&x + i);
}

ccl_device_inline float3 make_float3_1(float f)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set1_ps(f));
#else
  float3 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float3 make_float3(float x, float y, float z)
{
#ifdef __KERNEL_SSE__
  float3 a(_mm_set_ps(0.0f, z, y, x));
#else
  float3 a = {x, y, z, 0.0f};
#endif
  return a;
}

ccl_device_inline float3 make_float3_4(const float4 &f4)
{
#ifdef __KERNEL_SSE__
  float3 a(f4.m128);
#else
  float3 a = {f4.x, f4.y, f4.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float3(const char *label, const float3 &a)
{
  printf("%s: %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z);
}

CCL_NAMESPACE_END

#endif

#line 118 ".kernel_util/COM_kernel_types.h"
#line 1 ".kernel_util\\COM_kernel_types_float4_impl.h"
/*
 * Copyright 2011-2017 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __COM_KERNEL_TYPES_FLOAT4_IMPL_H__
#define __COM_KERNEL_TYPES_FLOAT4_IMPL_H__

#ifndef __COM_KERNEL_TYPES_H__
#  error "Do not include this file directly, include COM_kernel_types.h instead."
#endif

CCL_NAMESPACE_BEGIN

#ifdef __KERNEL_SSE__
__forceinline float4::float4()
{
}

__forceinline float4::float4(const __m128 &a) : m128(a)
{
}

__forceinline float4::operator const __m128 &() const
{
  return m128;
}

__forceinline float4::operator __m128 &()
{
  return m128;
}

__forceinline float4 &float4::operator=(const float4 &a)
{
  m128 = a.m128;
  return *this;
}
#endif /* __KERNEL_SSE__ */

__forceinline float float4::operator[](int i) const
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

__forceinline float &float4::operator[](int i)
{
  kernel_assert(i >= 0);
  kernel_assert(i < 4);
  return *(&x + i);
}

ccl_device_inline float4 make_float4_1(float f)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set1_ps(f));
#else
  float4 a = {f, f, f, f};
#endif
  return a;
}

ccl_device_inline float4 make_float4(float x, float y, float z, float w)
{
#ifdef __KERNEL_SSE__
  float4 a(_mm_set_ps(w, z, y, x));
#else
  float4 a = {x, y, z, w};
#endif
  return a;
}

ccl_device_inline float4 make_float4_3(const float3 &f3)
{
#ifdef __KERNEL_SSE__
  float4 a(f3.m128);
#else
  float4 a = {f3.x, f3.y, f3.z, 0.0f};
#endif
  return a;
}

ccl_device_inline void print_float4(const char *label, const float4 &a)
{
  printf("%s: %.8f %.8f %.8f %.8f\n", label, (double)a.x, (double)a.y, (double)a.z, (double)a.w);
}

CCL_NAMESPACE_END

#endif

#line 119 ".kernel_util/COM_kernel_types.h"

#endif

#endif

#line 156 ".COM_kernel_opencl.h"

/* Kernel function signature macros*/
#define CCL_READ(image) \
  __read_only image2d_t image, const BOOL image##_single, const float4 image##_single_elem
#define CCL_WRITE(image) \
  __write_only image2d_t image, const int image##_start_x, const int image##_start_y
#define CCL_SAMPLER(sampler) const sampler_t sampler
/* END of OpenCL kernel function signature macros*/

#define READ_DECL(src) float4 src##_pix;
#define SAMPLE_DECL(src) float4 src##_pix;
#define WRITE_DECL(dst) \
  int2 dst##_coords; \
  int write_offset_x = get_global_id(0), write_offset_y = get_global_id(1);

#define COORDS_TO_OFFSET(coords) \
  coords.x = dst##_start_x + write_offset_x; \
  coords.y = dst##_start_y + write_offset_y;

/*src_img must be a image2d_t , coords must be int2*/
#define READ_IMG(src, coords, result) \
  result = src##_single ? src##_single_elem : read_imagef(src, coords);

/*src_img must be a image2d_t, sampler must be sampler_t, coords must be float2*/
#define SAMPLE_IMG(src, coords, sampler, result) \
  result = src##_single ? src##_single_elem : read_imagef(src, sampler, coords);

/*dst_img must be a image2d_t , coords must be int2, pixel must be float4*/
#define WRITE_IMG(dst, coords, pixel) write_imagef(dst, coords, pixel);

/*CPU op loop*/

#define CPU_LOOP_START(dst)

#define CPU_LOOP_END

/*END of CPU op loop*/

#endif

#line 1 ".COM_OpenCLKernels.cl"
CCL_NAMESPACE_BEGIN

ccl_kernel alphaOverKeyOp(CCL_WRITE(dst), CCL_READ(value), CCL_READ(color), CCL_READ(over_color))
{
  READ_DECL(value);
  READ_DECL(color);
  READ_DECL(over_color);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color, dst_coords, color_pix);
  READ_IMG(over_color, dst_coords, over_color_pix);

  if (over_color_pix.w <= 0.0f) {
    WRITE_IMG(dst, dst_coords, color_pix);
  }
  else if (value_pix.x == 1.0f && over_color_pix.w >= 1.0f) {
    WRITE_IMG(dst, dst_coords, over_color_pix);
  }
  else {
    float premul = value_pix.x * over_color_pix.w;
    float premul_inv = 1.0f - premul;

    color_pix = premul_inv * color_pix;
    float alpha = color_pix.w;
    color_pix += premul * over_color_pix;
    color_pix.w = alpha + value_pix.x * over_color_pix.w;
    WRITE_IMG(dst, dst_coords, color_pix);
  }

  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN

ccl_kernel alphaOverMixedOp(
    CCL_WRITE(dst), CCL_READ(value), CCL_READ(color), CCL_READ(over_color), int x_factor)
{
  READ_DECL(value);
  READ_DECL(color);
  READ_DECL(over_color);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color, dst_coords, color_pix);
  READ_IMG(over_color, dst_coords, over_color_pix);

  if (over_color_pix.w <= 0.0f) {
    WRITE_IMG(dst, dst_coords, color_pix);
  }
  else if (value_pix.x == 1.0f && over_color_pix.w >= 1.0f) {
    WRITE_IMG(dst, dst_coords, over_color_pix);
  }
  else {
    float addfac = 1.0f - x_factor + over_color_pix.w * x_factor;
    float premul = value_pix.x * addfac;
    float mul = 1.0f - value_pix.x * over_color_pix.w;

    float4 mul_color = mul * color_pix;
    color_pix = mul_color + premul * over_color_pix;
    color_pix.w = mul_color.w + value_pix.x * over_color_pix.w;

    WRITE_IMG(dst, dst_coords, color_pix);
  }

  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN

ccl_kernel alphaOverPremultiplyOp(CCL_WRITE(dst),
                                  CCL_READ(value),
                                  CCL_READ(color),
                                  CCL_READ(over_color))
{
  READ_DECL(value);
  READ_DECL(color);
  READ_DECL(over_color);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color, dst_coords, color_pix);
  READ_IMG(over_color, dst_coords, over_color_pix);

  if (over_color_pix.w <= 0.0f) {
    WRITE_IMG(dst, dst_coords, color_pix);
  }
  else if (value_pix.x == 1.0f && over_color_pix.w >= 1.0f) {
    WRITE_IMG(dst, dst_coords, over_color_pix);
  }
  else {
    float mul = 1.0f - value_pix.x * over_color_pix.w;
    color_pix = mul * color_pix + value_pix.x * over_color_pix;
    WRITE_IMG(dst, dst_coords, color_pix);
  }

  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN

ccl_kernel brightnessOp(
    CCL_WRITE(dst), CCL_READ(color), CCL_READ(bright), CCL_READ(contrast), BOOL premultiply)
{
  float a, b, bright_value, contrast_value, delta;

  READ_DECL(color);
  READ_DECL(bright);
  READ_DECL(contrast);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(color, dst_coords, color_pix);
  READ_IMG(bright, dst_coords, bright_pix);
  READ_IMG(contrast, dst_coords, contrast_pix);

  bright_value = bright_pix.x / 100.0f;
  contrast_value = contrast_pix.x;
  delta = contrast_value / 200.0f;
  /*
   * The algorithm is by Werner D. Streidt
   * (http://visca.com/ffactory/archives/5-99/msg00021.html)
   * Extracted of OpenCV demhist.c
   */
  if (contrast_value > 0) {
    a = 1.0f - delta * 2.0f;
    a = 1.0f / fmaxf(a, FLT_EPSILON);
    b = a * (bright_value - delta);
  }
  else {
    delta *= -1;
    a = fmaxf(1.0f - delta * 2.0f, 0.0f);
    b = a * bright_value + delta;
  }

  float alpha = color_pix.w;
  if (premultiply) {
    premul_to_straight(color_pix);
    color_pix = a * color_pix + b;
    color_pix.w = alpha;
    straight_to_premul(color_pix);
  }
  else {
    color_pix = a * color_pix + b;
    color_pix.w = alpha;
  }

  WRITE_IMG(dst, dst_coords, color_pix);

  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel changeHsvOp(
    CCL_WRITE(dst), CCL_READ(color), CCL_READ(hue), CCL_READ(sat), CCL_READ(value))
{
  READ_DECL(value);
  READ_DECL(color);
  READ_DECL(hue);
  READ_DECL(sat);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color, dst_coords, color_pix);
  READ_IMG(hue, dst_coords, hue_pix);
  READ_IMG(sat, dst_coords, sat_pix);

  color_pix.x += (hue_pix.x - 0.5f);
  if (color_pix.x > 1.0f) {
    color_pix.x -= 1.0f;
  }
  else if (color_pix.x < 0.0f) {
    color_pix.x += 1.0f;
  }
  color_pix.y *= sat_pix.x;
  color_pix.z *= value_pix.x;

  WRITE_IMG(dst, dst_coords, color_pix);

  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel colorBalanceASCCDLOp(
    CCL_WRITE(dst), CCL_READ(value), CCL_READ(color), float4 offset, float4 power, float4 slope)
{
  READ_DECL(value);
  READ_DECL(color);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color, dst_coords, color_pix);

  const float fac = fminf(1.0f, value_pix.x);
  const float mfac = 1.0f - fac;

  float4 res = mfac * color_pix + fac * colorbalance_cdl(color_pix, offset, power, slope);
  res.w = color_pix.w;

  WRITE_IMG(dst, dst_coords, res);

  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel colorBalanceLGGOp(
    CCL_WRITE(dst), CCL_READ(value), CCL_READ(color), float4 lift, float4 gamma_inv, float4 gain)
{
  READ_DECL(value);
  READ_DECL(color);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color, dst_coords, color_pix);

  const float fac = fminf(1.0f, value_pix.x);
  const float mfac = 1.0f - fac;

  float4 res = mfac * color_pix + fac * colorbalance_lgg(color_pix, lift, gamma_inv, gain);
  res.w = color_pix.w;

  WRITE_IMG(dst, dst_coords, res);

  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel gammaOp(CCL_WRITE(dst), CCL_READ(color), CCL_READ(gamma))
{
  READ_DECL(gamma);
  READ_DECL(color);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(gamma, dst_coords, gamma_pix);
  READ_IMG(color, dst_coords, color_pix);

  /* check for negative to avoid nan's */
  color_pix.x = color_pix.x > 0.0f ? powf(color_pix.x, gamma_pix.x) : color_pix.x;
  color_pix.y = color_pix.y > 0.0f ? powf(color_pix.y, gamma_pix.x) : color_pix.y;
  color_pix.z = color_pix.z > 0.0f ? powf(color_pix.z, gamma_pix.x) : color_pix.z;

  WRITE_IMG(dst, dst_coords, color_pix);

  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel invertOp(
    CCL_WRITE(dst), CCL_READ(factor), CCL_READ(color), BOOL do_color, BOOL do_alpha)
{
  READ_DECL(factor);
  READ_DECL(color);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(factor, dst_coords, factor_pix);
  READ_IMG(color, dst_coords, color_pix);

  const float value = factor_pix.x;
  const float inv_value = 1.0f - value;
  const float alpha = color_pix.w;
  if (do_color) {
    color_pix = (1.0f - color_pix) * value + color_pix * inv_value;
  }

  if (do_alpha) {
    color_pix.w = (1.0f - alpha) * value + alpha * inv_value;
  }
  else {
    color_pix.w = alpha;
  }

  WRITE_IMG(dst, dst_coords, color_pix);

  CPU_LOOP_END;
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN

ccl_kernel mixBaseOp(
    CCL_WRITE(dst), CCL_READ(value), CCL_READ(color1), CCL_READ(color2), BOOL alpha_multiply)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }
  color2_pix = (1.0f - value_pix.x) * color1_pix + value_pix.x * color2_pix;
  color2_pix.w = color1_pix.w;

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN

ccl_kernel mixAddOp(CCL_WRITE(dst),
                    CCL_READ(value),
                    CCL_READ(color1),
                    CCL_READ(color2),
                    BOOL alpha_multiply,
                    BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }
  color2_pix = color1_pix + value_pix.x * color2_pix;
  color2_pix.w = color1_pix.w;
  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN

ccl_kernel mixBlendOp(CCL_WRITE(dst),
                      CCL_READ(value),
                      CCL_READ(color1),
                      CCL_READ(color2),
                      BOOL alpha_multiply,
                      BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }
  color2_pix = (1.0f - value_pix.x) * color1_pix + value_pix.x * color2_pix;
  color2_pix.w = color1_pix.w;
  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN

ccl_kernel mixColorBurnOp(
    CCL_WRITE(dst), CCL_READ(value), CCL_READ(color1), CCL_READ(color2), BOOL alpha_multiply)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }

  float4 zero4 = make_float4_1(0.0f);
  color2_pix = (1.0f - value_pix.x) + value_pix.x * color2_pix;
  int4 color2_eqless_0 = color2_pix <= zero4;
  color2_pix = 1.0f - (1.0f - color1_pix) / color2_pix;
  color2_pix = select(color2_pix, zero4, color2_eqless_0);
  color2_pix.w = color1_pix.w;
  color2_pix = clamp_to_normal_f4(color2_pix);

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN

ccl_kernel mixColorOp(CCL_WRITE(dst),
                      CCL_READ(value),
                      CCL_READ(color1),
                      CCL_READ(color2),
                      BOOL alpha_multiply,
                      BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }

  float4 color2_hsv = rgb_to_hsv(color2_pix);
  if (color2_hsv.y != 0.0f) {
    float4 color1_hsv = rgb_to_hsv(color1_pix);
    color2_hsv.z = color1_hsv.z;
    color2_pix = hsv_to_rgb(color2_hsv);
    color2_pix = (1.0f - value_pix.x) * color1_pix + value_pix.x * color2_pix;
    color2_pix.w = color1_pix.w;
  }
  else {
    color2_pix = color1_pix;
  }

  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mixDarkenOp(CCL_WRITE(dst),
                       CCL_READ(value),
                       CCL_READ(color1),
                       CCL_READ(color2),
                       BOOL alpha_multiply,
                       BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }

  color2_pix = min(color1_pix, color2_pix) * value_pix.x + color1_pix * (1.0f - value_pix.x);
  color2_pix.w = color1_pix.w;
  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mixDifferenceOp(CCL_WRITE(dst),
                           CCL_READ(value),
                           CCL_READ(color1),
                           CCL_READ(color2),
                           BOOL alpha_multiply,
                           BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }

  color2_pix = (1.0f - value_pix.x) * color1_pix + value_pix.x * fabs(color1_pix - color2_pix);
  color2_pix.w = color1_pix.w;
  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mixDivideOp(CCL_WRITE(dst),
                       CCL_READ(value),
                       CCL_READ(color1),
                       CCL_READ(color2),
                       BOOL alpha_multiply,
                       BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }

  float4 zero4 = make_float4_1(0.0f);
  int4 color2_not0 = color2_pix != zero4;
  color2_pix = (1.0f - value_pix.x) * color1_pix + value_pix.x * color1_pix / color2_pix;
  color2_pix = select(zero4, color2_pix, color2_not0);
  color2_pix.w = color1_pix.w;
  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mixDodgeOp(CCL_WRITE(dst),
                      CCL_READ(value),
                      CCL_READ(color1),
                      CCL_READ(color2),
                      BOOL alpha_multiply,
                      BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }

  if (color1_pix.x != 0.0f) {
    color2_pix.x = 1.0f - value_pix.x * color2_pix.x;
    if (color2_pix.x <= 0.0f) {
      color2_pix.x = 1.0f;
    }
    else {
      color2_pix.x = color1_pix.x / color2_pix.x;
      if (color2_pix.x > 1.0f) {
        color2_pix.x = 1.0f;
      }
    }
  }
  else {
    color2_pix.x = 0.0f;
  }

  if (color1_pix.y != 0.0f) {
    color2_pix.y = 1.0f - value_pix.x * color2_pix.y;
    if (color2_pix.y <= 0.0f) {
      color2_pix.y = 1.0f;
    }
    else {
      color2_pix.y = color1_pix.y / color2_pix.y;
      if (color2_pix.y > 1.0f) {
        color2_pix.y = 1.0f;
      }
    }
  }
  else {
    color2_pix.y = 0.0f;
  }

  if (color1_pix.z != 0.0f) {
    color2_pix.z = 1.0f - value_pix.x * color2_pix.z;
    if (color2_pix.z <= 0.0f) {
      color2_pix.z = 1.0f;
    }
    else {
      color2_pix.z = color1_pix.z / color2_pix.z;
      if (color2_pix.z > 1.0f) {
        color2_pix.z = 1.0f;
      }
    }
  }
  else {
    color2_pix.z = 0.0f;
  }

  color2_pix.w = color1_pix.w;
  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mixGlareOp(
    CCL_WRITE(dst), CCL_READ(value), CCL_READ(color1), CCL_READ(color2), BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  float mf = 2.0f - 2.0f * fabsf(value_pix.x - 0.5f);
  float4 zero4 = make_float4_1(0.0f);
  float alpha = color1_pix.w;
  color1_pix = select(color1_pix, zero4, color1_pix < zero4);
  color2_pix = mf * max(color1_pix + value_pix.x * (color2_pix - color1_pix), 0.0f);
  color2_pix.w = alpha;
  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN

ccl_kernel mixHueOp(CCL_WRITE(dst),
                    CCL_READ(value),
                    CCL_READ(color1),
                    CCL_READ(color2),
                    BOOL alpha_multiply,
                    BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }

  float4 color2_hsv = rgb_to_hsv(color2_pix);
  if (color2_hsv.y != 0.0f) {
    float4 color1_hsv = rgb_to_hsv(color1_pix);
    color1_hsv.x = color2_hsv.x;
    color2_pix = hsv_to_rgb(color1_hsv);
    color2_pix = (1.0f - value_pix.x) * color1_pix + value_pix.x * color2_pix;
    color2_pix.w = color1_pix.w;
  }
  else {
    color2_pix = color1_pix;
  }

  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mixLightenOp(CCL_WRITE(dst),
                        CCL_READ(value),
                        CCL_READ(color1),
                        CCL_READ(color2),
                        BOOL alpha_multiply,
                        BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }

  color2_pix = value_pix.x * color2_pix;
  color2_pix = select(color1_pix, color2_pix, color2_pix > color1_pix);
  color2_pix.w = color1_pix.w;
  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mixLinearLightOp(CCL_WRITE(dst),
                            CCL_READ(value),
                            CCL_READ(color1),
                            CCL_READ(color2),
                            BOOL alpha_multiply,
                            BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }

  if (color2_pix.x > 0.5f) {
    color2_pix.x = color1_pix.x + value_pix.x * (2.0f * (color2_pix.x - 0.5f));
  }
  else {
    color2_pix.x = color1_pix.x + value_pix.x * (2.0f * color2_pix.x - 1.0f);
  }
  if (color2_pix.y > 0.5f) {
    color2_pix.y = color1_pix.y + value_pix.x * (2.0f * (color2_pix.y - 0.5f));
  }
  else {
    color2_pix.y = color1_pix.y + value_pix.x * (2.0f * color2_pix.y - 1.0f);
  }
  if (color2_pix.z > 0.5f) {
    color2_pix.z = color1_pix.z + value_pix.x * (2.0f * (color2_pix.z - 0.5f));
  }
  else {
    color2_pix.z = color1_pix.z + value_pix.x * (2.0f * color2_pix.z - 1.0f);
  }
  color2_pix.w = color1_pix.w;

  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mixMultiplyOp(CCL_WRITE(dst),
                         CCL_READ(value),
                         CCL_READ(color1),
                         CCL_READ(color2),
                         BOOL alpha_multiply,
                         BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }

  color2_pix = color1_pix * ((1.0f - value_pix.x) + value_pix.x * color2_pix);
  color2_pix.w = color1_pix.w;
  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mixOverlayOp(CCL_WRITE(dst),
                        CCL_READ(value),
                        CCL_READ(color1),
                        CCL_READ(color2),
                        BOOL alpha_multiply,
                        BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }

  float valuem = 1.0f - value_pix.x;
  float value2 = 2.0f * value_pix.x;
  if (color1_pix.x < 0.5f) {
    color2_pix.x = color1_pix.x * (valuem + value2 * color2_pix.x);
  }
  else {
    color2_pix.x = 1.0f - (valuem + value2 * (1.0f - color2_pix.x)) * (1.0f - color1_pix.x);
  }
  if (color1_pix.y < 0.5f) {
    color2_pix.y = color1_pix.y * (valuem + value2 * color2_pix.y);
  }
  else {
    color2_pix.y = 1.0f - (valuem + value2 * (1.0f - color2_pix.y)) * (1.0f - color1_pix.y);
  }
  if (color1_pix.z < 0.5f) {
    color2_pix.z = color1_pix.z * (valuem + value2 * color2_pix.z);
  }
  else {
    color2_pix.z = 1.0f - (valuem + value2 * (1.0f - color2_pix.z)) * (1.0f - color1_pix.z);
  }
  color2_pix.w = color1_pix.w;

  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mixSaturationOp(CCL_WRITE(dst),
                           CCL_READ(value),
                           CCL_READ(color1),
                           CCL_READ(color2),
                           BOOL alpha_multiply,
                           BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }

  float4 color1_hsv = rgb_to_hsv(color1_pix);
  if (color1_pix.y != 0.0f) {
    float4 color2_hsv = rgb_to_hsv(color2_pix);
    color1_hsv.y = (1.0f - value_pix.x) * color1_hsv.y + value_pix.x * color2_hsv.y;
    color2_pix = hsv_to_rgb(color1_hsv);
  }
  else {
    color2_pix = color1_pix;
  }

  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mixScreenOp(CCL_WRITE(dst),
                       CCL_READ(value),
                       CCL_READ(color1),
                       CCL_READ(color2),
                       BOOL alpha_multiply,
                       BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }

  color2_pix = 1.0f -
               ((1.0f - value_pix.x) + value_pix.x * (1.0f - color2_pix)) * (1.0f - color1_pix);
  color2_pix.w = color1_pix.w;

  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mixSoftLightOp(CCL_WRITE(dst),
                          CCL_READ(value),
                          CCL_READ(color1),
                          CCL_READ(color2),
                          BOOL alpha_multiply,
                          BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }

  /* first calculate non-fac based Screen mix */
  float4 color1m = 1.0f - color1_pix;
  float4 screen = 1.0f - (1.0f - color2_pix) * color1m;
  color2_pix = (1.0f - value_pix.x) * color1_pix +
               value_pix.x * (color1m * color2_pix * color1_pix + color1_pix * screen);
  color2_pix.w = color1_pix.w;

  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mixSubstractOp(CCL_WRITE(dst),
                          CCL_READ(value),
                          CCL_READ(color1),
                          CCL_READ(color2),
                          BOOL alpha_multiply,
                          BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }

  color2_pix = color1_pix - value_pix.x * color2_pix;
  color2_pix.w = color1_pix.w;

  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mixValueOp(CCL_WRITE(dst),
                      CCL_READ(value),
                      CCL_READ(color1),
                      CCL_READ(color2),
                      BOOL alpha_multiply,
                      BOOL use_clamp)
{
  READ_DECL(value);
  READ_DECL(color1);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  if (alpha_multiply) {
    value_pix.x *= color2_pix.w;
  }

  float4 color1_hsv = rgb_to_hsv(color1_pix);
  float4 color2_hsv = rgb_to_hsv(color2_pix);
  color1_hsv.z = (1.0f - value_pix.x) * color1_hsv.z + value_pix.x * color2_hsv.z;
  color2_pix = hsv_to_rgb(color1_hsv);

  if (use_clamp) {
    color2_pix = clamp_to_normal_f4(color2_pix);
  }

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel zCombineOp(
    CCL_WRITE(dst), CCL_READ(color1), CCL_READ(z1), CCL_READ(color2), CCL_READ(z2))
{
  READ_DECL(color1);
  READ_DECL(z1);
  READ_DECL(color2);
  READ_DECL(z2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(z1, dst_coords, z1_pix);
  READ_IMG(color2, dst_coords, color2_pix);
  READ_IMG(z2, dst_coords, z2_pix);

  if (z1_pix.x < z2_pix.x) {
    WRITE_IMG(dst, dst_coords, color1_pix);
  }
  else {
    WRITE_IMG(dst, dst_coords, color2_pix);
  }

  CPU_LOOP_END;
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel zCombineAlphaOp(
    CCL_WRITE(dst), CCL_READ(color1), CCL_READ(z1), CCL_READ(color2), CCL_READ(z2))
{
  READ_DECL(color1);
  READ_DECL(z1);
  READ_DECL(color2);
  READ_DECL(z2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(z1, dst_coords, z1_pix);
  READ_IMG(z2, dst_coords, z2_pix);
  if (z1_pix.x <= z2_pix.x) {
    READ_IMG(color1, dst_coords, color1_pix);
    READ_IMG(color2, dst_coords, color2_pix);
  }
  else {
    READ_IMG(color1, dst_coords, color2_pix);
    READ_IMG(color2, dst_coords, color1_pix);
  }

  const float alpha1 = color1_pix.w;
  const float alpha2 = color2_pix.w;
  float alpha1_inv = 1.0f - alpha1;
  color2_pix = alpha1 * color1_pix + alpha1_inv * color2_pix;
  color2_pix.w = fmaxf(alpha1, alpha2);

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END;
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel zCombineMaskOp(CCL_WRITE(dst), CCL_READ(mask), CCL_READ(color1), CCL_READ(color2))
{
  READ_DECL(color1);
  READ_DECL(mask);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(mask, dst_coords, mask_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  color2_pix = interp_f4f4(color1_pix, color2_pix, 1.0f - mask_pix.x);

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel zCombineMaskAlphaOp(CCL_WRITE(dst), CCL_READ(mask), CCL_READ(color1), CCL_READ(color2))
{
  READ_DECL(color1);
  READ_DECL(mask);
  READ_DECL(color2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(mask, dst_coords, mask_pix);
  READ_IMG(color1, dst_coords, color1_pix);
  READ_IMG(color2, dst_coords, color2_pix);

  const float alpha1 = color1_pix.w;
  const float alpha2 = color2_pix.w;
  const float fac = (1.0f - mask_pix.x) * (1.0f - alpha1) + mask_pix.x * alpha2;
  const float mfac = 1.0f - fac;
  color2_pix = mfac * color1_pix + fac * color2_pix;
  color2_pix.w = fmaxf(alpha1, alpha2);

  WRITE_IMG(dst, dst_coords, color2_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel colorRampOp(CCL_WRITE(dst),
                       CCL_READ(factor),
                       const int n_bands,
                       const int interp_type,
                       const int hue_interp_type,
                       const int color_mode,
                       ccl_global float4 *bands_colors,
                       ccl_global float *bands_pos)
{
  READ_DECL(factor);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(factor, dst_coords, factor_pix);
  float4 result = colorband_evaluate(
      factor_pix.x, n_bands, interp_type, hue_interp_type, color_mode, bands_colors, bands_pos);
  WRITE_IMG(dst, dst_coords, result);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel convertValueToColorOp(CCL_WRITE(dst), CCL_READ(value))
{
  READ_DECL(value);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  value_pix.y = value_pix.x;
  value_pix.z = value_pix.x;
  value_pix.w = 1.0f;
  WRITE_IMG(dst, dst_coords, value_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel convertColorToValueOp(CCL_WRITE(dst), CCL_READ(color))
{
  READ_DECL(color);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(color, dst_coords, color_pix);
  color_pix.x = (color_pix.x + color_pix.y + color_pix.z) / 3.0f;
  WRITE_IMG(dst, dst_coords, color_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel convertColorToVectorOp(CCL_WRITE(dst), CCL_READ(color))
{
  READ_DECL(color);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(color, dst_coords, color_pix);
  WRITE_IMG(dst, dst_coords, color_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel convertValueToVectorOp(CCL_WRITE(dst), CCL_READ(value))
{
  READ_DECL(value);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(value, dst_coords, value_pix);
  value_pix.y = value_pix.x;
  value_pix.z = value_pix.x;
  WRITE_IMG(dst, dst_coords, value_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel convertVectorToColorOp(CCL_WRITE(dst), CCL_READ(vector))
{
  READ_DECL(vector);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(vector, dst_coords, vector_pix);
  vector_pix.w = 1.0f;
  WRITE_IMG(dst, dst_coords, vector_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel convertVectorToValueOp(CCL_WRITE(dst), CCL_READ(vector))
{
  READ_DECL(vector);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(vector, dst_coords, vector_pix);
  vector_pix.x = (vector_pix.x + vector_pix.y + vector_pix.z) / 3.0f;
  WRITE_IMG(dst, dst_coords, vector_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel convertRgbToYccOp(CCL_WRITE(dst), CCL_READ(color), int mode)
{
  READ_DECL(color);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(color, dst_coords, color_pix);
  color_pix = rgb_to_ycc(color_pix, mode);
  WRITE_IMG(dst, dst_coords, color_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel convertYccToRgbOp(CCL_WRITE(dst), CCL_READ(ycc), int mode)
{
  READ_DECL(ycc);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(ycc, dst_coords, ycc_pix);
  ycc_pix = ycc_to_rgb(ycc_pix, mode);
  WRITE_IMG(dst, dst_coords, ycc_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel convertRgbToYuvOp(CCL_WRITE(dst), CCL_READ(rgb))
{
  READ_DECL(rgb);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(rgb, dst_coords, rgb_pix);
  rgb_pix = rgb_to_yuv(rgb_pix);
  WRITE_IMG(dst, dst_coords, rgb_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel convertYuvToRgbOp(CCL_WRITE(dst), CCL_READ(yuv))
{
  READ_DECL(yuv);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(yuv, dst_coords, yuv_pix);
  yuv_pix = yuv_to_rgb(yuv_pix);
  WRITE_IMG(dst, dst_coords, yuv_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel convertRgbToHsvOp(CCL_WRITE(dst), CCL_READ(rgb))
{
  READ_DECL(rgb);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(rgb, dst_coords, rgb_pix);
  rgb_pix = rgb_to_hsv(rgb_pix);
  WRITE_IMG(dst, dst_coords, rgb_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel convertHsvToRgbOp(CCL_WRITE(dst), CCL_READ(hsv))
{
  READ_DECL(hsv);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(hsv, dst_coords, hsv_pix);
  hsv_pix = hsv_to_rgb(hsv_pix);
  WRITE_IMG(dst, dst_coords, hsv_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel convertPremulToStraightOp(CCL_WRITE(dst), CCL_READ(color))
{
  READ_DECL(color);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(color, dst_coords, color_pix);
  color_pix = premul_to_straight(color_pix);
  WRITE_IMG(dst, dst_coords, color_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel convertStraightToPremulOp(CCL_WRITE(dst), CCL_READ(color))
{
  READ_DECL(color);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(color, dst_coords, color_pix);
  color_pix = straight_to_premul(color_pix);
  WRITE_IMG(dst, dst_coords, color_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel separateChannel0Op(CCL_WRITE(dst), CCL_READ(color))
{
  READ_DECL(color);
  WRITE_DECL(dst);
  CPU_LOOP_START(dst);
  COORDS_TO_OFFSET(dst_coords);
  READ_IMG(color, dst_coords, color_pix);
  WRITE_IMG(dst, dst_coords, color_pix);
  CPU_LOOP_END
}

ccl_kernel separateChannel1Op(CCL_WRITE(dst), CCL_READ(color))
{
  READ_DECL(color);
  WRITE_DECL(dst);
  CPU_LOOP_START(dst);
  COORDS_TO_OFFSET(dst_coords);
  READ_IMG(color, dst_coords, color_pix);
  color_pix.x = color_pix.y;
  WRITE_IMG(dst, dst_coords, color_pix);
  CPU_LOOP_END
}

ccl_kernel separateChannel2Op(CCL_WRITE(dst), CCL_READ(color))
{
  READ_DECL(color);
  WRITE_DECL(dst);
  CPU_LOOP_START(dst);
  COORDS_TO_OFFSET(dst_coords);
  READ_IMG(color, dst_coords, color_pix);
  color_pix.x = color_pix.z;
  WRITE_IMG(dst, dst_coords, color_pix);
  CPU_LOOP_END
}

ccl_kernel separateChannel3Op(CCL_WRITE(dst), CCL_READ(color))
{
  READ_DECL(color);
  WRITE_DECL(dst);
  CPU_LOOP_START(dst);
  COORDS_TO_OFFSET(dst_coords);
  READ_IMG(color, dst_coords, color_pix);
  color_pix.x = color_pix.w;
  WRITE_IMG(dst, dst_coords, color_pix);
  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel combineChannelsOp(
    CCL_WRITE(dst), CCL_READ(ch0), CCL_READ(ch1), CCL_READ(ch2), CCL_READ(ch3))
{
  READ_DECL(ch0);
  READ_DECL(ch1);
  READ_DECL(ch2);
  READ_DECL(ch3);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(ch0, dst_coords, ch0_pix);
  READ_IMG(ch1, dst_coords, ch1_pix);
  READ_IMG(ch2, dst_coords, ch2_pix);
  READ_IMG(ch3, dst_coords, ch3_pix);
  ch0_pix.y = ch1_pix.x;
  ch0_pix.z = ch2_pix.x;
  ch0_pix.w = ch3_pix.x;
  WRITE_IMG(dst, dst_coords, ch0_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel idMaskOp(CCL_WRITE(dst), CCL_READ(input), const int obj_index)
{
  READ_DECL(input);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input, dst_coords, input_pix);
  input_pix.x = (roundf(input_pix.x) == obj_index) ? 1.0f : 0.0f;
  WRITE_IMG(dst, dst_coords, input_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathAddOp(CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), BOOL use_clamp)
{
  READ_DECL(input1);
  READ_DECL(input2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(input1_pix.x + input2_pix.x) :
                             input1_pix.x + input2_pix.x;
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathSubtractOp(CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), BOOL use_clamp)
{
  READ_DECL(input1);
  READ_DECL(input2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(input1_pix.x - input2_pix.x) :
                             input1_pix.x - input2_pix.x;
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathMultiplyOp(CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), BOOL use_clamp)
{
  READ_DECL(input1);
  READ_DECL(input2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(input1_pix.x * input2_pix.x) :
                             input1_pix.x * input2_pix.x;
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathDivideOp(CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), BOOL use_clamp)
{
  READ_DECL(input1);
  READ_DECL(input2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(input1_pix.x / input2_pix.x) :
                             input1_pix.x / input2_pix.x;
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathSineOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(sinf(input1_pix.x)) : sinf(input1_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathCosineOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(cosf(input1_pix.x)) : cosf(input1_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathTangentOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(tanf(input1_pix.x)) : tanf(input1_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathHiperbolicSineOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(sinhf(input1_pix.x)) : sinhf(input1_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathHiperbolicCosineOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(coshf(input1_pix.x)) : coshf(input1_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathHiperbolicTangentOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(tanhf(input1_pix.x)) : tanhf(input1_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathArcSineOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  if (input1_pix.x <= 1 && input1_pix.x >= -1) {
    input1_pix.x = use_clamp ? clamp_to_normal(asinf(input1_pix.x)) : asinf(input1_pix.x);
  }
  else {
    input1_pix.x = 0.0f;
  }
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathArcCosineOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  if (input1_pix.x <= 1 && input1_pix.x >= -1) {
    input1_pix.x = use_clamp ? clamp_to_normal(acosf(input1_pix.x)) : acosf(input1_pix.x);
  }
  else {
    input1_pix.x = 0.0f;
  }
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathArcTangentOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(atan(input1_pix.x)) : atan(input1_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathPowerOp(CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), BOOL use_clamp)
{
  READ_DECL(input1);
  READ_DECL(input2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  if (input1_pix.x >= 0) {
    input1_pix.x = powf(input1_pix.x, input2_pix.x);
  }
  else {
    float y_mod_1 = fmodf(input2_pix.x, 1);
    /* if input value is not nearly an integer, fall back to zero, nicer than straight rounding */
    if (y_mod_1 > 0.999f || y_mod_1 < 0.001f) {
      input1_pix.x = powf(input1_pix.x, floorf(input2_pix.x + 0.5f));
    }
    else {
      input1_pix.x = 0.0f;
    }
  }
  if (use_clamp) {
    input1_pix.x = clamp_to_normal(input1_pix.x);
  }
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathLogarithmOp(CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), BOOL use_clamp)
{
  READ_DECL(input1);
  READ_DECL(input2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  if (input1_pix.x > 0 && input2_pix.x > 0) {
    input1_pix.x = logf(input1_pix.x) / logf(input2_pix.x);
    if (use_clamp) {
      input1_pix.x = clamp_to_normal(input1_pix.x);
    }
  }
  else {
    input1_pix.x = 0.0f;
  }

  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathMinimumOp(CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), BOOL use_clamp)
{
  READ_DECL(input1);
  READ_DECL(input2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(fminf(input1_pix.x, input2_pix.x)) :
                             fminf(input1_pix.x, input2_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathMaximumOp(CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), BOOL use_clamp)
{
  READ_DECL(input1);
  READ_DECL(input2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(fmaxf(input1_pix.x, input2_pix.x)) :
                             fmaxf(input1_pix.x, input2_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathRoundOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(roundf(input1_pix.x)) : roundf(input1_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathLessThanOp(CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2))
{
  READ_DECL(input1);
  READ_DECL(input2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  input1_pix.x = input1_pix.x < input2_pix.x ? 1.0f : 0.0f;
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathGreaterThanOp(CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2))
{
  READ_DECL(input1);
  READ_DECL(input2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  input1_pix.x = input1_pix.x > input2_pix.x ? 1.0f : 0.0f;
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathModuloOp(CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), BOOL use_clamp)
{
  READ_DECL(input1);
  READ_DECL(input2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  if (input1_pix.x == 0.0f) {
    input1_pix.x = 0.0f;
  }
  else {
    input1_pix.x = use_clamp ? clamp_to_normal(fmodf(input1_pix.x, input2_pix.x)) :
                               fmodf(input1_pix.x, input2_pix.x);
  }
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathAbsoluteOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(fabsf(input1_pix.x)) : fabsf(input1_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathRadiansOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(DEG2RADF(input1_pix.x)) : DEG2RADF(input1_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathDegreesOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(RAD2DEGF(input1_pix.x)) : RAD2DEGF(input1_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathArcTan2Op(CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), BOOL use_clamp)
{
  READ_DECL(input1);
  READ_DECL(input2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(atan2f(input1_pix.x, input2_pix.x)) :
                             atan2f(input1_pix.x, input2_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathFloorOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(floorf(input1_pix.x)) : floorf(input1_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathCeilOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(floorf(input1_pix.x)) : floorf(input1_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathFractOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(input1_pix.x - floorf(input1_pix.x)) :
                             input1_pix.x - floorf(input1_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathSqrtOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  if (input1_pix.x > 0.0f) {
    input1_pix.x = use_clamp ? clamp_to_normal(sqrtf(input1_pix.x)) : sqrtf(input1_pix.x);
  }
  else {
    input1_pix.x = 0.0f;
  }

  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathInverseSqrtOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  if (input1_pix.x > 0.0f) {
    input1_pix.x = use_clamp ? clamp_to_normal(1.0f / sqrtf(input1_pix.x)) :
                               1.0f / sqrtf(input1_pix.x);
  }
  else {
    input1_pix.x = 0.0f;
  }
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathSignOp(CCL_WRITE(dst), CCL_READ(input1))
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = compatible_signf(input1_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathExponentOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = use_clamp ? clamp_to_normal(expf(input1_pix.x)) : expf(input1_pix.x);
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathTruncOp(CCL_WRITE(dst), CCL_READ(input1), BOOL use_clamp)
{
  READ_DECL(input1);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  input1_pix.x = (input1_pix.x >= 0.0f) ? floorf(input1_pix.x) : ceilf(input1_pix.x);
  if (use_clamp) {
    input1_pix.x = clamp_to_normal(input1_pix.x);
  }
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathSnapOp(CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), BOOL use_clamp)
{
  READ_DECL(input1);
  READ_DECL(input2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  if (input1_pix.x == 0.0f || input2_pix.x == 0.0f) {
    input1_pix.x = 0.0f;
  }
  else {
    input1_pix.x = floorf(input1_pix.x / input2_pix.x) * input2_pix.x;
  }
  if (use_clamp) {
    input1_pix.x = clamp_to_normal(input1_pix.x);
  }
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathWrapOp(
    CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), CCL_READ(input3), BOOL use_clamp)
{
  READ_DECL(input1);
  READ_DECL(input2);
  READ_DECL(input3);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  READ_IMG(input3, dst_coords, input3_pix);
  input1_pix.x = wrapf(input1_pix.x, input2_pix.x, input3_pix.x);
  if (use_clamp) {
    input1_pix.x = clamp_to_normal(input1_pix.x);
  }
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathPingPongOp(CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), BOOL use_clamp)
{
  READ_DECL(input1);
  READ_DECL(input2);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  input1_pix.x = fabsf(fractf((input1_pix.x - input2_pix.x) / (input2_pix.x * 2.0f)) *
                           input2_pix.x * 2.0f -
                       input2_pix.x);
  if (use_clamp) {
    input1_pix.x = clamp_to_normal(input1_pix.x);
  }
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathCompareOp(CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), CCL_READ(input3))
{
  READ_DECL(input1);
  READ_DECL(input2);
  READ_DECL(input3);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  READ_IMG(input3, dst_coords, input3_pix);
  input1_pix.x = (fabsf(input1_pix.x - input2_pix.x) <= fmaxf(input3_pix.x, 1e-5f)) ? 1.0f : 0.0f;
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathMultiplyAddOp(
    CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), CCL_READ(input3), BOOL use_clamp)
{
  READ_DECL(input1);
  READ_DECL(input2);
  READ_DECL(input3);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  READ_IMG(input3, dst_coords, input3_pix);
  input1_pix.x = input1_pix.x * input2_pix.x + input3_pix.x;
  if (use_clamp) {
    input1_pix.x = clamp_to_normal(input1_pix.x);
  }
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathSmoothMinOp(
    CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), CCL_READ(input3), BOOL use_clamp)
{
  READ_DECL(input1);
  READ_DECL(input2);
  READ_DECL(input3);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  READ_IMG(input3, dst_coords, input3_pix);
  input1_pix.x = smoothminf(input1_pix.x, input2_pix.x, input3_pix.x);
  if (use_clamp) {
    input1_pix.x = clamp_to_normal(input1_pix.x);
  }
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel mathSmoothMaxOp(
    CCL_WRITE(dst), CCL_READ(input1), CCL_READ(input2), CCL_READ(input3), BOOL use_clamp)
{
  READ_DECL(input1);
  READ_DECL(input2);
  READ_DECL(input3);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(input1, dst_coords, input1_pix);
  READ_IMG(input2, dst_coords, input2_pix);
  READ_IMG(input3, dst_coords, input3_pix);
  input1_pix.x = -smoothminf(-input1_pix.x, -input2_pix.x, input3_pix.x);
  if (use_clamp) {
    input1_pix.x = clamp_to_normal(input1_pix.x);
  }
  WRITE_IMG(dst, dst_coords, input1_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN
ccl_kernel setAlphaOp(CCL_WRITE(dst), CCL_READ(color), CCL_READ(alpha))
{
  READ_DECL(color);
  READ_DECL(alpha);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(color, dst_coords, color_pix);
  READ_IMG(alpha, dst_coords, alpha_pix);
  color_pix.w = alpha_pix.x;
  WRITE_IMG(dst, dst_coords, color_pix);

  CPU_LOOP_END
}
CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN

ccl_kernel scaleVariableOp(CCL_WRITE(dst),
                           CCL_READ(color),
                           CCL_READ(x_input),
                           CCL_READ(y_input),
                           CCL_SAMPLER(sampler),
                           float color_width,
                           float color_height,
                           float center_x,
                           float center_y,
                           BOOL relative)
{
  SAMPLE_DECL(color);
  READ_DECL(x_input);
  READ_DECL(y_input);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(x_input, dst_coords, x_input_pix);
  READ_IMG(y_input, dst_coords, y_input_pix);

  int2 color_coords;
  if (relative) {
    color_coords.x = center_x + (dst_coords.x - center_x) / x_input_pix.x;
    color_coords.y = center_y + (dst_coords.y - center_y) / y_input_pix.x;
  }
  else {
    color_coords.x = center_x + (dst_coords.x - center_x) / (x_input_pix.x / color_width);
    color_coords.y = center_y + (dst_coords.y - center_y) / (y_input_pix.x / color_height);
  }
  SAMPLE_IMG(color, color_coords, sampler, color_pix);
  WRITE_IMG(dst, dst_coords, color_pix);

  CPU_LOOP_END
}

ccl_kernel scaleFixedOp(CCL_WRITE(dst),
                        CCL_READ(input),
                        CCL_SAMPLER(sampler),
                        BOOL has_scale_offset,
                        float scale_offset_x,
                        float scale_offset_y,
                        float scale_rel_x,
                        float scale_rel_y)
{
  SAMPLE_DECL(input);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  int2 input_coords;
  if (has_scale_offset) {
    input_coords.x = ((dst_coords.x - scale_offset_x) * scale_rel_x);
    input_coords.y = ((dst_coords.y - scale_offset_y) * scale_rel_y);
  }
  else {
    input_coords.x = dst_coords.x * scale_rel_x;
    input_coords.y = dst_coords.y * scale_rel_y;
  }

  SAMPLE_IMG(input, input_coords, sampler, input_pix);
  WRITE_IMG(dst, dst_coords, input_pix);

  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN

ccl_kernel translateOp(CCL_WRITE(dst),
                       CCL_READ(color),
                       CCL_READ(x_input),
                       CCL_READ(y_input),
                       int color_width,
                       int color_height,
                       BOOL relative,
                       BOOL wrap_x,
                       BOOL wrap_y)

{
  READ_DECL(color);
  READ_DECL(x_input);
  READ_DECL(y_input);
  WRITE_DECL(dst);

  CPU_LOOP_START(dst);

  COORDS_TO_OFFSET(dst_coords);

  READ_IMG(x_input, dst_coords, x_input_pix);
  READ_IMG(y_input, dst_coords, y_input_pix);

  int2 color_coords;
  if (relative) {
    color_coords.x = dst_coords.x - x_input_pix.x * color_width;
    color_coords.y = dst_coords.y - y_input_pix.x * color_height;
  }
  else {
    color_coords.x = dst_coords.x - x_input_pix.x;
    color_coords.y = dst_coords.y - y_input_pix.x;
  }

  BOOL clip = FALSE;
  if (wrap_x) {
    color_coords.x = wrapf(color_coords.x, color_width, 0);
  }
  else {
    if (color_coords.x < 0 || color_coords.x >= color_width) {
      clip = TRUE;
    }
  }
  if (wrap_y) {
    color_coords.y = wrapf(color_coords.y, color_height, 0);
  }
  else {
    if (color_coords.y < 0 || color_coords.y >= color_height) {
      clip = TRUE;
    }
  }

  if (clip) {
    WRITE_IMG(dst, dst_coords, TRANSPARENT_PIXEL);
  }
  else {
    READ_IMG(color, color_coords, color_pix);
    WRITE_IMG(dst, dst_coords, color_pix);
  }

  CPU_LOOP_END
}

CCL_NAMESPACE_END
CCL_NAMESPACE_BEGIN

ccl_kernel bokehImageOp(CCL_WRITE(dst),
                        const float2 center,
                        const float circular_distance,
                        const float lensshift,
                        const float flap_rad,
                        const float flap_rad_add,
                        const float rounding,
                        const float catadioptric)
{
  float lensshift2 = lensshift / 2.0f;

  WRITE_DECL(dst);

  CPU_LOOP_START(dst);
  COORDS_TO_OFFSET(dst_coords);
  float2 dst_coordsf = make_float2(dst_coords.x, dst_coords.y);

  float insideBokehMax = bokehIsInside(
      circular_distance, dst_coordsf, center, flap_rad, flap_rad_add, rounding, catadioptric);
  float insideBokehMed = bokehIsInside(circular_distance - fabsf(lensshift2 * circular_distance),
                                       dst_coordsf,
                                       center,
                                       flap_rad,
                                       flap_rad_add,
                                       rounding,
                                       catadioptric);
  float insideBokehMin = bokehIsInside(circular_distance - fabsf(lensshift * circular_distance),
                                       dst_coordsf,
                                       center,
                                       flap_rad,
                                       flap_rad_add,
                                       rounding,
                                       catadioptric);

  float alpha = (insideBokehMax + insideBokehMed + insideBokehMin) / 3.0f;
  float4 result_pix = lensshift < 0 ?
                          make_float4(insideBokehMax, insideBokehMed, insideBokehMin, alpha) :
                          make_float4(insideBokehMin, insideBokehMed, insideBokehMax, alpha);

  WRITE_IMG(dst, dst_coords, result_pix);

  CPU_LOOP_END
}

CCL_NAMESPACE_END
